---
title: "HNSCC_scRNAseq_Descriptive_paper"
author: "Dillon Corvino"
date: "03/02/2020"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: united
    highlight: tango
    df_print: paged
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

Built with R version `r getRversion()`

## Setup {.tabset}

### Dataset information
```{r Dataset_Info}

# HNSCC scRNAseq/scTCRseq dataset
# Cells are HNSCC TILs sorted on Lymphocytes/Live/CD3+/CD4-/CD8+
# Human samples
# Each sample is a pool of 4 patients
# samples 1 and 2 are unstimulated 
# samples 3 and 4 are stimulated 
# Patients in sample 1 match patients in sample 3 and sample 2 pairs with 4
# Data acquired was transcript expression, ADT (antibody expression), and TCRA & B sequences
# This analysis uses just Transcript and TCR data


# General information
# CellRanger was used for sequence alignment/QC/counts/TCR calls - performed by Ross (QIMR, Brisbane, Aus)
# DC was provided the output from CellRanger (counts matrix) and used this as input for analysis within this script

```

### Environment
```{r Environment_setup, message = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,  
  eval = TRUE, 
  tidy = TRUE
)

# Environment Set up
rm(list = ls()) #Clean workspace
cat("\014")     #Clean Console
gc() # Free memory

# pipeline variables
start.time <- Sys.time()
quick.load <- TRUE
long.compute <- FALSE

###################
# Install packages
###################

# CITEseq requires latest version of Seurat i.e at least V3
# To install the development version of seurat
# devtools::install_github(repo = 'satijalab/seurat', ref = 'develop')

pkgs <- c("remedy", "Seurat", "dplyr", "rstudioapi",
          "cowplot", "ggplot2", "grid", "gridExtra",
          "styler", "stringr", "inlmisc", "RColorBrewer",
          "readxl", "devtools", "tidyverse", "hdf5r", "scales", "useful")

for(i in 1:length(pkgs)){
  if(!require(pkgs[i], character.only = T)){
    install.packages(pkgs[i])
    require(pkgs[i], character.only = T)
  }else{
    require(pkgs[i], character.only = T)
  }
}

pkgs <- c("gplots", "fgsea", "biomaRt", "clusterProfiler", 
          "GSEABase", "org.Hs.eg.db", "org.Mm.eg.db", "pcaMethods",
          "SingleCellExperiment", "batchelor", "DelayedArray", "DelayedMatrixStats",
          "limma", "SummarizedExperiment")

for(i in 1:length(pkgs)){
  if(!require(pkgs[i], character.only = T)){
    BiocManager::install(pkgs[i])
    require(pkgs[i], character.only = T)
  }else{
    require(pkgs[i], character.only = T)
  }
}


#####################
# Github packages
#####################

# Installed packages 

# library("devtools")

# usethis::browse_github_pat()
# usethis::edit_r_environ()
# GITHUB_PAT = "d8207153aef7b295cdf66eb1e1b2a2ed38b0ca18"
# R_MAX_VSIZE = 30Gb

# celltalker
#devtools::install_github("arc85/celltalker")

# Scillus 
#devtools::install_github("xmc811/Scillus", ref = "development")

#devtools::install_github('satijalab/seurat-data')

#devtools::install_github("velocyto-team/velocyto.R")

#devtools::install_github("dynverse/dyno")

#devtools::install_github('cole-trapnell-lab/leidenbase')
#devtools::install_github('cole-trapnell-lab/monocle3')

#devtools::install_github("immunomind/immunarch")
#devtools::install_github("Coolgenome/iTALK", build_vignettes = TRUE)

#########################
# Failed installations
#########################

# I have been getting a killed:9 error installing the following github packages. 
# I believe the issue is clang or something to do with the compiler. Unable to fix the issue. Many open github issues on this error

# For using scRep package I have made a work around to get access to the functions
#devtools::install_github("ncborcherding/scRepertoire")

#devtools::install_github('satijalab/seurat-wrappers')


# Moncle packages to load 
#library(monocle3)
#library(Seurat)
#library(SeuratData)
#library(SeuratWrappers)
#library(ggplot2)
#library(patchwork)
#library(magrittr)


#.rs.restartR()


# Failed
#remotes::install_git("https://gitlab.unil.ch/carmona/ProjecTILs.git", ref = "v0.4.1")

# TILPRED install works, but only currently for mouse datasets
#remotes::install_github("carmonalab/TILPRED")


####################
# Colour scheme
####################

Condition.cols <- c("turquoise", "red")

clust.cols <- c("#E41A1C", # Naive_like_1_CM
                "#A6761D", # Naive_like_2_SC
                "#8DA0CB", # Naive_like_3
                "#666666", # Cytotoxic
                "#A6D854", # Type_I_IFN
                "#984EA3", # Stimulated_1
                "#1B9E77", # Stimulated_exhausted
                "#D95F02", # Exhausted_1
                "#7570B3", # Exhausted_2
                "#E7298A", # TRM
                "#E6AB02", # gd_T_g9d2
                "#8DD3C7", # gd_T_non_g9d2
                "#FF7F00", # MAIT 
                "#E78AC3") # Proliferative


module.cols <- c("#E41A1C", # Naive_Stem
                 "#1B9E77", # Activated
                 "#7570B3", # Exhaustion
                 "#FF7F00", # Innate
                 "#E78AC3") # Cycling

# Set working directory to source file location
setwd(dirname(getActiveDocumentContext()$path))
working.dir <- getwd()

# create output directories
if(!dir.exists("Exported_RDS_files")){dir.create("Exported_RDS_files", recursive = T)}
if(!dir.exists("output")){dir.create("output", recursive = T)}
if(!dir.exists("output/figures")){dir.create("output/figures", recursive = T)}
if(!dir.exists("output/tables")){dir.create("output/tables", recursive = T)}
if(!dir.exists("output/QC")){dir.create("output/QC", recursive = T)}


# load saved seurat object with cluster annotations and imputation performed
if(quick.load){
  seurat.combined <- readRDS("Exported_RDS_files/seurat_combined.rds")
}


```

### Reading data
```{r reading_data}

# Load dataset from output generated by Ross, file is annotated as filtered_feature_bc_matrix

Sample1.data <- Read10X(data.dir = "Input_data/GEX_filtered_feature_bc_matrix_GEX_Only/Sample1_US/")
Sample2.data <- Read10X(data.dir = "Input_data/GEX_filtered_feature_bc_matrix_GEX_Only/Sample2_US/")
Sample3.data <- Read10X(data.dir = "Input_data/GEX_filtered_feature_bc_matrix_GEX_Only/Sample3_Stim/")
Sample4.data <- Read10X(data.dir = "Input_data/GEX_filtered_feature_bc_matrix_GEX_Only/Sample4_Stim/")


Sample1.seurat <- CreateSeuratObject(
  counts = Sample1.data,
  min.cells = 3,
  min.features = 200
)

Sample2.seurat <- CreateSeuratObject(
  counts = Sample2.data,
  min.cells = 3,
  min.features = 200
)

Sample3.seurat <- CreateSeuratObject(
  counts = Sample3.data,
  min.cells = 3,
  min.features = 200
)

Sample4.seurat <- CreateSeuratObject(
  counts = Sample4.data,
  min.cells = 3,
  min.features = 200
)


```

### Merge Seurat objects
```{r merge_seurat}


######################
# Merge samples
######################

# Unstimulated samples 1 & 2
US.seurat <- merge(x = Sample1.seurat, 
                   y = Sample2.seurat,
                   add.cell.ids = c("S1", "S2"), 
                   merge.data = FALSE, # Should normed data be merged as well or just raw data slot
                   project = "Unstimulated")

x <- ncol(Sample1.seurat) + ncol(Sample2.seurat)
paste0("expected number of cells after merge is ", ncol(US.seurat) == x)

Sample1.seurat # 14,695 genes and 3,042 cells
Sample2.seurat # 14,706 genes and 3,536 cells
US.seurat # 15,428 genes and 6,578 cells

head(US.seurat@meta.data)


# Stimulated samples 3 & 4
Stim.seurat <- merge(x = Sample3.seurat, 
                     y = Sample4.seurat,
                     add.cell.ids = c("S3", "S4"), 
                     merge.data = FALSE, # Should normed data be merged as well or just raw data slot
                     project = "Stimulated")

x <- ncol(Sample3.seurat) + ncol(Sample4.seurat)
paste0("expected number of cells after merge is ", ncol(Stim.seurat) == x)

Sample3.seurat # 14,740 genes and 3,885 cells
Sample4.seurat # 14,926 genes and 3,279 cells
Stim.seurat # 15,619 genes and 7,164 cells

head(Stim.seurat@meta.data)



# Add a condition metadata column
US.seurat@meta.data$condition <- "US"
Stim.seurat@meta.data$condition <- "Stim"


```

### Remove large variables that are no longer needed
```{r Remove_unneeded_variables}

rm(Sample1.data, 
   Sample2.data, 
   Sample3.data, 
   Sample4.data,
   S1.Clonotype.df, 
   S2.Clonotype.df,
   S3.Clonotype.df,
   S4.Clonotype.df,
   S1.TCR.df, 
   S2.TCR.df,
   S3.TCR.df,
   S4.TCR.df,
   Sample1.seurat, 
   Sample2.seurat,
   Sample3.seurat,
   Sample4.seurat)


```

## QC and Normalisation {.tabset}

### QC & Normalisation

**Note: No need to normalize here if you are just going to combine and renormalize - doesn't effect results at all because the integration step is using counts.** 

```{r QC_and_normalisation}


# QC metrics commonly used
# The number of unique genes detected in each cell.
# Low-quality cells or empty droplets will often have very few genes
# Cell doublets or multiplets may exhibit an aberrantly high gene count

# Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes)

# The percentage of reads that map to the mitochondrial genome
# Low-quality / dying cells often exhibit extensive mitochondrial contamination


################################################
#  Get percentage Mitochondria gene expression
################################################

# Unstimulated
US.seurat[["percent.mito"]] <- PercentageFeatureSet(US.seurat, pattern = "^MT-")

# Stimulated
Stim.seurat[["percent.mito"]] <- PercentageFeatureSet(Stim.seurat, pattern = "^MT-")

##################################
# Plot mitochondria percentage
##################################

# nFeature & nCount & Mito (US)
VlnPlot(object = US.seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))
dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_US.pdf")
dev.off()

# Mito (US)
VlnPlot(US.seurat, features = "percent.mito", y.max = 20)
dev.copy(pdf, "output/QC/QC_RNA_percentMito_US.pdf")
dev.off()

# nFeature & nCount & Mito (Stim)
VlnPlot(object = Stim.seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))
dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Stim.pdf")
dev.off()

# Mito (Stim)
VlnPlot(Stim.seurat, features = "percent.mito", y.max = 20)
dev.copy(pdf, "output/QC/QC_RNA_percentMito_Stim.pdf")
dev.off()



########################################
# Count vs Mito & Count vs Feature
########################################

# Unstimulated
plot1 <- FeatureScatter(US.seurat, feature1 = "nCount_RNA", feature2 = "percent.mito")
plot2 <- FeatureScatter(US.seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(plot1, plot2))
dev.copy(pdf, "output/QC/QC_RNA_percentMito_nCount_nFeature_corr_US.pdf")
dev.off()

# Stimulated
plot1 <- FeatureScatter(Stim.seurat, feature1 = "nCount_RNA", feature2 = "percent.mito")
plot2 <- FeatureScatter(Stim.seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(plot1, plot2))
dev.copy(pdf, "output/QC/QC_RNA_percentMito_nCount_nFeature_corr_Stim.pdf")
dev.off()


############################
# Structure and metadata 
############################

# Unstimulated
head(US.seurat@meta.data)
str(US.seurat@meta.data)

# Stimulated
head(Stim.seurat@meta.data)
str(Stim.seurat@meta.data)

###################
#  Filter cells
###################

# Seurat recommends removing cells with <200 or >2,500 genes or >10% mito genes

# Unstimulated
US.seurat.filt <- subset(US.seurat,
                         subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mito < 10)


# Post-filtering metrics

US.seurat # 15,429 genes across 6,584 cells
US.seurat.filt # 15,429 genes across 5,785 cells

# Therefore
6584 - 5785
# 799 cells were deleted

# Stimulated
Stim.seurat.filt <- subset(Stim.seurat,
                           subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mito < 10)

# Post-filtering metrics

Stim.seurat # 15,618 genes across 7,167 cells
Stim.seurat.filt # 15,618 genes across 6,042 cells

# Therefore
7167 - 6042
# 1125 cells were deleted


##########################################
# Visualise QC metrics after filtering
##########################################

# Unstimulated

# Before Filtering
VlnPlot(object = US.seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))

# After filtering
VlnPlot(object = US.seurat.filt, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))
dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Post_filtering_US.pdf")
dev.off()

# Stimulated

# Before Filtering
VlnPlot(object = Stim.seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))

# After filtering
VlnPlot(object = Stim.seurat.filt, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))
dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Post_filtering_Stim.pdf")
dev.off()



################################################
# Normalise, scale & find variable genes 
################################################

#################
# Unstimulated
#################

# Normalise
US.seurat.filt <- NormalizeData(
  object = US.seurat.filt,
  assay = "RNA",
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  verbose = TRUE
)

# Find variable genes
US.seurat.filt <- FindVariableFeatures(
  object = US.seurat.filt,
  verbose = TRUE
)

# Scale data
US.seurat.filt <- ScaleData(
  object = US.seurat.filt,
  assay = "RNA",
  vars.to.regress = c("nCount_RNA", "percent.mito"),
  model.use = "linear",
  do.scale = TRUE,
  do.center = TRUE,
  verbose = TRUE
)

#################
# Stimulated
#################

# Normalise
Stim.seurat.filt <- NormalizeData(
  object = Stim.seurat.filt,
  assay = "RNA",
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  verbose = TRUE
)

# Find variable genes
Stim.seurat.filt <- FindVariableFeatures(
  object = Stim.seurat.filt,
  verbose = TRUE
)

# Scale data
Stim.seurat.filt <- ScaleData(
  object = Stim.seurat.filt,
  assay = "RNA",
  vars.to.regress = c("nCount_RNA", "percent.mito"),
  model.use = "linear",
  do.scale = TRUE,
  do.center = TRUE,
  verbose = TRUE
)


###############################
# Remove unneeded variables
###############################

rm(US.seurat, Stim.seurat)


```

## Combine treatment conditions {.tabset}

### Integrate data
```{r Integrate_across_conditions}

# Set activate assay to RNA
DefaultAssay(US.seurat.filt) <- "RNA"
DefaultAssay(Stim.seurat.filt) <- "RNA"

# Create list of seurat objects
seurat.list <- list(US = US.seurat.filt, Stim = Stim.seurat.filt)

# Find Integration Anchors
immune.anchors <- FindIntegrationAnchors(object.list = seurat.list, 
                                         anchor.features = 2000, 
                                         scale = TRUE, 
                                         normalization.method = "LogNormalize", 
                                         reduction = "cca", 
                                         l2.norm = TRUE,
                                         dims = 1:30,
                                         k.anchor = 5,
                                         k.filter = 200,
                                         k.score = 30,
                                         max.features = 200,
                                         nn.method = "rann",
                                         eps = 0,
                                         verbose = TRUE)

# Integrate dataset
seurat.combined <- IntegrateData(anchorset = immune.anchors,
                                 new.assay.name = "integrated",
                                 normalization.method = "LogNormalize",
                                 dims = 1:30,
                                 k.weight = 100,
                                 sd.weight = 1,
                                 verbose = TRUE)


# Basic overview of data
seurat.combined # 11,827 cells and 18,295 genes 

US.seurat.filt # 5,785 cells
Stim.seurat.filt # 6,042 cells


# Save files 
saveRDS(US.seurat.filt, file = "Exported_RDS_files/US_seurat_filt.rds")
saveRDS(Stim.seurat.filt, file = "Exported_RDS_files/Stim_seurat_filt.rds")

# Remove unnecessary data
rm(US.seurat.filt)
rm(Stim.seurat.filt)


# Format metadata in integrated seurat object
seurat.combined@meta.data$condition <- factor(seurat.combined@meta.data$condition, levels = c("US", "Stim"))



```

## Clustering and dim reduction {.tabset}

### PCA and cluster identificaton

**Note: What is the basis for the parameters you selected? Did you try others? Same for the UMAP below?**
```{r Cluster_data}

DefaultAssay(seurat.combined) <- "integrated"

# Scale data
seurat.combined <- ScaleData(seurat.combined, 
                             verbose = TRUE)

# Run PCA
seurat.combined <- RunPCA(seurat.combined, 
                          npcs = 30, 
                          verbose = TRUE)

# Find Neighbors
seurat.combined <- FindNeighbors(seurat.combined, 
                                 reduction = "pca", 
                                 k.param = 20,
                                 dims = 1:20)

# Find clusters
seurat.combined <- FindClusters(seurat.combined, 
                                random.seed = 42,
                                resolution = 0.4) # 0.4 is cluster resolution decided upon


```

### Run UMAP

**Note: If there are a number of samples pooled together for each sequencing run - is there a way to tell them apart in the data? I know you have S1, S2, etc, but each of these are comprise of multiple samples? How do you know we are not just seeing difference between patients?**
```{r UMAP}

# Create output directory
if(!dir.exists("output/figures/UMAP_no_clusts_removed")){
  dir.create("output/figures/UMAP_no_clusts_removed", 
             recursive = T)
}


# Run UMAP
seurat.combined <- RunUMAP(object = seurat.combined,
                           reduction = "pca",
                           dims = 1:20,
                           umap.method = "uwot",
                           n.neighbors = 30, # 5 to 50
                           min.dist = 0.3, # Sensible values are in the range 0.001 to 0.5
                           seed.use = 42)


# Plot UMAP projection
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + ggtitle("Integrated (n.neigh = 30 & min.dist = 0.3)")

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_clusts_clust.pdf")
dev.off()



# UMAP projection grouped by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         cols = Condition.cols,
         group.by = "condition") + ggtitle("UMAP vis by Condition") 

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_condition.pdf")
dev.off()



p1 <- DimPlot(seurat.combined, 
              reduction = "umap", 
              cols = Condition.cols,
              group.by = "condition")

p2 <- DimPlot(seurat.combined, 
              reduction = "umap", 
              label = TRUE)

p1|p2

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_clusters_conditions_sidebyside.pdf")
dev.off()


```

## Remove uninformative clusters {.tabset}

### Visualise and justify removing clusters 
```{r Justify_clusts_to_remove}

# Based on resolution of 0.4 for cluster identification 
# Cluster #15 and 13 are to be removed 
# 15 = Myeloid population 
# 13 = ?? 


# Create output directory
if(!dir.exists("output/figures/Cluster_removal_validation")){
  dir.create("output/figures/Cluster_removal_validation", 
             recursive = T)
}


# Show overall number and frequency of clusters

x <- table(seurat.combined@meta.data$seurat_clusters)
y <- prop.table(table(seurat.combined@meta.data$seurat_clusters))*100

barplot(x, 
        main = "# of cells per cluster", 
        xlab = "Cluster #", 
        ylab = "# of cells",
        cex.names = 0.8, 
        ylim = c(0, 2000))

dev.copy(pdf, "output/figures/Cluster_removal_validation/Number_cells_per_cluster.pdf")
dev.off()

barplot(y,
        main = "% of cells per cluster",
        xlab = "Cluster #",
        ylab = "% of cells",
        cex.names = 0.8, 
        ylim = c(0, 20))

dev.copy(pdf, "output/figures/Cluster_removal_validation/Percent_cells_per_cluster.pdf")
dev.off()


##########################################################################################
# Get differentially expressed genes for clusters to be removed and show heatmaps
##########################################################################################

# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

################
# Positive only
################

# Find markers for clust 13
Clust.13.Markers <- FindMarkers(seurat.combined,
                                assay = "RNA",
                                ident.1 = "13",
                                only.pos = TRUE,
                                min.diff.pct = 0.1,
                                return.thresh = 0.05)


# Find markers for clust 15
Clust.15.Markers <- FindMarkers(seurat.combined,
                                assay = "RNA",
                                ident.1 = "15",
                                only.pos = TRUE,
                                min.diff.pct = 0.1,
                                return.thresh = 0.05)

###################
# Heatmap vis
###################

# Downsample for heatmap vis
seurat.combined.small <- subset(seurat.combined, downsample = 300)

# Heatmap of Clust 13 markers
sig.genes <- Clust.13.Markers[Clust.13.Markers$p_val_adj < 0.1, ]




# Heatmap of Clust 15 markers
sig.genes <- Clust.15.Markers[Clust.15.Markers$p_val_adj < 0.1, ]








# Plot DEGs as heatmap for vis justification for removal


```

### Use Clustifyr to call cluster identities

**Note: What is up with the mouse.ref here?**
```{r Clustifyr_cell_ID}

# Create output directories
if(!dir.exists("output/figures/Cell_type_annotation/Clustifyr")){
  dir.create("output/figures/Cell_type_annotation/Clustifyr", 
             recursive = T)
}


#devtools::install_github("rnabioco/clustifyr")
library(clustifyr)

mouse.ref <- cbmc_ref
rownames(mouse.ref) <- str_to_title(rownames(mouse.ref))


res <- clustify(input = seurat.combined,
                cluster_col = "seurat_clusters",
                ref_mat = cbmc_ref,
                seurat_out = FALSE,
                query_genes = seurat.combined@assays$integrated@var.features)


res2 <- cor_to_call(cor_mat = res,                  # matrix correlation coefficients
                    cluster_col = "seurat_clusters") # name of column in meta.data containing cell clusters



print(plot_cor_heatmap(cor_mat = res))
dev.copy(pdf, "output/figures/Cell_type_annotation/Clustifyr/Heatmap_cluster_annotations.pdf")
dev.off()


```

### Use various SingleR databases to call cluster identities

Conversiobn of mouse genes to human using toupper() is only an approximation as many genes (especially in immunology) are different than just all capitalized version of mouse genes. I do not think you are using the immgen for your annotation, but just a note here. 
```{r SingleR_cell_clasification}

# Create output directory
if(!dir.exists("output/figures/Cell_type_annotation/SingleR")){
  dir.create("output/figures/Cell_type_annotation/SingleR", 
             recursive = T)
}

# Load package
#BiocManager::install("SingleR")
library(SingleR)

################################################################
# Use a couple databased to get broad overview of clusters 
################################################################

##################################
# Use HumanPrimaryCellAtlasData
##################################
# Info: Human, Microarray, 713 samples, 37 main labels, 157 fine lables, Non-specific focus

HumanPrimaryCellAtlasData.data <- HumanPrimaryCellAtlasData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = HumanPrimaryCellAtlasData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = HumanPrimaryCellAtlasData.data$label.fine)

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_HumanPrimaryCellAtlasData_db.pdf")
dev.off()

##########################
# Use BlueprintEncodeData
##########################
# Info: Human, RNAseq, 259 samples, 24 main labels, 43 fine lables, Non-specific focus

BlueprintEncodeData.data <- BlueprintEncodeData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = BlueprintEncodeData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = BlueprintEncodeData.data$label.fine)

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_BlueprintEncodeData_db.pdf")
dev.off()

##########################################
# Use NovershternHematopoieticData
##########################################
# Info: Human, Microarray, 211 samples, 17 main labels, 38 fine lables, Hematopoietic & Immune focus

NovershternHematopoieticData.data <- NovershternHematopoieticData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = NovershternHematopoieticData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = NovershternHematopoieticData.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_NovershternHematopoietic_db.pdf")
dev.off()

#####################
# Use ImmGenData
#####################
# Info: Mouse, Microarray, 830 samples, 20 main labels, 253 fine lables, Hematopoietic & Immune focus

ImmGen.data <- ImmGenData()

# Convert GeneID to match human
ImmGen.data.counts <- ImmGen.data@assays@data$logcounts
rownames(ImmGen.data.counts) <- toupper(rownames(ImmGen.data.counts))


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = ImmGen.data.counts, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = ImmGen.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_ImmGen_db.pdf")
dev.off()




################################################################
# Most useful database is probably the MonacoImmuneData
################################################################

#########################
# Use MonacoImmuneData
#########################
# Info: Human, RNAseq, 114 samples, 11 main labels, 29 fine lables, Immune cell focus
Immune.data <- MonacoImmuneData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = Immune.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = Immune.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_Monaco_db.pdf")
dev.off()


# Restrict labels to biologicaly relevant 
Immune.data.counts <- Immune.data@assays@data$logcounts

pattern <- c("CD8", "MAIT", "gd", "Intermediate")

labels.keep <- grepl(paste0(pattern, collapse = "|"), Immune.data$label.fine)

Immune.data.counts <- Immune.data.counts[,labels.keep]

SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = Immune.data.counts, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = Immune.data$label.fine[labels.keep])

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_limited_labels_Monaco_db.pdf")
dev.off()


```

### Myeloid and Mitochondrial populations
```{r Remove_clusters}

# Remove cluster 13 and 15
seurat.combined <- subset(seurat.combined, idents = c(0:12, 14))

# Check clusters are removed
levels(seurat.combined@meta.data$seurat_clusters)

# Save old cluster IDs
seurat.combined@meta.data$seurat_clusters_old <- seurat.combined@meta.data$seurat_clusters


```

## Recalculate UMAP and Visualise {.tabset}

### Recalculate UMAP
```{r Recalculate_UMAP}

###########################
# Recalculate UMAP
###########################

DefaultAssay(seurat.combined) <- "integrated"

# Scale data
seurat.combined <- ScaleData(seurat.combined, 
                             verbose = TRUE)

# Run PCA
seurat.combined <- RunPCA(seurat.combined, 
                          npcs = 30, 
                          verbose = TRUE)

# Find Neighbors
seurat.combined <- FindNeighbors(seurat.combined, 
                                 reduction = "pca", 
                                 k.param = 20,
                                 dims = 1:20)

# Find clusters
seurat.combined <- FindClusters(seurat.combined, 
                                random.seed = 42,
                                resolution = 0.4)


# Run UMAP
seurat.combined <- RunUMAP(object = seurat.combined,
                           reduction = "pca",
                           dims = 1:20,
                           umap.method = "uwot",
                           n.neighbors = 30, # 5 to 50
                           min.dist = 0.3, # Sensible values are in the range 0.001 to 0.5
                           seed.use = 42)

```

### Vis new UMAP
```{r Visualise_new_UMAP_projection}

# Create output directory
if(!dir.exists("output/figures/UMAP")){
  dir.create("output/figures/UMAP", 
             recursive = T)
}


Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters_new

# Plot UMAP projection
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + 
  ggtitle("UMAP new projection and clust IDs")

dev.copy(pdf, "output/figures/UMAP/UMAP_new_clust_IDs_numbered.pdf")
dev.off()

# Plot UMAP projection with old clust IDs
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters_old

UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + 
  ggtitle("UMAP new projection - original clust IDs")

dev.copy(pdf, "output/figures/UMAP/UMAP_original_clust_IDs_numbered.pdf")
dev.off()

```

### Rename clusters
```{r rename_clusters}

# Name clusters

# Save cluster IDs - new ids = those after removal of clusters
seurat.combined@meta.data$seurat_clusters_new <- seurat.combined@meta.data$seurat_clusters

# Set Idents to cluster IDs following cluster removal 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Rename classes.
seurat.combined <- RenameIdents(object = seurat.combined,
                                `0` = "Cytotoxic",
                                `1` = "Naive_like_3",
                                `2` = "Exhausted_1", 
                                `3` = "Type_I_IFN",
                                `4` = "Naive_like_1_CM", # Central memory?
                                `5` = "Naive_like_2_SC", # Stem-cell-like
                                `6` = "Stimulated_1", # Derived from cytotoxic ?
                                `7` = "Stimulated_exhausted",
                                `8` = "gd_T_non_g9d2", 
                                `9` = "Exhausted_2",
                                `10` = "MAIT", 
                                `11` = "TRM", 
                                `12` = "gd_T_g9d2", 
                                `13` = "Proliferative")


# Relevel idents variable to group clusters into order of future modules 

# Module: Naive / Stem-like 
# Naïve_like_1_CM
# Naïve_like_2_SC
# Naïve_like_3

# Module: Activated
# Cytotoxic
# Type_I_IFN
# Stimulated_1

# Module: Exhaustion
# Stimulated_exhausted
# Exhausted_1, 
# Exhausted_2
# TRM

# Module: Innate
# gd_T_g9d2
# gd_T_non_g9d2 
# MAIT 

# Module: Cycling
# Proliferative


# reset levels of factor variable 
seurat.combined@active.ident <- factor(seurat.combined@active.ident, 
                                       levels = c("Naive_like_1_CM",
                                                  "Naive_like_2_SC", 
                                                  "Naive_like_3", 
                                                  "Cytotoxic",
                                                  "Type_I_IFN",
                                                  "Stimulated_1",
                                                  "Stimulated_exhausted",
                                                  "Exhausted_1",
                                                  "Exhausted_2", 
                                                  "TRM", 
                                                  "gd_T_g9d2", 
                                                  "gd_T_non_g9d2", 
                                                  "MAIT",
                                                  "Proliferative"))



# Change "seurat_clusters" metadata label to new ident names as this slot is used in downstream plotting
seurat.combined@meta.data$seurat_clusters <- Idents(seurat.combined)

```

### UMAP with Named clusters
```{r Vis_Named_Clusters_UMAP}

# Create output directory
if(!dir.exists("output/figures/UMAP")){
  dir.create("output/figures/UMAP", 
             recursive = T)
}


##########################################
# Plot UMAPs with cluster names
##########################################


Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# UMAP named clusters
UMAPPlot(object = seurat.combined,
         pt.size = 1,
         label = FALSE, 
         cols = clust.cols) + 
  ggtitle("UMAP named clusters")

dev.copy(pdf, "output/figures/UMAP/UMAP_clusters.pdf")
dev.off()

# UMAP named clusters - labeled 
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         pt.size = 1,
         label.size = 6,
         cols = clust.cols) + 
  NoLegend() +
  ggtitle("UMAP named clusters")

dev.copy(pdf, "output/figures/UMAP/UMAP_clusters_labeled.pdf")
dev.off()


#############
# Condition
#############

# Split by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "condition",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by condition")

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_conditions.pdf")
dev.off()

# Split by condition // No legend
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "condition",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by condition") + 
  NoLegend()

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_conditions_Nolegend.pdf")
dev.off()

# Group by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         group.by = "condition",
         cols = Condition.cols,
         label.size = 6) + 
  ggtitle("UMAP group by condition")

dev.copy(pdf, "output/figures/UMAP/UMAP_groupby_conditions.pdf")
dev.off()


#############
# Sample
#############

# Split by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "group",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by Sample")

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_sample.pdf")
dev.off()


# Group by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         group.by = "group",
         pt.size = 1,
         label.size = 6) + 
  ggtitle("UMAP group by Sample")

dev.copy(pdf, "output/figures/UMAP/UMAP_groupby_sample.pdf")
dev.off()







```

### Saving dim reduction Embeddings to metadata

**Note: Never thought of doing this, but for sure this will be in ever analysis I do from here on out!!!**
```{r Save_dimreduction_embeddings}

# UMAP embeddings
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$umap@cell.embeddings[,1], "UMAP_1")
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$umap@cell.embeddings[,2], "UMAP_2")

# Save PCA (Dim 1 and 2) embeddings
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$pca@cell.embeddings[,1], "PCA_1")
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$pca@cell.embeddings[,2], "PCA_2")

head(seurat.combined@meta.data)

```

## Group clusters into modules {.tabset}

### Create Modules



```{r Create_modules}

# Create output directory
if(!dir.exists("output/figures/Modules")){
  dir.create("output/figures/Modules", 
             recursive = T)
}


# Group clusters together into functional modules 
# Module aggregation based on visualisation and analysis of DEGs in each cluster 


# Use numeric cluster IDs followin myeloid and mitochondrial cluster removal 
# use numeric ids as allows easy changing of cluster names without impacting module creation

# Exhaustion module
# 2, 7, 9, 11 (NB 11 is likely Tissue_resident)

# Activated
# 0, 3, 6

# Innate
# 8, 10, 12

# Naive / Stem-like 
# 1, 4, 5

# Cycling
# 13


# Get cluster IDs
Module.groups <- seurat.combined@meta.data$seurat_clusters_new
Module.groups <- as.numeric(as.character(Module.groups)) # need to remove factorisation

#######################################################
# Assign cluster IDs to module groups // use ^ and $ start and end anchors to create exact match, exclude selecting 11 for grep("1") etc
#######################################################

# Exhaustion Module \\ 2, 7, 9, 11
logic.vec <- grepl(paste0(c("^2$", "^7$", "^9$", "^11$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Exhaustion"

# Activated Module \\ 0, 3, 6
logic.vec <- grepl(paste0(c("^0$", "^3$", "^6$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Activated"

# Innate Module \\ 8, 10, 12
logic.vec <- grepl(paste0(c("^8$", "^10$", "^12$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Innate"

# Naive/Stem-like Module \\ 1, 4, 5
logic.vec <- grepl(paste0(c("^1$", "^4$", "^5$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Naive_Stem"

# Cycling Module \\ 13
logic.vec <- grepl("^13$", Module.groups)
Module.groups[logic.vec] <- "Cycling"


# Assign Module groups to metadata
seurat.combined@meta.data$Module <- factor(Module.groups,
                                           levels = c("Naive_Stem",
                                                      "Activated", 
                                                      "Exhaustion", 
                                                      "Innate", 
                                                      "Cycling"))


##############################
# UMAP vis of module grouping
##############################

# Plot clusters
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

p1 <- UMAPPlot(object = seurat.combined,
               label = TRUE, 
               pt.size = 1,
               label.size = 6) + 
  NoLegend() +
  ggtitle("Clusters")


# Plot modules
Idents(seurat.combined) <- seurat.combined@meta.data$Module

p2 <- UMAPPlot(object = seurat.combined,
               label = FALSE, 
               pt.size = 1,
               label.size = 6) + 
  ggtitle("Modules")


# Plot side by side
p1|p2


dev.copy(pdf, "output/figures/Modules/UMAP_Clusts_to_Modules.pdf")
dev.off()

```

### Create Cluster/Module by condition metadata
```{r Generate_metadata_for_Cluster_Module_by_Condition}

######################################################
# Create additional Metadata for downstream analysis
######################################################
# Now that clusters are cleaned and renamed 
# Generate a joint cluster/Module & condition_ID variable

# Using named clusters
seurat.combined@meta.data$condition_clust <- paste(seurat.combined@meta.data$condition, 
                                                   seurat.combined@meta.data$seurat_clusters, sep = "_")

# Using numeric cluster IDs
seurat.combined@meta.data$condition_clust_numeric <- paste(seurat.combined@meta.data$condition, 
                                                           seurat.combined@meta.data$seurat_clusters_new, sep = "_")

# Condition & Module variable
seurat.combined@meta.data$condition_module <- paste(seurat.combined@meta.data$condition, 
                                                    seurat.combined@meta.data$Module, sep = "_")


```

### Vis overview of Modules
```{r Visualise_modules}

# Create output directory
if(!dir.exists("output/figures/Modules")){
  dir.create("output/figures/Modules", 
             recursive = T)
}

#########################################
# Vis distribution of modules in UMAPs
#########################################

Idents(seurat.combined) <- seurat.combined@meta.data$Module


# Modules
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         label.size = 6, 
         cols = module.cols) + 
  ggtitle("Modules")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules.pdf")
dev.off()

# Modules No legend
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         pt.size = 1,
         label.size = 6,
         cols = module.cols) + 
  NoLegend() +
  ggtitle("Modules")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_labelled.pdf")
dev.off()

##########
# Sample
##########

# Split by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "group",
         label.size = 6,
         cols = module.cols) + 
  ggtitle("UMAP Modules split by sample")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_splitby_sample.pdf")
dev.off()


# Grouped by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         group.by = "group",
         label.size = 6) + 
  ggtitle("UMAP Modules group by sample")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_groupby_sample.pdf")
dev.off()

##############
# Condition
##############

# Split by Condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "condition",
         label.size = 6,
         cols = module.cols) + 
  ggtitle("UMAP Modules split by Condition")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_splitby_condition.pdf")
dev.off()

# group by Condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         group.by = "condition",
         cols = Condition.cols,
         label.size = 6) + 
  ggtitle("UMAP Modules group by Condition")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_groupby_condition.pdf")
dev.off()

```


## Export large data {.tabset}

### Export seurat object
```{r export_RDS}
if(!quick.load){
  saveRDS(seurat.combined, file = "Exported_RDS_files/seurat_combined_no_imputation.rds")
}

```

### Save large data tables
```{r write_data, eval = FALSE}

if(long.compute){
  
  
  # Create output directory
  if(!dir.exists("output/tables/Large_dataframes")){
    dir.create("output/tables/Large_dataframes", 
               recursive = T)
  }
  
  
  save.data.frame.function <- function(df, title){
    
    x <- as.data.frame(as.matrix(df))
    
    write.table(x, 
                paste0("output/tables/Large_dataframes/", title, ".txt"),
                sep = "\t",
                quote = FALSE)
  }
  
  # Raw data
  save.data.frame.function(seurat.combined@assays$RNA@counts, "Raw_dataframe")
  
  # Normed data
  save.data.frame.function(seurat.combined@assays$RNA@data, "filtered_dataframe")
  
  # Scaled data
  save.data.frame.function(seurat.combined@assays$RNA@scale.data, "scaled_dataframe")
  
  # PCA embeddings
  save.data.frame.function(seurat.combined@reductions$pca@cell.embeddings, "RNA_PCA")
  
  # UMAP embeddings
  save.data.frame.function(seurat.combined@reductions$umap@cell.embeddings, "RNA_UMAP")
  
  # Metadata
  save.data.frame.function(seurat.combined@meta.data, "Meta_data_dataframe")
  
  # Integrated normed values
  save.data.frame.function(seurat.combined@assays$integrated@data, "filtered_integrated_dataframe")
  
  # Integrated scaled data
  save.data.frame.function(seurat.combined@assays$integrated@scale.data, "scaled_integrated_dataframe")
  
}

```


## Imputation {.tabset}

### Imputation calculation
```{r seurat_imputation}


######################
# Impute values 
######################
if(long.compute){
  seurat.combined <- RunALRA(seurat.combined, 
                             genes.use = rownames(seurat.combined))
}

# 8.37% of the values became negative in the scaling process and were set to zero
# The matrix went from 29.63% nonzero to 38.95% nonzero


####################
# Calculate k value
####################
if(long.compute){
  
  Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
  seurat.combined.small <- subset(seurat.combined, downsample = 100)
  
  ALRA.out <- RunALRA(seurat.combined.small,
                      k.only = TRUE)
  
  ggouts <- ALRAChooseKPlot(ALRA.out)
  
  ggouts
  dev.copy(pdf, "output/QC/Imputation_K_plot.pdf")
  dev.off()
}


# set default assay back to RNA
DefaultAssay(seurat.combined) <- "RNA"


```


## Export large data after imputation {.tabset}

### Export seurat object with imputation
```{r export_RDS}
if(!quick.load){
  saveRDS(seurat.combined, file = "Exported_RDS_files/seurat_combined.rds")
}

if(long.compute){
  
  
  # Create output directory
  if(!dir.exists("output/tables/Large_dataframes")){
    dir.create("output/tables/Large_dataframes", 
               recursive = T)
  }
  
  
  save.data.frame.function <- function(df, title){
    
    x <- as.data.frame(as.matrix(df))
    
    write.table(x, 
                paste0("output/tables/Large_dataframes/", title, ".txt"),
                sep = "\t",
                quote = FALSE)
  }
  
  # Imputed values
  save.data.frame.function(seurat.combined@assays$alra@counts, "Imputed_counts_dataframe")
  
}


```



## Visualise distribution of cells across clusters/condition/modules {.tabset}

### Plot distribution of cells per each cluster 
```{r Distribution_cells_per_cluster}

# Create output directory
if(!dir.exists("output/figures/Clust_and_Module_distribution")){
  dir.create("output/figures/Clust_and_Module_distribution", 
             recursive = T)
}

################################
# Plot cluster wise distribution
################################
default.mar <- par()$mar

par(mar = c(10.1, 5.1, 4.1, 2.1))


# Number of cells 
x <- table(seurat.combined@meta.data$seurat_clusters)

barplot(t(x), 
        main = "Number of cells per clust",
        ylab = "Number of cells",
        cex.names = 1,
        las = 2,
        ylim = c(0, 2500),
        legend = TRUE, 
        beside = TRUE)


dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Number_cells_per_clust.pdf")
dev.off()

# Frequency 
x <- prop.table(table(seurat.combined@meta.data$seurat_clusters)) * 100

barplot(t(x), 
        main = "Freq of cells per clust",
        ylab = "% of total",
        cex.names = 1, 
        las = 2,
        ylim = c(0, 20),
        legend = TRUE, 
        beside = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Freq_cells_per_clust.pdf")
dev.off()



###################################################
# Plot Freq per cluster per condition 
###################################################

# Be aware, US and Stim have diff total number of cells and therefore should be represented as a % normalised to total condition cell #

condition.cell.n <- table(seurat.combined@meta.data$condition)
US.cell.n <- condition.cell.n[1]
Stim.cell.n <- condition.cell.n[2]

Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
Cluster.cell.n <- table(Idents(seurat.combined), seurat.combined@meta.data$condition)

Cluster.cell.n[,1] <- Cluster.cell.n[,1]/US.cell.n*100
Cluster.cell.n[,2] <- Cluster.cell.n[,2]/Stim.cell.n*100

colSums(Cluster.cell.n) # sanity check, both should = 100%

barplot(t(Cluster.cell.n),
        main = "% of cells per cluster per condition",
        ylab = "% of cells",
        col = Condition.cols,
        cex.names = 1, 
        las = 2,
        ylim = c(0, 30), 
        beside = TRUE, 
        legend = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_cluster_per_condition.pdf")
dev.off()


# reset margin to default 
par(mar = c(default.mar))


#########################################
# Plot Module wise distribution
#########################################

# Plot total cell # per module 

Module.cell.n <- table(seurat.combined@meta.data$Module)

barplot(Module.cell.n, 
        main = "# of cells per Module", 
        xlab = "Module", 
        ylab = "# of cells",
        cex.names = 0.8, 
        ylim = c(0, 5000))

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Number_cells_per_Module.pdf")
dev.off()


# Plot freq of total per module
Module.freq <- prop.table(table(seurat.combined@meta.data$Module))*100

barplot(Module.freq,
        main = "% of cells per Module",
        xlab = "Module",
        ylab = "% of cells",
        cex.names = 0.8, 
        ylim = c(0, 40))

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_Module.pdf")
dev.off()


###################################################
# Plot Freq per module per condition 
###################################################

# Be aware, US and Stim have diff total number of cells and therefore should be represented as a % normalised to total condition cell #

condition.cell.n <- table(seurat.combined@meta.data$condition)
US.cell.n <- condition.cell.n[1]
Stim.cell.n <- condition.cell.n[2]

Idents(seurat.combined) <- seurat.combined@meta.data$Module
Module.cell.n <- table(Idents(seurat.combined), seurat.combined@meta.data$condition)

Module.cell.n[,1] <- Module.cell.n[,1]/US.cell.n*100
Module.cell.n[,2] <- Module.cell.n[,2]/Stim.cell.n*100

colSums(Module.cell.n) # sanity check, both should = 100%


barplot(t(Module.cell.n),
        main = "% of cells per Module per condition",
        xlab = "Module",
        ylab = "% of cells",
        col = Condition.cols,
        cex.names = 0.8, 
        ylim = c(0, 50), 
        beside = TRUE, 
        legend = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_Module_per_condition.pdf")
dev.off()



```


## DEG analysis {.tabset}

### DEG between modules
```{r DEG_between_modules}

# Create output directory
if(!dir.exists("output/tables/DEG_Modules")){
  dir.create("output/tables/DEG_Modules", 
             recursive = T)
}

# Set Idents
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

################
# Pos DEGs
################

# Find markers
Module.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA",
                                 only.pos = TRUE,
                                 min.diff.pct = 0.1,
                                 return.thresh = 0.05)

# Write data to file
write.csv(Module.markers, "output/tables/DEG_Modules/Module_markers_unfiltered_pos.csv")

# Filter by sig Padj val
sum(Module.markers$p_val_adj < 0.05) # 772 genes 

write.csv(Module.markers[Module.markers$p_val_adj < 0.05, ], "output/tables/DEG_Modules/Module_markers_sig_only_pos.csv")


################
# Pos and Neg
################

# Find markers
Module.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA",
                                 only.pos = FALSE,
                                 min.diff.pct = 0.1,
                                 return.thresh = 0.05)

# Write data to file
write.csv(Module.markers, "output/tables/DEG_Modules/Module_markers_unfiltered.csv")

# Filter by sig Padj val
sum(Module.markers$p_val_adj < 0.05) 

write.csv(Module.markers[Module.markers$p_val_adj < 0.05, ], "output/tables/DEG_Modules/Module_markers_sig_only.csv")


################################################
# Extract the top markers for each module
################################################

# Get top markers for each module - use Positive markers only
sig.markers <- Module.markers[Module.markers$p_val_adj < 0.05, ]

Module.vect <- unique(Module.markers$cluster)

for(i in 1:length(Module.vect)){
  
  print(paste0("Getting markers for Module ", Module.vect[i]))
  
  input.df <- sig.markers[sig.markers$cluster == Module.vect[i], ]
  
  assign(paste0("Module_", Module.vect[i]), top_n(input.df, 40,  avg_logFC))
  
  x <- eval(parse(text = paste0("Module_", Module.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Modules/Top_40_markers_for_Module_", Module.vect[i], ".csv"))
  
}


```

### DEGs of modules between conditions
```{r DEGs_of_modules_between_conditions}


# Create output directories
if(!dir.exists("output/tables/DEG_Modules_btn_conditions")){
  dir.create("output/tables/DEG_Modules_btn_conditions", 
             recursive = T)
}


if(!dir.exists("output/figures/DEG_Modules_btn_conditions")){
  dir.create("output/figures/DEG_Modules_btn_conditions", 
             recursive = T)
}


# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

# Get vector of clusters
Module.vect <- seurat.combined@meta.data$Module
Module.vect <- levels(Module.vect)

for(i in 1:length(Module.vect)){
  
  print(paste0("Analysis for Module ", Module.vect[i]))
  
  # Set idents to the condition_cluster
  Idents(seurat.combined) <- seurat.combined@meta.data$condition_module
  
  # Calculating DEGs for each cluster across condition
  DEG.var <- FindMarkers(seurat.combined,
                         ident.1 = paste0("Stim_", Module.vect[i]), 
                         ident.2 = paste0("US_", Module.vect[i]),
                         test.use = "wilcox",
                         logfc.threshold = 0.25,
                         min.pct = 0.1,
                         only.pos = FALSE,
                         verbose = FALSE)
  
  # create column for gene ID
  DEG.var$gene <- rownames(DEG.var)
  
  # Write data to file
  write.csv(DEG.var, paste0("output/tables/DEG_Modules_btn_conditions/Stim_vs_US_DEG_module_", Module.vect[i], ".csv"))
  
  #########################################
  # Get top DEGs for clusters Stim vs. US
  #########################################
  
  print(paste0("Getting top markers for module ", Module.vect[i], " Stim vs. US"))
  
  sig.markers <- DEG.var[DEG.var$p_val_adj < 0.05, ]
  
  assign(paste0("Condition_Module_DEGs_", Module.vect[i]), top_n(sig.markers, 40,  avg_logFC))
  
  x <- eval(parse(text = paste0("Condition_Module_DEGs_", Module.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Modules_btn_conditions/Top_40_markers_for_Stim_vs_US_Module_", Module.vect[i], ".csv"))
  
  ############################################
  # plotting DEG per module across condition
  ############################################
  
  # Set idents to Module ID
  Idents(seurat.combined) <- seurat.combined@meta.data$Module
  
  # Subset for Module ID
  subset.seurat <- subset(seurat.combined, idents = paste0(Module.vect[i]))
  
  # Set idents to condition var
  Idents(subset.seurat) <- subset.seurat@meta.data$condition
  
  # Get top 10 genes
  # up-regulated genes
  genes.to.label.1 <- top_n(DEG.var, 10, avg_logFC)$gene
  
  # Down-regulated genes
  genes.to.label.2 <- top_n(DEG.var, -10, avg_logFC)$gene
  
  # Create vector of genes
  genes.to.label <- unique(c(genes.to.label.1, genes.to.label.2))
  
  # Average expression
  avg.subset.seurat <- log1p(AverageExpression(subset.seurat, verbose = FALSE)$RNA)
  
  # Create column with gene id 
  avg.subset.seurat$gene <- rownames(avg.subset.seurat)
  
  # Generate plot
  p1 <- ggplot(avg.subset.seurat, 
               aes(US, Stim)) + 
    geom_point() + 
    ggtitle(paste0("Module ", Module.vect[i]))
  
  p1 <-  LabelPoints(plot = p1,
                     points = genes.to.label,
                     repel = TRUE)
  
  print(plot(p1))
  dev.copy(pdf, paste0("output/figures/DEG_Modules_btn_conditions/ScatterPlot_Stim_vs_US_Module_", Module.vect[i], ".pdf"))
  dev.off()
  
  # Remove large variable
  rm(subset.seurat)
  rm(DEG.var)
  
}



```

### DEGs between clusters 
```{r DEGs_between_clusters}

# Create output directory
if(!dir.exists("output/tables/DEG_Clusters")){
  dir.create("output/tables/DEG_Clusters", 
             recursive = T)
}

# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

################
# Positive only
################

# Find markers
Cluster.markers.pos <- FindAllMarkers(seurat.combined,
                                      assay = "RNA",
                                      only.pos = TRUE,
                                      min.diff.pct = 0.1,
                                      return.thresh = 0.05)

# Write data to file
write.csv(Cluster.markers.pos, "output/tables/DEG_Clusters/Cluster_markers_unfiltered_pos.csv")

# Filter by sig Padj val
sum(Cluster.markers.pos$p_val_adj < 0.05) # 2,919 genes 

write.csv(Cluster.markers.pos[Cluster.markers.pos$p_val_adj < 0.05, ], "output/tables/DEG_Clusters/Cluster_markers_sig_only_pos.csv")


################
# Pos and Neg
################

# Find markers
Cluster.markers <- FindAllMarkers(seurat.combined,
                                  assay = "RNA",
                                  only.pos = FALSE,
                                  min.diff.pct = 0.1,
                                  return.thresh = 0.05)

# Write data to file
write.csv(Cluster.markers, "output/tables/DEG_Clusters/Cluster_markers_unfiltered.csv")

# Filter by sig Padj val
sum(Cluster.markers$p_val_adj < 0.05) # 4,890 genes 

write.csv(Cluster.markers[Cluster.markers$p_val_adj < 0.05, ], "output/tables/DEG_Clusters/Cluster_markers_sig_only.csv")


########################
# Get top markers
########################

# Get top markers for each cluster - use Positive markers only
sig.markers <- Cluster.markers.pos[Cluster.markers.pos$p_val_adj < 0.05, ]

Cluster.vect <- unique(sig.markers$cluster)

for(i in 1:length(Cluster.vect)){
  
  
  print(paste0("Getting markers for cluster ", Cluster.vect[i]))
  
  input.df <- sig.markers[sig.markers$cluster == Cluster.vect[i], ]
  
  assign(paste0("Cluster_", Cluster.vect[i]), top_n(input.df, 40,  avg_logFC))
  
  
  x <- eval(parse(text = paste0("Cluster_", Cluster.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Clusters/Top_40_markers_for_cluster_", Cluster.vect[i], ".csv"))
  
}


```

### DEGs of clusters between conditions
```{r DEGs_of_clusts_between_conditions}

# Create output directories
if(!dir.exists("output/tables/DEG_Clusters_btn_conditions")){
  dir.create("output/tables/DEG_Clusters_btn_conditions", 
             recursive = T)
}


if(!dir.exists("output/figures/DEG_Clusters_btn_conditions")){
  dir.create("output/figures/DEG_Clusters_btn_conditions", 
             recursive = T)
}


# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

# Get vector of clusters
clust.var <- seurat.combined@meta.data$seurat_clusters
clust.var <- levels(clust.var)

for(i in 1:length(clust.var)){
  
  print(paste0("Analysis for cluster ", clust.var[i]))
  
  # Set idents to the condition_cluster
  Idents(seurat.combined) <- seurat.combined@meta.data$condition_clust
  
  # Calculating DEGs for each cluster across condition
  DEG.var <- FindMarkers(seurat.combined,
                         ident.1 = paste0("Stim_", clust.var[i]), 
                         ident.2 = paste0("US_", clust.var[i]),
                         test.use = "wilcox",
                         logfc.threshold = 0.25,
                         min.pct = 0.1,
                         only.pos = FALSE,
                         verbose = FALSE)
  
  # create column for gene ID
  DEG.var$gene <- rownames(DEG.var)
  
  # Write data to file
  write.csv(DEG.var, paste0("output/tables/DEG_Clusters_btn_conditions/Stim_vs_US_DEG_clust_", clust.var[i], ".csv"))
  
  #########################################
  # Get top DEGs for clusters Stim vs. US
  #########################################
  
  print(paste0("Getting top markers for cluster ", Cluster.vect[i], " Stim vs. US"))
  
  sig.markers <- DEG.var[DEG.var$p_val_adj < 0.05, ]
  
  assign(paste0("Condition_Cluster_DEGs_", Cluster.vect[i]), top_n(sig.markers, 40,  avg_logFC))
  
  x <- eval(parse(text = paste0("Condition_Cluster_DEGs_", Cluster.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Clusters_btn_conditions/Top_40_markers_for_Stim_vs_US_cluster_", Cluster.vect[i], ".csv"))
  
  ############################################
  # plotting DEG per cluster across condition
  ############################################
  
  # Set idents to cluster ID
  Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
  
  # Subset for cluster ID
  subset.seurat <- subset(seurat.combined, idents = paste0(clust.var[i]))
  
  # Set idents to condition var
  Idents(subset.seurat) <- subset.seurat@meta.data$condition
  
  # Get top 10 genes
  # up-regulated genes
  genes.to.label.1 <- top_n(DEG.var, 10, avg_logFC)$gene
  
  # Down-regulated genes
  genes.to.label.2 <- top_n(DEG.var, -10, avg_logFC)$gene
  
  # Create vector of genes
  genes.to.label <- unique(c(genes.to.label.1, genes.to.label.2))
  
  # Average expression
  avg.subset.seurat <- log1p(AverageExpression(subset.seurat, verbose = FALSE)$RNA)
  
  # Create column with gene id 
  avg.subset.seurat$gene <- rownames(avg.subset.seurat)
  
  # Generate plot
  p1 <- ggplot(avg.subset.seurat, 
               aes(US, Stim)) + 
    geom_point() + 
    ggtitle(paste0("Cluster ", clust.var[i]))
  
  p1 <-  LabelPoints(plot = p1,
                     points = genes.to.label,
                     repel = TRUE)
  
  print(plot(p1))
  dev.copy(pdf, paste0("output/figures/DEG_Clusters_btn_conditions/ScatterPlot_Stim_vs_US_cluster_", clust.var[i], ".pdf"))
  dev.off()
  
  # Remove large variable
  rm(subset.seurat)
  rm(DEG.var)
  
}


```


## Visualise DEGs {.tabset}

### Heatmaps and dotplots of Module DEGs
```{r Heatmaps_and_dotplots_of_Module_DEGs}

# Output directory
# Heatmaps
if(!dir.exists("output/figures/Module_DEG_Heatmaps")){
  dir.create("output/figures/Module_DEG_Heatmaps", 
             recursive = T)
}

# Dotplots
if(!dir.exists("output/figures/Module_DEG_dotplots")){
  dir.create("output/figures/Module_DEG_dotplots", 
             recursive = T)
}



# Set assay to integrated
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)


# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)


################################################
# Visualise top markers for each Module
################################################
# as single cell heatmap, averaged heatmap, and dotplot


# get vector of Modules to iterate over
Module.vect <- unique(seurat.combined@meta.data$Module)


for(i in 1:length(Module.vect)){
  
  print(paste0("Evaluating Module = ", Module.vect[i]))
  
  x <- eval(parse(text = paste0("Module_", Module.vect[i])))
  
  # Single cell heatmap
  print(DoHeatmap(seurat.combined.small, 
                  features = x$gene, 
                  size = 4, 
                  angle = 0, 
                  hjust = 0.5,
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Module_DEG_Heatmaps/Heatmap_topDEGs_Module_", Module.vect[i], ".pdf"))
  dev.off()
  
  
  # Average expression heatmap
  print(DoHeatmap(average.seurat, 
                  features = x$gene, 
                  size = 4, 
                  angle = 0, 
                  draw.lines = FALSE,
                  hjust = 0.1,
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Module_DEG_Heatmaps/Heatmap_topDEGs_Module_", Module.vect[i], "_average.pdf"))
  dev.off()
  
  
  print(DotPlot(seurat.combined, 
                assay = "RNA",
                features = x$gene, 
                dot.scale = 8) + 
          RotatedAxis() +  
          theme(text = element_text(size = 4)) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Module_DEG_dotplots/DotPlot_TopDEGs_Module_", Module.vect[i], ".pdf"))
  dev.off()
  
  
}



```

### Curated Module heatmaps
```{r Curated_Module_heatmaps}

# Curated Module Heatmaps
if(!dir.exists("output/figures/Modules/Curated_Heatmaps")){
  dir.create("output/figures/Modules/Curated_Heatmaps", 
             recursive = T)
}

# Set assay to RNA
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)

#################################################
# Plot single cell heatmaps for curated goi
#################################################

# Exhaustion
Exhaustion.sig <- c("CD226", "LAG3", "TIGIT", 
                    "HAVCR2", "TCF7", "TOX",
                    "PDCD1", "IFNG", "GZMA",
                    "ENTPD1", "ICOS", "NKG7", 
                    "GZMB", "PRF1", "CTLA4",
                    "GNLY", "LAYN")

DoHeatmap(seurat.combined.small, 
          features = Exhaustion.sig, 
          size = 4, 
          angle = 0, 
          hjust = 0.5,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_Exhaustion_sig.pdf")
dev.off()


# Naive
Naive.sig <- c("CCR7", "SELL", "IL7R",
               "LTB", "LEF1", "TCF7")

# Stem-like 
Stem.sig <- c("FOSB", "PPP1R15A", "KLF6",
              "JUNB", "NFKBIA", "TCF7",
              "RELB", "CCR7", "CRTAM")

Naive.stem.sig <-unique(c(Naive.sig, Stem.sig))


DoHeatmap(seurat.combined.small, 
          features = Naive.stem.sig, 
          size = 4, 
          angle = 0, 
          hjust = 0.5,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_NaiveStem_sig.pdf")
dev.off()



########################
# Curated heatmaps 
########################

# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)


# Exhaustion
DoHeatmap(average.seurat, 
          features = Exhaustion.sig, 
          size = 4, 
          angle = 0, 
          draw.lines = FALSE,
          hjust = 0.1,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_Exhaustion_sig_Averaged.pdf")
dev.off()

# NaiveStem
DoHeatmap(average.seurat, 
          features = Naive.stem.sig, 
          size = 4, 
          angle = 0, 
          draw.lines = FALSE,
          hjust = 0.1,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_NaiveStem_sig_Averaged.pdf")
dev.off()


```

### Heatmaps and dotplots of Cluster DEGs
```{r Heatmaps_and_dotplots_of_Cluster_DEGs}

# Output directory
# Heatmaps
if(!dir.exists("output/figures/Cluster_DEG_Heatmaps")){
  dir.create("output/figures/Cluster_DEG_Heatmaps", 
             recursive = T)
}

# Dotplots
if(!dir.exists("output/figures/Cluster_DEG_dotplots")){
  dir.create("output/figures/Cluster_DEG_dotplots", 
             recursive = T)
}



# Set assay to RNA
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)


# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)


################################################
# Visualise top markers for each Cluster
################################################
# as single cell heatmap, averaged heatmap, and dotplot


# get vector of clusters to iterate over
Cluster.vect <- unique(seurat.combined.small@meta.data$seurat_clusters)


for(i in 1:length(Cluster.vect)){
  
  print(paste0("Evaluating cluster = ", Cluster.vect[i]))
  
  x <- eval(parse(text = paste0("Cluster_", Cluster.vect[i])))
  
  # Single cell heatmap
  print(DoHeatmap(seurat.combined.small, 
                  features = x$gene, 
                  size = 4, 
                  angle = 90, 
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Cluster_DEG_Heatmaps/Heatmap_topDEGs_clust_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Average expression heatmap
  print(DoHeatmap(average.seurat, 
                  features = x$gene, 
                  size = 4, 
                  angle = 90, 
                  draw.lines = FALSE,
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Cluster_DEG_Heatmaps/Heatmap_topDEGs_clust_", Cluster.vect[i], "_average.pdf"))
  dev.off()
  
  
  print(DotPlot(seurat.combined, 
                assay = "RNA",
                features = x$gene, 
                dot.scale = 8) + 
          RotatedAxis() +  
          theme(text = element_text(size = 4)) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Cluster_DEG_dotplots/DotPlot_TopDEGs_clust_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
}


```


### Large heatmaps of top DEGs by foldchange // Average and single cell
```{r Large_Heatmaps_of_top_DEGs}

# Output directory
if(!dir.exists("output/figures/Large_Summary_heatmaps")){
  dir.create("output/figures/Large_Summary_heatmaps", 
             recursive = T)
}


# Set assay to integrated
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)

# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)



###########################
# Get top overall DEGs
###########################

# Get top Module markers
sig.genes <- Module.markers[Module.markers$p_val_adj < 0.05, ]

clusts <- unique(sig.genes$cluster)
output.vect <- NA
top.n <- 100

for(i in 1:length(clusts)){
  
  temp.gene <- sig.genes[sig.genes$cluster == paste0(clusts[i]), ]
  temp.top <- top_n(temp.gene, top.n, avg_logFC)$gene
  
  output.vect <- c(output.vect, temp.top)
  output.vect <- unique(output.vect)
  
}


DoHeatmap(average.seurat, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_byModule_Averaged.pdf")
dev.off()

DoHeatmap(seurat.combined.small, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = TRUE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_byModule.pdf")
dev.off()




# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)

# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)



# Get top cluster markers
sig.genes <- Cluster.markers[Cluster.markers$p_val_adj < 0.05, ]

clusts <- unique(sig.genes$cluster)
output.vect <- NA
top.n <- 40

for(i in 1:length(clusts)){
  
  temp.gene <- sig.genes[sig.genes$cluster == paste0(clusts[i]), ]
  temp.top <- top_n(temp.gene, top.n, avg_logFC)$gene
  
  output.vect <- c(output.vect, temp.top)
  output.vect <- unique(output.vect)
}





DoHeatmap(average.seurat, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_bycluster_Averaged.pdf")
dev.off()

DoHeatmap(seurat.combined.small, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = TRUE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_bycluster.pdf")
dev.off()




```

### DEGs and selected genes Vlnplots || Modules & Clusters
```{r Vln_feature_plots}

# Create output directories
if(!dir.exists("output/figures/Top_DEG_plots/Modules")){
  dir.create("output/figures/Top_DEG_plots/Modules", 
             recursive = T)
}

if(!dir.exists("output/figures/Top_DEG_plots/Clusters")){
  dir.create("output/figures/Top_DEG_plots/Clusters", 
             recursive = T)
}



# Set assay
DefaultAssay(seurat.combined) <- "RNA"



# Custom list of genes to plot


goi <- c("IFNG", "TNF", "ENTPD1",
         "PDCD1", "TIGIT", "LAYN", 
         "EOMES", "GZMA", "GZMB", 
         "GZMK", "CXCR3", "TOX",
         "CASZ1", "CD226", "CXCL13",
         "CD160", "TBX21",
         "TRBC1", "CD8A", "CD8B", 
         "CD4",
         "FOXP3", "IL2RA", "CTLA4", 
         "CD14", "LYZ", 
         "PRF1", "NKG7", "GNLY", 
         "FCGR3A",
         "KLRB1", "KLRC1", 
         "MKI67", 
         "KIT", 
         "HAVCR2", "LAG3", "TCF7",
         "ICOS", 
         "CCR7", "IL7R", "CD7", "CD69",  
         "ITGAX", "ITGAM", "IL3RA",
         "CD86", "CD83", "IL4I1")



################################################################
# Plot Feature plot and VlnPlot for top DEGs for modules
################################################################

# Generate vector of genes to plot
Top.module.genes <- unique(c(Module_Naive_Stem$gene,
                             Module_Activated$gene,
                             Module_Cycling$gene,
                             Module_Exhaustion$gene,
                             Module_Innate$gene))

# Add custom genes 
Top.module.genes <- unique(c(Top.module.genes, goi))

# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module


for(i in 1:length(Top.module.genes)){
  
  print(paste0("Plotting ", Top.module.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.module.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots/Modules/VlnPlot_", Top.module.genes[i], ".pdf"))
  dev.off()
  
  # Plot feature plot on UMAP projection
  print(FeaturePlot(seurat.combined,
                    features = Top.module.genes[i],
                    reduction = "umap") + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots/FeaturePlot_", Top.module.genes[i], ".pdf"))
  dev.off()
  
}


################################################################
# Plot Feature plot and VlnPlot for top DEGs for Clusters
################################################################


# Generate vector of genes to plot
Top.cluster.genes <- unique(c(Cluster_Cytotoxic$gene,
                              Cluster_Exhausted_1$gene,
                              Cluster_Exhausted_2$gene,
                              Cluster_gd_T_g9d2$gene,
                              Cluster_gd_T_non_g9d2$gene,
                              Cluster_MAIT$gene,
                              Cluster_Naïve_like_1_CM$gene,
                              Cluster_Naïve_like_2_SC$gene,
                              Cluster_Naïve_like_3$gene,
                              Cluster_Proliferative$gene,
                              Cluster_Stimulated_1$gene,
                              Cluster_Stimulated_exhausted$gene,
                              Cluster_TRM$gene,
                              Cluster_Type_I_IFN$gene))



# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Add custom genes 
Top.cluster.genes <- unique(c(Top.cluster.genes, goi))

for(i in 1:length(Top.cluster.genes)){
  
  print(paste0("Plotting ", Top.cluster.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.cluster.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots/Clusters/VlnPlot_", Top.cluster.genes[i], ".pdf"))
  dev.off()
  
  # If gene is already in top.module.gene list this will have already been plotted
  if(Top.cluster.genes[i] %in% Top.module.genes){
    next()
  }else{
    # Plot feature plot on UMAP projection
    print(FeaturePlot(seurat.combined,
                      features = Top.cluster.genes[i],
                      reduction = "umap") + 
            NoLegend())
    
    dev.copy(pdf, paste0("output/figures/Top_DEG_plots/FeaturePlot_", Top.cluster.genes[i], ".pdf"))
    dev.off()
  }
  
}




```

### DEGs and selected genes Vlnplots || Modules & Clusters || Imputed
```{r Vln_feature_plots}

# Create output directories
if(!dir.exists("output/figures/Top_DEG_plots_Imputed/Modules")){
  dir.create("output/figures/Top_DEG_plots_Imputed/Modules", 
             recursive = T)
}

if(!dir.exists("output/figures/Top_DEG_plots_Imputed/Clusters")){
  dir.create("output/figures/Top_DEG_plots_Imputed/Clusters", 
             recursive = T)
}



# Set assay
DefaultAssay(seurat.combined) <- "alra"



# Custom list of genes to plot


goi <- c("IFNG", "TNF", "ENTPD1",
         "PDCD1", "TIGIT", "LAYN", 
         "EOMES", "GZMA", "GZMB", 
         "GZMK", "CXCR3", "TOX",
         "CASZ1", "CD226", "CXCL13",
         "CD160", "TBX21",
         "TRBC1", "CD8A", "CD8B", 
         "CD4",
         "FOXP3", "IL2RA", "CTLA4", 
         "CD14", "LYZ", 
         "PRF1", "NKG7", "GNLY", 
         "FCGR3A",
         "KLRB1", "KLRC1", 
         "MKI67", 
         "KIT", 
         "HAVCR2", "LAG3", "TCF7",
         "ICOS", 
         "CCR7", "IL7R", "CD7", "CD69",  
         "ITGAX", "ITGAM", "IL3RA",
         "CD86", "CD83", "IL4I1")



################################################################
# Plot Feature plot and VlnPlot for top DEGs for modules
################################################################

# Generate vector of genes to plot
Top.module.genes <- unique(c(Module_Naive_Stem$gene,
                             Module_Activated$gene,
                             Module_Exhaustion$gene,
                             Module_Innate$gene,
                             Module_Cycling$gene))

# Add custom genes 
Top.module.genes <- unique(c(Top.module.genes, goi))

# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module


for(i in 1:length(Top.module.genes)){
  
  print(paste0("Plotting ", Top.module.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.module.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/Modules/VlnPlot_", Top.module.genes[i], "_imputed.pdf"))
  dev.off()
  
  # Plot feature plot on UMAP projection
  print(FeaturePlot(seurat.combined,
                    features = Top.module.genes[i],
                    reduction = "umap") + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/FeaturePlot_", Top.module.genes[i], "_imputed.pdf"))
  dev.off()
  
}


################################################################
# Plot Feature plot and VlnPlot for top DEGs for Clusters
################################################################


# Generate vector of genes to plot
Top.cluster.genes <- unique(c(Cluster_Naïve_like_1_CM$gene,
                              Cluster_Naïve_like_2_SC$gene,
                              Cluster_Naïve_like_3$gene,
                              Cluster_Cytotoxic$gene,
                              Cluster_Type_I_IFN$gene,
                              Cluster_Stimulated_1$gene,
                              Cluster_Stimulated_exhausted$gene,
                              Cluster_Exhausted_1$gene,
                              Cluster_Exhausted_2$gene,
                              Cluster_TRM$gene,
                              Cluster_gd_T_g9d2$gene,
                              Cluster_gd_T_non_g9d2$gene,
                              Cluster_MAIT$gene,
                              Cluster_Proliferative$gene))




# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Add custom genes 
Top.cluster.genes <- unique(c(Top.cluster.genes, goi))

for(i in 1:length(Top.cluster.genes)){
  
  print(paste0("Plotting ", Top.cluster.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.cluster.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/Clusters/VlnPlot_", Top.cluster.genes[i], "_imputed.pdf"))
  dev.off()
  
  # If gene is already in top.module.gene list this will have already been plotted
  if(Top.cluster.genes[i] %in% Top.module.genes){
    next()
  }else{
    # Plot feature plot on UMAP projection
    print(FeaturePlot(seurat.combined,
                      features = Top.cluster.genes[i],
                      reduction = "umap") + 
            NoLegend())
    
    dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/FeaturePlot_", Top.cluster.genes[i], "_imputed.pdf"))
    dev.off()
  }
  
}




```


### Volcano DEGs
```{r Volcano_plots}

# Generate output directories
if(!dir.exists("output/figures/VolcanoPlots/Clusters")){
  dir.create("output/figures/VolcanoPlots/Clusters", 
             recursive = TRUE)
}

if(!dir.exists("output/figures/VolcanoPlots/Modules")){
  dir.create("output/figures/VolcanoPlots/Modules", 
             recursive = TRUE)
}

##############################
# Install and load package
##############################

# "EnhancedVolcano" package from Github repo
# devtools::install_github('kevinblighe/EnhancedVolcano')

library(EnhancedVolcano)


#############
# Functions
#############

clean.data <- function(input.data, group.id){
  
  output.data <- input.data %>%
    dplyr::filter(cluster == paste0(group.id))
  
  rownames(output.data) <- output.data$gene
  
  output.data <- output.data %>%
    dplyr::select(avg_logFC, p_val_adj)
  
  colnames(output.data) <- c("logFC", "FDR")
  return(output.data)
  
}



colour.points <- function(volcano.data, 
                          increase.col = "Red",
                          decreased.col = "Blue",
                          FDR.cutoff = 0.05,
                          logFC.cutoff = 0.25){
  
  # set the base colour
  keyvals <- rep('grey50', nrow(volcano.data))
  
  # set the base name/label as 'NS'
  names(keyvals) <- rep('NS', nrow(volcano.data))
  
  # modify keyvals for vars meeting FDR and LogFC threshold
  
  # Increased
  keyvals[which(volcano.data$logFC > logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- increase.col
  names(keyvals)[which(volcano.data$logFC > logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- 'Increased'
  
  # Decreased
  keyvals[which(volcano.data$logFC < -logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- decreased.col
  names(keyvals)[which(volcano.data$logFC < -logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- 'Decreased'
  
  return(keyvals)
  
}

# edited enhancedvolcano() function to have the default variables for aesthetics I want

source("~/Documents/Work/Sciebo/Scripts/Enhanced_volcano_custom_defaults.R")



################
# Clusters
################

cluster.markers.df <- read.csv("output/tables/DEG_Clusters/Cluster_markers_unfiltered.csv")


cluster.var <- unique(cluster.markers.df$cluster)


for(i in 1:length(cluster.var)){
  
  # format data
  volcano.data <- clean.data(cluster.markers.df,
                             group.id = cluster.var[i])
  
  keyvals <- colour.points(volcano.data)
  
  
  # get list of top 10 up and 10 downregulated genes
  goi.up <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(10, logFC)
  
  goi.dn <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(-10, logFC)
  
  # combine vectors
  goi <- unique(c(rownames(goi.up), rownames(goi.dn)))
  
  
  
  print(custom.enhanced.volcano(volcano.data, 
                                selectLab = goi, 
                                colCustom = keyvals, 
                                title = paste0(cluster.var[i])))
  
  
  dev.copy(pdf, paste0("output/figures/VolcanoPlots/Clusters/Volcano_", cluster.var[i], ".pdf"))
  dev.off()
  
  
}



################
# Modules
################

Module.markers.df <- read.csv("output/tables/DEG_Modules/Module_markers_unfiltered.csv")


module.var <- unique(Module.markers.df$cluster)


for(i in 1:length(module.var)){
  
  # format data
  volcano.data <- clean.data(Module.markers.df,
                             group.id = module.var[i])
  
  keyvals <- colour.points(volcano.data)
  
  
  # get list of top 10 up and 10 downregulated genes
  goi.up <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(10, logFC)
  
  goi.dn <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(-10, logFC)
  
  # combine vectors
  goi <- unique(c(rownames(goi.up), rownames(goi.dn)))
  
  
  
  print(custom.enhanced.volcano(volcano.data, 
                                selectLab = goi, 
                                colCustom = keyvals, 
                                title = paste0(module.var[i])))
  
  
  dev.copy(pdf, paste0("output/figures/VolcanoPlots/Modules/Volcano_", module.var[i], ".pdf"))
  dev.off()
  
  
}















########################################################################
### Below code is kept for any future tweeking of volcano aesthetics 
########################################################################


# Custom point size for points of particular type 
# pointSize = c(ifelse(volcano.data$genes %in% goi, 10, 4))

# Add custom ticks
# +
#  ggplot2::coord_cartesian(xlim=c(-1.5, 3)) +
#  ggplot2::scale_x_continuous(
#    breaks=seq(-1.5, 3, 0.5))




#EnhancedVolcano(volcano.data,
#                lab = rownames(volcano.data),
#                x = 'logFC',
#                y = 'FDR',
#                selectLab = goi,
#xlim = c(-2.5, 2.5),
#ylim = c(0, 500),
#                title = "DNAM1 High vs. Neg",
#                subtitle = "",
#                ylab = bquote(~-Log[10]~adjusted~italic(P)),
##                pCutoff = 0.05,
#                FCcutoff = 0.25,
#                pointSize = 5, 
#col = c("black", "black", "black", "red2"),
#                colCustom = keyvals,
#                colAlpha = 0.2, 
#                drawConnectors = TRUE,
#                widthConnectors = 0.5,
#                colConnectors = 'grey30',
#                typeConnectors = "open",
#                labSize = 4,
#                gridlines.major = TRUE,
#                gridlines.minor = FALSE,
#                border = 'partial',
#                borderWidth = 0.5,
#                borderColour = 'black')   

```



## Cell-cell receptor-ligand analysis {.tabset}

### Celltalker analysis
```{r celltalker}

# Create output directories
if(!dir.exists("output/figures/Cell_cell_interaction/celltalker")){
  dir.create("output/figures/Cell_cell_interaction/celltalker", 
             recursive = T)
}



# load library
library("celltalker")

# Ref dataset supplied with celltalker
head(ramilowski_pairs)
tail(ramilowski_pairs)

dim(ramilowski_pairs) #There are 2,557 unique ligand/receptor interactions in this dataset


###########################################################################
#Identification of differentially expressed ligands and receptors
###########################################################################

# Identify ligands and receptors in our dataset
ligs <- as.character(unique(ramilowski_pairs$ligand))
recs <- as.character(unique(ramilowski_pairs$receptor))

ligs.present <- rownames(seurat.combined)[rownames(seurat.combined) %in% ligs]
recs.present <- rownames(seurat.combined)[rownames(seurat.combined) %in% recs]

genes.to.use <- union(ligs.present,recs.present)
length(genes.to.use) # 760


# Use FindAllMarkers for deferentially expressed ligands and receptors between groups

# Set idents to clusters
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

ligand.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA", 
                                 features = genes.to.use,
                                 only.pos = TRUE)

nrow(ligand.markers) # 269 


# Filter by adjusted P.value 
ligand.markers <- ligand.markers[ligand.markers$p_val_adj < 0.05, ]

nrow(ligand.markers) # 254

# get vector of unique ligands/receptors
ligs.recs.use <- unique(ligand.markers$gene)
length(ligs.recs.use) # 111




# Filter ramilowski pairs
interactions.forward1 <- ramilowski_pairs[as.character(ramilowski_pairs$ligand) %in% ligs.recs.use, ]

interactions.forward2 <- ramilowski_pairs[as.character(ramilowski_pairs$receptor) %in% ligs.recs.use, ]

interact.for <- rbind(interactions.forward1, interactions.forward2)

dim(interact.for) # 494 ligand receptor interactions




# Create data for celltalker
DefaultAssay(seurat.combined) <- "RNA"

expr.mat <- GetAssayData(seurat.combined, 
                         slot = "counts")

# define clusters and groups(condition)
defined.clusters <- seurat.combined@meta.data$seurat_clusters
defined.groups <- seurat.combined@meta.data$condition


# Need to get a replicates vector 
defined.replicates <- seurat.combined@meta.data$group
defined.replicates <- gsub("S1", "US_1", defined.replicates)
defined.replicates <- gsub("S2", "US_2", defined.replicates)
defined.replicates <- gsub("S3", "Stim_1", defined.replicates)
defined.replicates <- gsub("S4", "Stim_2", defined.replicates)

# Needs to be a named vector
names(defined.clusters) <- rownames(seurat.combined@meta.data)
names(defined.groups) <- rownames(seurat.combined@meta.data)
names(defined.replicates) <- rownames(seurat.combined@meta.data)

# should be a factor vector
defined.clusters <- factor(defined.clusters, levels = c("Naïve_like_1_CM",
                                                        "Naïve_like_2_SC",
                                                        "Naïve_like_3",
                                                        "Cytotoxic",
                                                        "Type_I_IFN",
                                                        "Stimulated_1",
                                                        "Stimulated_exhausted",
                                                        "Exhausted_1",
                                                        "Exhausted_2",
                                                        "TRM",
                                                        "gd_T_g9d2",
                                                        "gd_T_non_g9d2",
                                                        "MAIT",
                                                        "Proliferative"))

defined.groups <- factor(defined.groups, levels = c("US",
                                                    "Stim"))

defined.replicates <- factor(defined.replicates, levels = c("US_1",
                                                            "US_2",
                                                            "Stim_1",
                                                            "Stim_2"))



reshaped.matrices <- reshape_matrices(count.matrix = expr.mat,
                                      clusters = defined.clusters,
                                      groups = defined.groups,
                                      replicates = defined.replicates,
                                      ligands.and.receptors = interact.for)


#Check out the hierarchy of the tibble
reshaped.matrices
reshaped.matrices$group
reshaped.matrices$samples

unnest(reshaped.matrices,
       cols = "samples")

names(pull(unnest(reshaped.matrices, cols = "samples"))[[1]])

# small bug in create_lig_rec_tib function, required small modification 
source("~/Documents/Work/Sciebo/Scripts/Modified_Celltalker_function.R")

consistent.lig.recs <- create_lig_rec_tib.mod(exp.tib = reshaped.matrices,
                                              clusters = defined.clusters,
                                              groups = defined.groups,
                                              replicates = defined.replicates,
                                              cells.reqd = 10,
                                              freq.pos.reqd = 0.5,
                                              ligands.and.receptors = interact.for)





consistent.lig.recs


unnest(consistent.lig.recs[1,2], 
       cols = "lig.rec.exp")

pull(unnest(consistent.lig.recs[1,2],
            cols = "lig.rec.exp")[1,2])[[1]]

# Determine putative ligand/receptor pairs
put.int <- putative_interactions(ligand.receptor.tibble = consistent.lig.recs,
                                 clusters = defined.clusters,
                                 groups = defined.groups,
                                 freq.group.in.cluster = 0.05,
                                 ligands.and.receptors = interact.for)

# Identify and visualise unique ligand/receptor pairs in a group

# Identify unique ligand/receptor interactions present in each sample
unique.ints <- unique_interactions(put.int,
                                   group1 = "US",
                                   group2 = "Stim",
                                   interact.for)

temp.df <- as.data.frame(unique.ints)

# Get data to plot circos unique to US
US.to.plot <- pull(unique.ints[1,2])[[1]]
for.circos.US <- pull(put.int[1,2])[[1]][US.to.plot]

circos_plot(interactions = for.circos.US,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray") 

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_US_clusters.pdf")
dev.off()




#Get data to plot circos unique to Stim
Stim.to.plot <- pull(unique.ints[2,2])[[1]]
for.circos.Stim <- pull(put.int[2,2])[[1]][Stim.to.plot]

circos_plot(interactions = for.circos.Stim,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_Stim_clusters.pdf")
dev.off()





# Get data to plot circos common 
Common.to.plot <- pull(unique.ints[3,2])[[1]]
for.circos.common <- pull(put.int[1,2])[[1]][Common.to.plot]

circos_plot(interactions = for.circos.common,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_Common_clusters.pdf")
dev.off()









##################################################
### repeat analysis for modules 
##################################################

# Set idents
Idents(seurat.combined) <- seurat.combined@meta.data$Module

ligand.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA", 
                                 features = genes.to.use,
                                 only.pos = TRUE)

nrow(ligand.markers) # 104 


# Filter by adjusted P.value 
ligand.markers <- ligand.markers[ligand.markers$p_val_adj < 0.05, ]

nrow(ligand.markers) # 91

# get vector of unique ligands/receptors
ligs.recs.use <- unique(ligand.markers$gene)
length(ligs.recs.use) # 76



# Filter ramilowski pairs
interactions.forward1 <- ramilowski_pairs[as.character(ramilowski_pairs$ligand) %in% ligs.recs.use,]
interactions.forward2 <- ramilowski_pairs[as.character(ramilowski_pairs$receptor) %in% ligs.recs.use,]
interact.for <- rbind(interactions.forward1, interactions.forward2)

dim(interact.for) # 373



# Create data for celltalker
DefaultAssay(seurat.combined) <- "RNA"

expr.mat <- GetAssayData(seurat.combined, 
                         slot = "counts")

# Groups and replicates are defined in code for celltalk on clusters 
# Just "clusters" needs to be redefined to modules

defined.clusters <- seurat.combined@meta.data$Module

# Needs to be a named vector
names(defined.clusters) <- rownames(seurat.combined@meta.data)

# should be a factor vector
defined.clusters <- factor(defined.clusters, levels = c("Naive_Stem",
                                                        "Activated",
                                                        "Exhaustion",
                                                        "Innate",
                                                        "Cycling"))

reshaped.matrices <- reshape_matrices(count.matrix = expr.mat,
                                      clusters = defined.clusters,
                                      groups = defined.groups,
                                      replicates = defined.replicates,
                                      ligands.and.receptors = interact.for)


# Check out the hierarchy of the tibble
reshaped.matrices

unnest(reshaped.matrices,
       cols = "samples")

names(pull(unnest(reshaped.matrices, cols = "samples"))[[1]])


consistent.lig.recs <- create_lig_rec_tib.mod(exp.tib = reshaped.matrices,
                                              clusters = defined.clusters,
                                              groups = defined.groups,
                                              replicates = defined.replicates,
                                              cells.reqd = 10,
                                              freq.pos.reqd = 0.5,
                                              ligands.and.receptors = interact.for)

consistent.lig.recs


unnest(consistent.lig.recs[1,2], 
       cols = "lig.rec.exp")

pull(unnest(consistent.lig.recs[1,2],
            cols = "lig.rec.exp")[1,2])[[1]]

# Determine putative ligand/receptor pairs
put.int <- putative_interactions(ligand.receptor.tibble = consistent.lig.recs,
                                 clusters = defined.clusters,
                                 groups = defined.groups,
                                 freq.group.in.cluster = 0.05,
                                 ligands.and.receptors = interact.for)

# Identify and visualise unique ligand/receptor pairs in a group

# Identify unique ligand/receptor interactions present in each sample
unique.ints <- unique_interactions(put.int,
                                   group1 = "US",
                                   group2 = "Stim",
                                   interact.for)


#temp.df <- as.data.frame(unique.ints)

# Get data to plot circos unique to US
US.to.plot <- pull(unique.ints[1,2])[[1]]
for.circos.US <- pull(put.int[1,2])[[1]][US.to.plot]

circos_plot(interactions = for.circos.US,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray") 

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_US_modules.pdf")
dev.off()


#Get data to plot circos unique to Stim
Stim.to.plot <- pull(unique.ints[2,2])[[1]]
for.circos.Stim <- pull(put.int[2,2])[[1]][Stim.to.plot]

circos_plot(interactions = for.circos.Stim,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_Stim_modules.pdf")
dev.off()


# Get data to plot circos common 
Common.to.plot <- pull(unique.ints[3,2])[[1]]
for.circos.common <- pull(put.int[1,2])[[1]][Common.to.plot]

circos_plot(interactions = for.circos.common,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_Common_modules.pdf")
dev.off()


```

### Cellphonedb
```{r Cellphonedb}

# Create output directories
if(!dir.exists("output/tables/cellphonedb")){
  dir.create("output/tables/cellphonedb", 
             recursive = T)
}

# Cellphonedb is a python program - can also be used via an online webportal

# Prepare and export data for cellphonedb analysis



save.data.frame.function <- function(df, title){
  
  x <- as.data.frame(as.matrix(df))
  
  write.table(x, 
              paste0("output/tables/cellphonedb/", title, ".txt"),
              sep = "\t",
              quote = FALSE)
}




# Export dataset of all cells (US and Stim)

Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

save.data.frame.function(seurat.combined@assays$RNA@data, "cellphonedb_both_conditions_normed")


# Metadata with cluster annotation
tmp.meta.data <- cbind(rownames(seurat.combined@meta.data),
                       seurat.combined@meta.data[ ,"seurat_clusters", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_both_conditions_clusters.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)

# Metadata with module annotation
tmp.meta.data <- cbind(rownames(seurat.combined@meta.data),
                       seurat.combined@meta.data[ ,"Module", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_both_conditions_modules.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)


# Export dataset of just US cells
Idents(seurat.combined) <- seurat.combined@meta.data$condition

temp.seurat <- subset(seurat.combined, idents = "US")

Idents(temp.seurat) <- temp.seurat@meta.data$seurat_clusters

save.data.frame.function(temp.seurat@assays$RNA@data, "cellphonedb_US_normed")

# Metadata with cluster annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"seurat_clusters", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_US_clusters.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)

# Metadata with Module annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"Module", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_US_modules.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)



# Export dataset of just Stim cells
Idents(seurat.combined) <- seurat.combined@meta.data$condition

temp.seurat <- subset(seurat.combined, idents = "Stim")

Idents(temp.seurat) <- temp.seurat@meta.data$seurat_clusters

save.data.frame.function(temp.seurat@assays$RNA@data, "cellphonedb_Stim_normed")

# Metadata with cluster annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"seurat_clusters", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_Stim_clusters.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)


# Metadata with Module annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"Module", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_Stim_modules.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)


rm(tmp.meta.data, temp.seurat)


```

### iTalk
```{r iTalk}

# Create output directories
if(!dir.exists("output/figures/Cell_cell_interaction/iTALK")){
  dir.create("output/figures/Cell_cell_interaction/iTALK", 
             recursive = T)
}


# Load library
library(iTALK)


#############################
# Run analysis for clusters
#############################

# Downsample dataset
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

seurat.combined.small <- subset(seurat.combined, downsample = 300)

iTalk.input <- as.data.frame(seurat.combined.small@assays$RNA@data)

# Append metadata
temp <- as.data.frame(seurat.combined.small@meta.data)
sum(rownames(temp) != colnames(iTalk.input))

iTalk.input <- t(iTalk.input)
iTalk.input <- as.data.frame(iTalk.input)

iTalk.input$cell_type <- temp$seurat_clusters


# find top 50 percent highly expressed genes
highly_exprs_genes <- rawParse(iTalk.input, top_genes = 50, stats = 'mean')

# find the ligand-receptor pairs from highly expressed genes
comm_list<-c('growth factor','other','cytokine','checkpoint')

cell_col <- structure(c('Red','Blue','Green','Purple', 'Orange', 'Grey','Black', "Yellow", "Darkred", "lightblue", "Pink", "burlywood", "Brown", "Darkgreen"), names = unique(iTalk.input$cell_type))


par(mfrow = c(1,2))
par(mfrow = c(1,1))

res <- NULL

for(comm_type in comm_list){
  res_cat <- FindLR(highly_exprs_genes, 
                    datatype = 'mean count', 
                    comm_type = comm_type)
  
  res_cat <- res_cat[order(res_cat$cell_from_mean_exprs*res_cat$cell_to_mean_exprs, 
                           decreasing = TRUE), ]
  
  #plot by ligand category
  
  #top 50 ligand-receptor pairs
  LRPlot(res_cat[1:50,],
         datatype = 'mean count', 
         cell_col = cell_col,
         link.arr.lwd = res_cat$cell_from_mean_exprs[1:50], 
         link.arr.width = res_cat$cell_to_mean_exprs[1:50])
  title(comm_type)
  
  dev.copy(pdf, paste0("output/figures/Cell_cell_interaction/iTALK/Ligand_receptor_plot_", comm_type, ".pdf"))
  dev.off()
  
  res <- rbind(res,res_cat)
}






# Archived code below to plot network 1 by 1 for each cell type

#for(i in 1:14){

# col.vec <- rep("#BEBEBE00", 14)
#col.vec[i] <- "Red"


#cell_col <- structure(col.vec, names = unique(iTalk.input$cell_type))

#NetView(res_cat, 
#        col = cell_col,
#        vertex.label.cex = 1,
#        label = FALSE,
#        arrow.width = 1, 
#        edge.max.width = 20)

#}


```


## GSEA analysis {.tabset}

### Scillus
```{r Scillus_GSEA}

#remotes::install_github("xmc811/Scillus")

# Scillus package would not compile
# I took the functions and made a new .R file
# Some of the functions called and used in this script required modifications to work outside of the package environment

source("~/Documents/Work/Sciebo/Scripts/Packages/Scillus_package/Scillus_functions.R")
load("~/Documents/Work/Sciebo/Scripts/Packages/Scillus_package/pathways.hallmark.rda")


# Create output directories
if(!dir.exists("output/figures/GO_analysis/Scillus_GO")){
  dir.create("output/figures/GO_analysis/Scillus_GO", 
             recursive = T)
}

######################
# Module analysis
######################

# set idents to Module
Idents(seurat.combined) <- seurat.combined@meta.data$Module


# get a broad list of DEG markers 
Module.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA",
                                 only.pos = FALSE,
                                 min.diff.pct = 0.1,
                                 logfc.threshold = 0,
                                 return.thresh = 0.01)




# Threshold marker list by P value and fold change for GO analysis 

GO.markers <- Module.markers[Module.markers$p_val_adj < 0.05, ]
GO.markers <- GO.markers[abs(GO.markers$avg_logFC) > 0.25, ]
dim(Module.markers) #2,132 genes
dim(GO.markers) # 1,232 genes

table(GO.markers$cluster) # number of genes DEG per cluster // used to justify using topn = 100

# Plot Gene Ontology analysis
# CC, BP, MF

# To plot graph for a specific cluster use below code
#plot_cluster_go(Module.markers, cluster_name = "Activated", org = "human", ont = "MF")

# CC 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Modules_CC.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "CC")

dev.off()


# BP 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Modules_BP.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "BP")

dev.off()

# MF 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Modules_MF.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "MF")
dev.off()




# Perform GSEA 
gsea_res <- test_GSEA(Module.markers, 
                      pathway = pathways.hallmark)



plot_GSEA(gsea_res)
dev.copy(pdf, "output/figures/GO_analysis/Scillus_GO/GSEA_Module.pdf")
dev.off()


######################
# Cluster analysis
######################

# set idents to cluster
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# get a broad list of DEG markers 
Cluster.markers <- FindAllMarkers(seurat.combined,
                                  assay = "RNA",
                                  only.pos = FALSE,
                                  min.diff.pct = 0.1,
                                  logfc.threshold = 0,
                                  return.thresh = 0.01)




# Threshold marker list by P value and fold change for GO analysis 

GO.markers <- Cluster.markers[Cluster.markers$p_val_adj < 0.05, ]
GO.markers <- GO.markers[abs(GO.markers$avg_logFC) > 0.25, ]
dim(Cluster.markers) # 8,635 genes
dim(GO.markers) # 4,890 genes

table(GO.markers$cluster) # number of genes DEG per cluster // used to justify using topn = 100

# Plot Gene Ontology analysis
# CC, BP, MF

# To plot graph for a specific cluster use below code
#plot_cluster_go(Module.markers, cluster_name = "Activated", org = "human", ont = "MF")

# CC 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Clusters_CC.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "CC")

dev.off()


# BP 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Clusters_BP.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "BP")

dev.off()

# MF 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Clusters_MF.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "MF")
dev.off()




# Perform GSEA 
gsea_res <- test_GSEA(Cluster.markers, 
                      pathway = pathways.hallmark)



plot_GSEA(gsea_res)
dev.copy(pdf, "output/figures/GO_analysis/Scillus_GO/GSEA_Clusters.pdf")
dev.off()


```





## Misc analysis {.tabset}

### Secretome // Unfinished chunk 
```{r Secretome}

# set working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output/figures/Secretome")){
  dir.create("output/figures/Secretome",
             recursive = T)}

output.dir <- "output/figures/Secretome"
setwd(output.dir)

# Read in data
chemo.cytokines <- read.csv(paste0(working.dir, "/Input_data/Secretome/ChemoCytokines.csv"))
receptors <- read.csv(paste0(working.dir, "/Input_data/Secretome/receptors.csv"))


# Set idents
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Identify which of the query genes are in the database
query.genes <- unique(c(chemo.cytokines$GeneID, receptors$GeneID))

logic.vec <- rownames(seurat.combined) %in% query.genes
genes.to.test <- rownames(seurat.combined)[logic.vec]


# Run DEG test on all genes in query set that can be found in database
Query.DEG <- FindAllMarkers(seurat.combined,
                            assay = "RNA",
                            features = genes.to.test,
                            only.pos = FALSE,
                            min.diff.pct = 0.1,
                            logfc.threshold = 0,
                            return.thresh = 0.01)


# Filter Query.DEG for sig and arrange by LogFC within groups for nicer plotting
genes.plot <- Query.DEG %>% 
  dplyr::filter(p_val_adj < 0.05) %>%
  dplyr::group_by(cluster) %>%
  dplyr::arrange(desc(avg_logFC), .by_group = TRUE) %>%
  dplyr::select(gene)

genes.plot <- unique(genes.plot$gene)


# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)


# Plot all genes DEG from query list
DoHeatmap(average.seurat, 
          features = genes.plot, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "All_sig_genes.pdf")
dev.off()



# Plot just chemokine and cytokine genes
logic.vec <- genes.plot %in% receptors$GeneID
chemo.cytokine.genes <- genes.plot[!logic.vec]

DoHeatmap(average.seurat, 
          features = chemo.cytokine.genes, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Chemo_cytokine_genes.pdf")
dev.off()


# Plot just receptor genes
logic.vec <- genes.plot %in% receptors$GeneID
receptor.genes <- genes.plot[logic.vec]

DoHeatmap(average.seurat, 
          features = receptor.genes, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Receptor_genes.pdf")
dev.off()


# Return to working dir
setwd(working.dir)

# remove unneeded variables
rm(receptor.genes, genes.plot, receptors, chemo.cytokine.genes, average.seurat, Query.DEG)
```
 
### ProjecTILs
```{r ProjecTILs}

# Use ProjecTILs package from Carmona Lab to map TILS to mouse T cell atlas 

# Create output directory
if(!dir.exists("output/figures/ProjecTILs")){
  dir.create("output/figures/ProjecTILs",
             recursive = T)}

# Load package as install failed. Killed: 9 error
devtools::load_all("~/Documents/Work/Sciebo/Scripts/Packages/ProjecTILs-master-devbranch/")

#library(Seurat)
library(ProjecTILs)
library(gridExtra)

# load reference map 
ref <- load.reference.map()

# project dataset onto mouse Atlas
query.projected <- make.projection(seurat.combined, 
                                   query.assay = "RNA", 
                                   filter.cells = FALSE,
                                   ref = ref,
                                   human.ortho = TRUE)

 # plot projection on mouse Atlas
plot.projection(ref, query.projected)

# predict cell state
query.projected <- cellstate.predict(ref = ref,
                                     query = query.projected)

# Evaluate cluster call 
table(query.projected$functional.cluster, query.projected$seurat_clusters)

# Sanity check for rough overlay of UMAP dims 
temp.names <- rownames(query.projected@reductions$umap@cell.embeddings)
temp.names <- gsub("Q_", "", temp.names)
sum(temp.names != rownames(seurat.combined@reductions$umap@cell.embeddings))

# Change umap dims to original projection 
query.projected@reductions$umap@cell.embeddings <- seurat.combined@reductions$umap@cell.embeddings
rownames(query.projected@reductions$umap@cell.embeddings) <- paste0("Q_", rownames(query.projected@reductions$umap@cell.embeddings))



# show were cells sit by highlighting a single cell annotation each time 

# Loop over all clusters 

for(i in 1:9){
  
# set up col vector
temp.cols <- rep("Grey", 9)

# Set 1 cluster to be highlighted 
temp.cols[i] <- "Blue"


print(DimPlot(query.projected,
        reduction = "umap", 
        group.by = "functional.cluster", 
        pt.size = 1, 
        cols = temp.cols,
        label = FALSE))

dev.copy(pdf, paste0("output/figures/ProjecTILs/MouseAtlas_projection_cluster_", i, ".pdf"))
dev.off()
  
  
}


```


## Additional analysis {.tabset}

### Cell cycle analysis
```{r cell_cycle}

# Analyse if there is any enrichment for cell cycle stage

if(!dir.exists("output/figures/cell_cycle")){
  dir.create("output/figures/cell_cycle")
}

##################################
# Ensure idents is set up
##################################

Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters



################
# Read in data
################

exp.mat <- read.table(file = "Input_data/Cell_cycle_input_dataset/cell_cycle_vignette_files/nestorawa_forcellcycle_expressionMatrix.txt", 
                      header = TRUE, 
                      as.is = TRUE, row.names = 1)

# A list of cell cycle markers, from Tirosh et al, 2015, is loaded with Seurat.
# We can segregate this list into markers of G2/M phase and markers of S phase

cc.genes$s.genes
cc.genes$g2m.genes

s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes


#######################
# Cell cycle analysis
#######################

seurat.combined <- CellCycleScoring(seurat.combined, 
                                    s.features = s.genes, 
                                    g2m.features = g2m.genes, 
                                    set.ident = FALSE)


head(seurat.combined@meta.data)


#######################
# Visualisation
#######################

UMAPPlot(seurat.combined, 
         group.by = "Phase",
         split.by = "condition",
         pt.size = 1)

dev.copy(pdf, "output/figures/cell_cycle/UMAP_CellCycle_Phase.pdf")
dev.off()


FeaturePlot(seurat.combined, 
            reduction = "umap",
            features = "S.Score",
            pt.size = 1.5, 
            label = TRUE, 
            label.size = 5,
            order = TRUE, 
            cols = c("lightgray", "orange", "red")) + NoLegend()

dev.copy(pdf, "output/figures/cell_cycle/FeaturePlot_S.pdf")
dev.off()

FeaturePlot(seurat.combined, 
            reduction = "umap",
            features = "G2M.Score",
            pt.size = 1.5, 
            label = TRUE, 
            label.size = 5,
            order = TRUE, 
            cols = c("lightgray", "orange", "red")) + NoLegend()

dev.copy(pdf, "output/figures/cell_cycle/FeaturePlot_G2M.pdf")
dev.off()

#######################
# Vln plots
#######################

VlnPlot(seurat.combined, 
        features = "S.Score")

dev.copy(pdf, "output/figures/cell_cycle/VlnPlot_Sscore.pdf")
dev.off()


VlnPlot(seurat.combined,
        features = "G2M.Score")

dev.copy(pdf, "output/figures/cell_cycle/VlnPlot_G2Mscore.pdf")
dev.off()

#######################
# Ridge plots
#######################

RidgePlot(seurat.combined, 
          features = c("S.Score", "G2M.Score"), 
          log = TRUE)

dev.copy(pdf, "output/figures/cell_cycle/RidgePlot_S_and_G2Mscore.pdf")
dev.off()


table(seurat.combined@meta.data$Phase)


```

### CytoTRACE
```{r cytoTRACE_analysis}

#####################
# Install package
#####################

#BiocManager::install("sva")

# Package wont install, killed 9 error. so load locally workaround 
#devtools::install_local("~/Documents/Work/Sciebo/Scripts/CytoTRACE_0.3.2.tar.gz")
devtools::load_all("~/Documents/Work/Sciebo/Scripts/Packages/CytoTRACE/")

# run in terminal 
# pip install scanoramaCT
# pip install numpy

# Example dataset
#data.file <- read.delim("CytoTRACE_Analysis/Example_datasets/Bone_marrow_10x_matrix.txt")
#data.pheno <- read.delim("CytoTRACE_Analysis/Example_datasets/Bone_marrow_10x_metadata.txt")


##############################
# Create output directories
##############################

if(!dir.exists("output/figures/CytoTRACE")){dir.create("output/figures/CytoTRACE", recursive = T)}

##############
# Load library
##############

library("CytoTRACE")


# Prepare data

# Expression matrix (Raw data)
data.file <- as.data.frame(seurat.combined@assays$RNA@counts)
head(data.file[1:10, 1:10])

# Metadata file
data.pheno <- as.data.frame(seurat.combined@meta.data)
head(data.pheno)

# Run cytoTRACE
Trace.object <- CytoTRACE(data.file,
                          enableFast = TRUE,
                          ncores = 6, 
                          subsamplesize = 1000)


# Create phenotype label vector
pheno.labels <- as.character(data.pheno$seurat_clusters)
names(pheno.labels) <- rownames(data.pheno)



# Small error in plotCytoTRACE function, needed to correct function locally
source("~/Documents/Work/Sciebo/Scripts/CytoTrace_modified_function.R")

# Plot data
cytoTRACE.mod(Trace.object,
              emb = data.pheno[ , c("UMAP_1", "UMAP_2")],
              phenotype = pheno.labels,
              outputDir = paste0(working.dir, "/output/figures/CytoTRACE/"))



plotCytoGenes(Trace.object, 
              numOfGenes = 50,
              outputDir = paste0(working.dir, "/output/figures/CytoTRACE/"))




# Remove variables to save space and prevent errors
rm(data.file, data.pheno, Trace.object, pheno.labels)


```


## TCR analysis - based on scRNAseq expression {.tabset}

### Expression of TCR genes
```{r TCR_gene_expression}

# Set wd
setwd(working.dir)

# Create output directories
if(!dir.exists("output/figures/TCR_gene_expression/VlnPlot")){
  dir.create("output/figures/TCR_gene_expression/VlnPlot",
             recursive = T)}

# set and move to output.dir
output.dir <- "output/figures/TCR_gene_expression"
setwd(output.dir)

# set idents
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# set assay 
DefaultAssay(seurat.combined) <- "RNA"


# Find TCR genes to plot
genes <- rownames(seurat.combined)

pattern <- c("TRAV", "TRBV", "TRAC", "TRBC", "TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

length(TCR.genes)


for(i in 1:length(TCR.genes)){
  print(paste0("Plotting ", TCR.genes[i]))
  
  skip.iteration <- FALSE
  tryCatch(print(VlnPlot(seurat.combined, 
                         paste0(TCR.genes[i]),
                         log = T,
                         group.by = "seurat_clusters",
                         pt.size = 0)),
           error = function(e){skip.iteration <- TRUE})
  if(skip.iteration){next}
  
  
  dev.copy(pdf, paste0("VlnPlot/VlnPlot_", TCR.genes[i], ".pdf"))
  dev.off()
  
}


##################################################
# Plot heatmap of gene expression for TCR genes
##################################################



# get average expression 
Avg.seurat <- AverageExpression(seurat.combined,
                                   assay = "RNA",
                                   slot = "data",
                                   verbose = TRUE,
                                   return.seurat = TRUE)



# TCRA genes 
pattern <- c("TRAV", "TRAC")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRA_genes.pdf")
dev.off()


# TCRB genes
pattern <- c("TRBV", "TRBC")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRB_genes.pdf")
dev.off()




# TCRG and TCRD genes
pattern <- c("TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG_TCRD_genes_all_clusts.pdf")
dev.off()



#################################################
# Heatmaps with just G/D and MAIT clusters
#################################################

# Subset data for just GD and MAIT clusters 
Avg.seurat <- subset(Avg.seurat, idents = c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT"))

# Plot all TCRG and TCRD genes across just G/D and MAIT clusters
pattern <- c("TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG_TCRD_genes_gd_MAIT_clusts.pdf")
dev.off()


# Plot all specific G/D TCR and KLRB1 gene expression
TCR.genes <- c("TRGV9", "TRDV2", "TRGC1", "TRGC2", "TRDC", "TRAV1-2", "KLRB1")


DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG9_TCRD2_KLRB1_expression_gd_MAIT_clusts.pdf")
dev.off()


# Remove unneeded object
rm(Avg.seurat)

# return to working directory
setwd(working.dir)

```

### Expression of TCR genes // IMPUTED
```{r TCR_gene_expression_imputed}

# Set wd
setwd(working.dir)

# Create output directories
if(!dir.exists("output/figures/TCR_gene_expression/Imputed/VlnPlot")){
  dir.create("output/figures/TCR_gene_expression/Imputed/VlnPlot",
             recursive = T)}

# set and move to output.dir
output.dir <- "output/figures/TCR_gene_expression/Imputed"
setwd(output.dir)

# set idents
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# set assay 
DefaultAssay(seurat.combined) <- "alra"


# Find TCR genes to plot
genes <- rownames(seurat.combined)

pattern <- c("TRAV", "TRBV", "TRAC", "TRBC", "TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

length(TCR.genes)


for(i in 1:length(TCR.genes)){
  print(paste0("Plotting ", TCR.genes[i]))
  
  skip.iteration <- FALSE
  tryCatch(print(VlnPlot(seurat.combined, 
                         paste0(TCR.genes[i]),
                         log = T,
                         group.by = "seurat_clusters",
                         pt.size = 0)),
           error = function(e){skip.iteration <- TRUE})
  if(skip.iteration){next}
  
  
  dev.copy(pdf, paste0("VlnPlot/VlnPlot_", TCR.genes[i], "_imputed.pdf"))
  dev.off()
  
}


##################################################
# Plot heatmap of gene expression for TCR genes
##################################################



# get average expression 
Avg.seurat <- AverageExpression(seurat.combined,
                                   assay = "alra",
                                   slot = "data",
                                   verbose = TRUE,
                                   return.seurat = TRUE)



# TCRA genes 
pattern <- c("TRAV", "TRAC")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRA_genes_imputed.pdf")
dev.off()


# TCRB genes
pattern <- c("TRBV", "TRBC")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRB_genes_imputed.pdf")
dev.off()




# TCRG and TCRD genes
pattern <- c("TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG_TCRD_genes_all_clusts_imputed.pdf")
dev.off()



#################################################
# Heatmaps with just G/D and MAIT clusters
#################################################

# Subset data for just GD and MAIT clusters 
Avg.seurat <- subset(Avg.seurat, idents = c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT"))

# Plot all TCRG and TCRD genes across just G/D and MAIT clusters
pattern <- c("TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG_TCRD_genes_gd_MAIT_clusts_imputed.pdf")
dev.off()


# Plot all specific G/D TCR and KLRB1 gene expression
TCR.genes <- c("TRGV9", "TRDV2", "TRGC1", "TRGC2", "TRDC", "TRAV1-2", "KLRB1")


DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG9_TCRD2_KLRB1_expression_gd_MAIT_clusts_imputed.pdf")
dev.off()


# Remove unneeded object
rm(Avg.seurat)

# return to working directory
setwd(working.dir)

```


## TCR analysis - formatting {.tabset}

### Load scRepertoire package
```{r Load_scRep_Package}

# If using R < 4, should use the dev version with @dev
#devtools::install_github("ncborcherding/scRepertoire")
#install.packages("ggalluvial")

# Package fails to load - use this trick to get tools of the package 
devtools::load_all("~/Documents/Work/Sciebo/Scripts/Packages/scRepertoire/")


```
 
### Format data with scRepertoire
```{r Format_data_with_scRep}
#################################
# Read in and format data
#################################

# read in contig files
S1.contig <- read.csv("Input_data/VDJ_data/Sample1_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S2.contig <- read.csv("Input_data/VDJ_data/Sample2_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S3.contig <- read.csv("Input_data/VDJ_data/Sample3_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S4.contig <- read.csv("Input_data/VDJ_data/Sample4_filtered_contig_annotations.csv", stringsAsFactors = FALSE)

# create list of contigs
contig.list <- list(S1.contig, S2.contig,
                    S3.contig, S4.contig)

# Combine contig list
combined.contig <- combineTCR(contig.list, 
                              samples = c("S1", "S2", "S3", "S4"), 
                              ID = c("US", "US", "Stim", "Stim"), 
                              cells = "T-AB",
                              removeNA = TRUE,
                              removeMulti = FALSE, 
                              filterMulti = TRUE) # take the top 2 expressed chains for cells with multiple chains 

# on average, filteringMulti results in approx. 200 more cells for each sample than outright removing cells


# Need to amend BarcodeID to match with seurat object
combined.contig$S1_US$barcode <- gsub("US_", "", combined.contig$S1_US$barcode)
combined.contig$S2_US$barcode <- gsub("US_", "", combined.contig$S2_US$barcode)
combined.contig$S3_Stim$barcode <- gsub("Stim_", "", combined.contig$S3_Stim$barcode)
combined.contig$S4_Stim$barcode <- gsub("Stim_", "", combined.contig$S4_Stim$barcode)


# Combine seurat object with contig info
seurat.tcr <- combineExpression(combined.contig,
                                seurat.combined,
                                cloneCall = "aa",
                                cloneTypes = c(None = 0, Single = 1, Small = 5, Medium = 10, Large = 20, Hyperexpanded = 150),
                                groupBy = "none", # Alternative frequencies are calculated in next code Chunk
                                filterNA = TRUE) # should seurat object be subsetted to remove NA values

# Max freq of a clonotype is 127, therefore reset cloneTypes accordingly

# Seurat object went from 11658 samples to 6625 samples 
# Therefore 56% of original dataset remains 


# Remove frequency column calculated by combineExpression function
logic.vec <- grepl("Frequency", colnames(seurat.tcr@meta.data))
seurat.tcr@meta.data[ ,logic.vec] <- NULL
head(seurat.tcr@meta.data)

# Ensure seurat object cloneType var is a factor with correct levels
seurat.tcr@meta.data$cloneType <- factor(seurat.tcr@meta.data$cloneType, 
                                         levels = c("Hyperexpanded (20 < X <= 150)",
                                                    "Large (10 < X <= 20)", 
                                                    "Medium (5 < X <= 10)",
                                                    "Small (1 < X <= 5)", 
                                                    "Single (0 < X <= 1)"))

# remove unneeded objects
rm(combined.contig, contig.list, S1.contig, S2.contig, S3.contig, S4.contig)

```

### Count clonotype frequencies and normalise
```{r Count_and_normalise_clonotype_frequencies}

####################################################################################
# Need to count clonotype occurrence per condition and then normalise this value 
####################################################################################

# create temp meta.data df and append cell_ID as column (lost in dplyr workflow)
meta.data.temp <- seurat.tcr@meta.data
meta.data.temp$cell_ID <- rownames(seurat.tcr@meta.data)

corner(meta.data.temp, c = ncol(meta.data.temp))


# Get total number of cells in each condition
US.cell.n <- table(meta.data.temp$condition)[1] # 3,184 
Stim.cell.n <- table(meta.data.temp$condition)[2] # 3,441
total.cell.n <- US.cell.n + Stim.cell.n # 6,625 

#dim(meta.data.temp) // sanity check of total cell number




####################################################################################
# Count occurence of clonotypes across entire dataset 
####################################################################################
# Also: Normalise n() by # of cells within dataset
meta.data.temp <- meta.data.temp %>%
  dplyr::group_by(CTaa) %>%
  dplyr::mutate(Total_clonotype_n = n()) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(Total_clonotype_freq = (Total_clonotype_n/total.cell.n)*100) %>%
  dplyr::ungroup()

####################################################################################
# Count occurence of clonotypes across entire condition 
####################################################################################
# Also: Normalise n() by # of cells within condition
meta.data.temp <- meta.data.temp %>%
  dplyr::group_by(CTaa, condition) %>%
  dplyr::mutate(Clone_conditionwise_n = n()) %>%
  dplyr::group_by(condition) %>%
  dplyr::mutate(Clone_conditionwise_freq = case_when(condition == "US" ~ (Clone_conditionwise_n/US.cell.n)*100, 
                                                         condition == "Stim" ~ (Clone_conditionwise_n/Stim.cell.n)*100)) %>%
  dplyr::ungroup()

####################################################################################
# Count occurence of clonotypes within each cluster per condition 
####################################################################################
# Also: Normalise n() by # of cells within condition
meta.data.temp <- meta.data.temp %>%
  dplyr::group_by(CTaa, condition, seurat_clusters) %>%
  dplyr::mutate(Clone_Clust_conditionwise_n = n()) %>%
  dplyr::group_by(condition) %>%
  dplyr::mutate(Clone_Clust_conditionwise_freq = case_when(condition == "US" ~ (Clone_Clust_conditionwise_n/US.cell.n)*100, 
                                                         condition == "Stim" ~ (Clone_Clust_conditionwise_n/Stim.cell.n)*100)) %>%
  dplyr::ungroup()


######################################
# Add new metadata to seurat object
######################################

#########
# Total 
#########

# Add total clonotype n value
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Total_clonotype_n",
                          metadata = meta.data.temp$Total_clonotype_n)

# Add total clonotype freq
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Total_clonotype_freq",
                          metadata = meta.data.temp$Total_clonotype_freq)

##################
# Condition-wise 
##################

# Add clone condition-wise n value
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Clone_conditionwise_n",
                          metadata = meta.data.temp$Clone_conditionwise_n)

# Add Clone condition-wise freq
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Clone_conditionwise_freq",
                          metadata = meta.data.temp$Clone_conditionwise_freq)

################################
# Cluster and Condition-wise 
################################

# Add Clone Clust and condition-wise n value
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Clone_Clust_conditionwise_n",
                          metadata = meta.data.temp$Clone_Clust_conditionwise_n)

# Add Clone Clust and condition-wise Freq
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Clone_Clust_conditionwise_freq",
                          metadata = meta.data.temp$Clone_Clust_conditionwise_freq)


#############################################
# Scale variables for downstream plotting
#############################################
scale.var <- c(0, 10)

# Scale total clonotype number
seurat.tcr@meta.data$Total_clonotype_scaled <- scales::rescale(seurat.tcr@meta.data$Total_clonotype_n, 
                                                               to = scale.var)


# Scale clonotype per condition freq
seurat.tcr@meta.data$Clone_conditionwise_scaled <- scales::rescale(seurat.tcr@meta.data$Clone_conditionwise_freq, 
                                                                   to = scale.var)

# Scale clonotype per cluster per condition freq
seurat.tcr@meta.data$Clone_Clust_conditionwise_scaled <- scales::rescale(seurat.tcr@meta.data$Clone_Clust_conditionwise_freq, 
                                                                         to = scale.var)




rm(meta.data.temp)


```
 
### Export or read in tcr seurat object
```{r export_RDS}

if(quick.load){
  seurat.tcr <- readRDS("Exported_RDS_files/seurat_tcr.rds")
}else if(!quick.load){
  saveRDS(seurat.tcr, file = "Exported_RDS_files/seurat_tcr.rds")
}

```

## TCR analysis - General analysis {.tabset}

### Heatmaps VJ gene usage
```{r V_J_usage_heatmaps}

# Move to working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output/figures/TCRseq/VJ_usage")){
  dir.create("output/figures/TCRseq/VJ_usage",
             recursive = T)}

# set and move to output.dir
output.dir <- "output/figures/TCRseq/VJ_usage"
setwd(output.dir)



########################
# Heatmap functions
########################

hclust.func <- function(x){
  hclust(x, method = 'ward.D2')
}

dist.func <- function(x){
  dist(x,method = 'binary')
}

col.palette <- colorRampPalette(brewer.pal(8, "RdYlBu"))(600)

######################################################
# Plot V/J gene usage as a log2() of cell number
######################################################

# TRA-V gene usage

x <- table(seurat.tcr@meta.data$v_gene_A, seurat.tcr@meta.data$seurat_clusters)

cells.remove <- c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT")

x <- x[ ,-grep(paste0(cells.remove, collapse = "|"), colnames(x))]


heatmap.2(as.matrix(log2(x+1)), 
          scale = "none",
          trace = "none",
          Colv = TRUE,
          cexRow = 0.5, 
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_TRA_V_usage.pdf")
dev.off()

# TRA-J gene usage

x <- table(seurat.tcr@meta.data$j_gene_A, seurat.tcr@meta.data$seurat_clusters)

cells.remove <- c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT")

x <- x[ ,-grep(paste0(cells.remove, collapse = "|"), colnames(x))]


heatmap.2(as.matrix(log2(x+1)), 
          scale = "none",
          trace = "none",
          Colv = TRUE,
          cexRow = 0.5, 
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_TRA_V_usage.pdf")
dev.off()


# TRB-V gene usage

x <- table(seurat.tcr@meta.data$v_gene_B, seurat.tcr@meta.data$seurat_clusters)

cells.remove <- c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT")

x <- x[ ,-grep(paste0(cells.remove, collapse = "|"), colnames(x))]


heatmap.2(as.matrix(log2(x+1)), 
          scale = "none",
          trace = "none",
          Colv = TRUE,
          cexRow = 0.5, 
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_TRB_V_usage.pdf")
dev.off()



# TRB-J gene usage

x <- table(seurat.tcr@meta.data$j_gene_B, seurat.tcr@meta.data$seurat_clusters)

cells.remove <- c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT")

x <- x[ ,-grep(paste0(cells.remove, collapse = "|"), colnames(x))]


heatmap.2(as.matrix(log2(x+1)), 
          scale = "none",
          trace = "none",
          Colv = TRUE,
          cexRow = 0.5, 
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_TRB_J_usage.pdf")
dev.off()




# Reset working dir
setwd(working.dir)




```

### Heatmap of top clonotypes
```{r Heatmap_top_clonotypes}

# Move to working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output/figures/TCRseq/Top_clonotypes_heatmaps")){
  dir.create("output/figures/TCRseq/Top_clonotypes_heatmaps",
             recursive = T)}

# set and move to output.dir
output.dir <- "output/figures/TCRseq/Top_clonotypes_heatmaps"
setwd(output.dir)



########################
# Heatmap functions
########################

hclust.func <- function(x){
  hclust(x, method = 'ward.D2')
}

dist.func <- function(x){
  dist(x,method = 'binary')
}

col.palette <- colorRampPalette(brewer.pal(8, "RdYlBu"))(600)












# Get data of how many cells in each cluster are assigned to what clonotypes
clonotype.data <- table(seurat.tcr@meta.data$CTaa, seurat.tcr@meta.data$seurat_clusters)

# remove non-T cell clusters
cells.remove <- c("gd_T_non_g9d2", "gd_T_g9d2")
cells.remove.index <- grep(paste0(cells.remove, collapse = "|"), colnames(clonotype.data))
clonotype.data <- clonotype.data[ ,-cells.remove.index]

# also filter colouring variable to remove non-T cell clusters
temp.cols <- clust.cols[-cells.remove.index]






# Plot the top 10 clonotypes
aa.keep <- sort(rowSums(clonotype.data), decreasing = TRUE)[1:10]

keep.vec <- rownames(clonotype.data) %in% names(aa.keep)

plot.data <- clonotype.data[keep.vec, ]


heatmap.2(as.matrix(log2(plot.data+1)), 
          scale = "none",
          trace = "none",
          ColSideColors = temp.cols,
          Colv = TRUE,
          cexRow = 0.8, 
          margins = c(8, 15),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_top_10_clonotypes.pdf")
dev.off()



# Plot the top 50 clonotypes
aa.keep <- sort(rowSums(clonotype.data), decreasing = TRUE)[1:50]

keep.vec <- rownames(clonotype.data) %in% names(aa.keep)

plot.data <- clonotype.data[keep.vec, ]


heatmap.2(as.matrix(log2(plot.data+1)), 
          scale = "none",
          trace = "none",
          ColSideColors = temp.cols,
          Colv = TRUE,
          cexRow = 0.5, 
          labRow = FALSE,
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_top_50_clonotypes.pdf")
dev.off()



# Plot the all clonotypes in > 3 cells

aa.keep <- rowSums(clonotype.data) > 3

keep.vec <- rownames(clonotype.data) %in% names(aa.keep)[aa.keep]

plot.data <- clonotype.data[keep.vec, ]

heatmap.2(as.matrix(log2(plot.data+1)), 
          scale = "none",
          trace = "none",
          ColSideColors = temp.cols,
          Colv = TRUE,
          cexRow = 0.5, 
          labRow = FALSE,
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_top_all_clonotypes_in_morethan_3_cells.pdf")
dev.off()

# Reset working dir
setwd(working.dir)
```

### Analysis with scRepertoire
```{r scRepertoire_analysis}

# Ensure dir back in working
setwd(working.dir)

# Create output directories
if(!dir.exists("output/figures/TCRseq/scRepertoire/clusters")){
  dir.create("output/figures/TCRseq/scRepertoire/clusters",
             recursive = T)}

if(!dir.exists("output/figures/TCRseq/scRepertoire/modules")){
  dir.create("output/figures/TCRseq/scRepertoire/modules",
             recursive = T)}

output.dir <- "output/figures/TCRseq/scRepertoire"
setwd(output.dir)

#########################
# Set uniform variables 
#########################

# for clonalProportion split
split.var <- c(1, 5, 10, 20, 50, 500, 5000, 1e+05)

# for clonalHomeostasis split
homeostasis.var <- c(Rare = 0.001, 
                     very_small = 0.002,
                     Small = 0.005, 
                     Medium = 0.01, 
                     Large = 0.05, 
                     very_Large = 0.1, 
                     Hyperexpanded = 1)


#########################################################
# Perform basic clonotype analysis and visualisation
#########################################################

# quantify % unique clonotype per sample
quantContig(combined.contig,
            cloneCall="aa", 
            scale = TRUE)

dev.copy(pdf, "Quant_contig_sample.pdf")
dev.off()

# quantify % unique clonotype per group
quantContig(combined.contig,
            cloneCall="aa", 
            group = "ID",
            scale = TRUE)

dev.copy(pdf, "Quant_contig_treatment.pdf")
dev.off()


# abundance of clonotypes
abundanceContig(combined.contig,
                cloneCall = "aa",
                group = "ID", 
                scale = TRUE)

dev.copy(pdf, "Clonotype_abundance_by_treatment.pdf")
dev.off()



# Chain length overview 
lengthContig(combined.contig, 
             cloneCall="aa", 
             chains = "combined",
             group = "ID") 

dev.copy(pdf, "Chain_length_combined.pdf")
dev.off()

# Chain length by chain
lengthContig(combined.contig, 
             cloneCall="aa", 
             chains = "single",
             group = "ID")

dev.copy(pdf, "Chain_length_by_locus.pdf")
dev.off()


## Something looks weird with the alluvial plots - lines dont line up

# Compare clonotypes across samples

compareClonotypes(combined.contig,
                  numbers = 20, 
                  samples = c("S1_US", "S3_Stim"), 
                  cloneCall = "aa", 
                  graph = "alluvial") + NoLegend()


compareClonotypes(combined.contig,
                  numbers = 20, 
                  samples = c("S2_US", "S4_Stim"), 
                  cloneCall = "aa", 
                  graph = "alluvial") + NoLegend()



# Overview of clonal homeostasis
clonalHomeostasis(combined.contig, 
                  cloneType = homeostasis.var,
                  cloneCall = "aa")

dev.copy(pdf, "clonalHomeostasis.pdf")
dev.off()


# Clonal Proportion
clonalProportion(combined.contig,
                 split = split.var,
                 cloneCall = "aa") 

dev.copy(pdf, "clonalProportion.pdf")
dev.off()

# clonal overlap
clonalOverlap(combined.contig, 
              cloneCall = "aa", 
              method = "morisita")

dev.copy(pdf, "cloncalOverlap.pdf")
dev.off()


# clone size distribution
clonesizeDistribution(combined.contig, 
                      cloneCall = "aa", 
                      method = "ward.D2")

dev.copy(pdf, "cloneSizeDistribution.pdf")
dev.off()

# Clonal Diversity 
clonalDiversity(combined.contig,
                cloneCall = "aa",
                group = "ID")

dev.copy(pdf, "clonalDiversity.pdf")
dev.off()



########################################################################
# perform basic repertoire analysis across clusters & modules
########################################################################

# Modified function, original was not subsetting correctly
expression2List.mod <- function(sc, group){
  meta <- grabMeta(sc)
  unique.var <- str_sort(as.character(unique(meta[,group])), numeric = TRUE)
  df <- NULL
  for (i in seq_along(unique.var)) {
    subset.var <- meta[meta[,group] == unique.var[i],]
    df[[i]] <- subset.var
  }
  names(df) <- unique.var
  
  return(df)
}


tcr.clusters <- expression2List.mod(seurat.tcr, group = "seurat_clusters")

tcr.modules <- expression2List.mod(seurat.tcr, group = "Module")



####################
# Clonal Diversity 
####################

# Clusters
clonalDiversity(tcr.clusters, 
                cloneCall = "aa")

dev.copy(pdf, "clusters/clonalDiversity_clusters.pdf")
dev.off()

# Modules
clonalDiversity(tcr.modules, 
                cloneCall = "aa")

dev.copy(pdf, "modules/clonalDiversity_modules.pdf")
dev.off()



####################
# Clonal Homeostasis
####################


# Clusters
clonalHomeostasis(tcr.clusters, 
                  cloneType = homeostasis.var,
                  cloneCall = "aa") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "clusters/clonalHomeostasis_clusters.pdf")
dev.off()

# Modules
clonalHomeostasis(tcr.modules, 
                  cloneType = homeostasis.var,
                  cloneCall = "aa") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "modules/clonalHomeostasis_modules.pdf")
dev.off()


####################
# Clonal Proportion
####################

# Clusters
clonalProportion(tcr.clusters, 
                 split = split.var,
                 cloneCall = "aa") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "clusters/clonalproportion_clusters.pdf")
dev.off()


# Modules
clonalProportion(tcr.modules, 
                 split = split.var,
                 cloneCall = "aa") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "modules/clonalproportion_modules.pdf")
dev.off()



####################
# Clonal Overlap
####################

# Clusters
clonalOverlap(tcr.clusters, 
              cloneCall = "aa", 
              method = "overlap") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "clusters/clonaloverlap_clusters.pdf")
dev.off()

# Modules
clonalOverlap(tcr.modules, 
              cloneCall = "aa", 
              method = "overlap") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "modules/clonaloverlap_modules.pdf")
dev.off()





###################################
# Split dataset by condition
###################################

Idents(seurat.tcr) <- seurat.tcr@meta.data$condition

# US
US.seurat.tcr <- subset(seurat.tcr, ident = "US")
tcr.clusters.US <- expression2List.mod(US.seurat.tcr, group = "seurat_clusters")

# Stimulated
Stim.seurat.tcr <- subset(seurat.tcr, ident = "Stim")
tcr.clusters.Stim <- expression2List.mod(Stim.seurat.tcr, group = "seurat_clusters")




p1 <- clonalOverlap(tcr.clusters.US, 
                    cloneCall = "aa", 
                    method = "overlap") + 
  theme(axis.text.x = element_text(angle = 90))

p2 <- clonalOverlap(tcr.clusters.Stim, 
                    cloneCall = "aa", 
                    method = "overlap") + 
  theme(axis.text.x = element_text(angle = 90))


p1|p2



rm(US.seurat.tcr, tcr.clusters.US, Stim.seurat.tcr, tcr.clusters.Stim, tcr.modules, tcr.clusters)


# reset to working dir
setwd(working.dir)
```

### Clonotype frequency on UMAP
```{r Clonotype_freq}

# Ensure dir back in working
setwd(working.dir)

# Create output directory
if(!dir.exists("output/figures/TCRseq/Binned_clonotype_expansion_plots")){
  dir.create("output/figures/TCRseq/Binned_clonotype_expansion_plots",
             recursive = T)}

output.dir <- "output/figures/TCRseq/Binned_clonotype_expansion_plots"
setwd(output.dir)

###################################
# Plot dataset on UMAP projection
###################################

Idents(seurat.tcr) <- seurat.tcr@meta.data$seurat_clusters

clonetype.col <- c("Red", "Black", "blue", "orange", "lightblue")

# Vis clonotype size on UMAP
UMAPPlot(seurat.tcr, 
         group.by = "cloneType", 
         pt.size = 1) +
  scale_color_manual(values = clonetype.col, 
                     na.value="grey")


dev.copy(pdf, "Clonotype_size_UMAP.pdf")
dev.off()

# Split by condition
UMAPPlot(seurat.tcr, 
         group.by = "cloneType", 
         split.by = "condition", 
         pt.size = 1) +
  scale_color_manual(values = clonetype.col, 
                     na.value="grey")

dev.copy(pdf, "Clonotype_size_UMAP_split_condition.pdf")
dev.off()


# Split by cloneType visualise clusters
UMAPPlot(seurat.tcr, 
         group.by = "seurat_clusters", 
         split.by = "cloneType", 
         pt.size = 1, 
         cols = clust.cols) 

dev.copy(pdf, "Clonotype_size_UMAP_split_cloneType_Clusters.pdf")
dev.off()

# Split by cloneType visualise clusters
UMAPPlot(seurat.tcr, 
         group.by = "Module", 
         split.by = "cloneType", 
         pt.size = 1,
         cols = module.cols) 

dev.copy(pdf, "Clonotype_size_UMAP_split_cloneType_Modules.pdf")
dev.off()

# Ensure dir back in working
setwd(working.dir)
```

## TCR analysis - cluster-specific clonotypes {.tabset}

### Get clonotypes function
```{r Get_clonotypes_function}

get.clonotypes <- function(input.seurat, identity.column, ident.id){
  
  # identitiy column = cluster or module 
  # ident.id = a specific module or cluster ID
  
  # This function identifies all clonotypes in a specified cluster/module subset and then pulls out all occurances of these clonotypes
  
  
  
  # set idents
  Idents(input.seurat) <- input.seurat@meta.data[ , paste0(identity.column)]
  
  # Subset by ident.id
  Ident.specific.seurat <- subset(input.seurat, idents = paste0(ident.id))
  
  # get list of clonotypes in selected cluster/module
  Ident.specific.clones <- sort(table(Ident.specific.seurat@meta.data$CTaa), decreasing = TRUE)
  
  # Find all cells that have these clonotypes
  keep.logic <- input.seurat@meta.data$CTaa %in% names(Ident.specific.clones)
  cells.with.ident.sp.clones <- rownames(input.seurat@meta.data)[keep.logic]
  
  # Subset seurat by these cell IDs
  seurat.ident.specific.clones <- subset(input.seurat, cells = cells.with.ident.sp.clones)
  
  
  return(seurat.ident.specific.clones)
  
}

```

## Reduce dataset to clonotypes per cluster
```{r Cluster_clonotypes}

# set working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output/figures/TCRseq/Cluster_clonotypes")){
  dir.create("output/figures/TCRseq/Cluster_clonotypes",
             recursive = T)}

output.dir <- "output/figures/TCRseq/Cluster_clonotypes"
setwd(output.dir)

##########################################################
# Keep only one occurrence of a clonotype in each cluster
##########################################################

uniq.clonotypes <- seurat.tcr@meta.data %>% 
  dplyr::distinct(seurat_clusters, CTaa) %>%
  rownames()

clust.clonotypes.seurat <- subset(seurat.tcr, cells = uniq.clonotypes)
#3773 clonotypes 

# Set Idents
Idents(clust.clonotypes.seurat) <- clust.clonotypes.seurat@meta.data$seurat_clusters

# Cluster Clonotypes
UMAPPlot(clust.clonotypes.seurat, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         cols = clust.cols) + 
  ggtitle("Pts = Cluster clonotypes")

dev.copy(pdf, "Cluster_clonotypes.pdf")
dev.off()

# Cluster Clonotypes // No legend
UMAPPlot(clust.clonotypes.seurat, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         label = TRUE,
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("Pts = Cluster clonotypes") + 
  NoLegend()

dev.copy(pdf, "Cluster_clonotypes_NoLegend.pdf")
dev.off()


# Plot number of clonotypes per cluster
x <- table(clust.clonotypes.seurat@meta.data$seurat_clusters)

barplot(x, 
        las = 2, 
        ylim = c(0, 1000), 
        ylab = "# of clonotypes",
        main = "# of clonotypes per cluster")

dev.copy(pdf, "Barplot_Num_Cluster_clonotypes.pdf")
dev.off()



############################################
# Scale pt size with clonotype frequency
############################################

Total.clonotype.scale <- clust.clonotypes.seurat@meta.data$Total_clonotype_scaled 

# Total dataset
UMAPPlot(clust.clonotypes.seurat, 
         pt.size = Total.clonotype.scale, 
         group.by = "seurat_clusters", 
         cols = clust.cols) + 
    ggtitle("Clonotypes - scaled by total occurrence")

dev.copy(pdf, "Cluster_clonotypes_scaled_by_occurrence.pdf")
dev.off()



# Total dataset // No legend
UMAPPlot(clust.clonotypes.seurat, 
         pt.size = Total.clonotype.scale, 
         group.by = "seurat_clusters", 
         label = TRUE, 
         label.size = 4,
         cols = clust.cols) + 
      ggtitle("Clonotypes - scaled by total occurrence") +
  NoLegend()

dev.copy(pdf, "Cluster_clonotypes_scaled_by_occurrence_Nolegend.pdf")
dev.off()


# Remove seurat
rm(clust.clonotypes.seurat)


# set working dir
setwd(working.dir)

```
 
## Reduce dataset to clonotypes per cluster per condition
```{r Cluster_condition_clonotypes}

# set working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output/figures/TCRseq/Cluster_condition_clonotypes")){
  dir.create("output/figures/TCRseq/Cluster_condition_clonotypes",
             recursive = T)}

output.dir <- "output/figures/TCRseq/Cluster_condition_clonotypes"
setwd(output.dir)


############################################################################
# Keep only one occurrence of a clonotype in each cluster per condition
############################################################################

uniq.clonotypes <- seurat.tcr@meta.data %>% 
  dplyr::distinct(seurat_clusters, CTaa, condition) %>%
  rownames()

clust.cond.clonotypes.seurat <- subset(seurat.tcr, cells = uniq.clonotypes)
# 4093 clonotypes

# Set Idents
Idents(clust.cond.clonotypes.seurat) <- clust.cond.clonotypes.seurat@meta.data$seurat_clusters


# Cluster & Condition clonotypes
UMAPPlot(clust.cond.clonotypes.seurat, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         cols = clust.cols) + 
  ggtitle("Pts = Cluster and condition clonotypes")

dev.copy(pdf, "Cluster_condition_clonotypes.pdf")
dev.off()

# Split by condition // no legend
UMAPPlot(clust.cond.clonotypes.seurat, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         label = TRUE, 
         label.size = 4,
         cols = clust.cols) + 
  ggtitle("Pts = Cluster and condition clonotypes") + 
  NoLegend()

dev.copy(pdf, "Cluster_condition_clonotypes_Nolegend.pdf")
dev.off()


# Barplot of # of unique clonotypes per clust per condition

x <- table(clust.cond.clonotypes.seurat@meta.data$seurat_clusters, clust.cond.clonotypes.seurat@meta.data$condition)


barplot(t(x),
        las = 2,
        beside = TRUE,
        col = Condition.cols,
        legend = TRUE,
        ylim = c(0, 600),
        ylab = "# of clonotypes", 
        main = "# of unique clonotypes per cluster per condition")

dev.copy(pdf, "Barplot_Num_Cluster_condition_clonotypes.pdf")
dev.off()


############################################
# Scale pt size with clonotype frequency
############################################

Condition.clonotype.scale <- clust.cond.clonotypes.seurat@meta.data$Clone_Clust_conditionwise_scaled 

# Split by condition
UMAPPlot(clust.cond.clonotypes.seurat, 
         pt.size = Condition.clonotype.scale, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         cols = clust.cols) + 
    ggtitle("Clust/Cond Clonotype - by normed condition freq")

dev.copy(pdf, "Cluster_condition_clonotypes_scaled_by_normalised_conditionwise_freq.pdf")
dev.off()


# Split by condition // No legend
UMAPPlot(clust.cond.clonotypes.seurat, 
         pt.size = Condition.clonotype.scale, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         label = TRUE, 
         label.size = 4,
         cols = clust.cols) + 
    ggtitle("Clust/Cond Clonotype - by normed condition freq") + 
  NoLegend()

dev.copy(pdf, "Cluster__condition_clonotypes_scaled_by_normalised_conditionwise_freq_Nolegend.pdf")
dev.off()


# set working dir
setwd(working.dir)

```
 
### Cluster-condition-specific clonotypes
```{r Cluster_condition_specific_clonotypes}

# Create output directories
setwd(working.dir)

if(!dir.exists("output/figures/TCRseq/Cluster_condition__specific_clonotypes")){
  dir.create("output/figures/TCRseq/Cluster_condition__specific_clonotypes",
             recursive = T)}

output.dir <- "output/figures/TCRseq/Cluster_condition__specific_clonotypes"
setwd(output.dir)


# Set Idents to Cluster ID
Idents(clust.cond.clonotypes.seurat) <- clust.cond.clonotypes.seurat@meta.data$seurat_clusters



# Get x and y lims for UMAP plots
z <- UMAPPlot(clust.cond.clonotypes.seurat, 
                 pt.size = 1,
                 group.by = "seurat_clusters",
                 split.by = "condition",
                 cols = clust.cols)

# extract x and y lims
umap.x.lim <- layer_scales(z)$x$range$range
umap.y.lim <- layer_scales(z)$y$range$range


###################################
# get Cluster specific clonotypes
###################################

Cluster.vect <- unique(clust.cond.clonotypes.seurat@meta.data$condition_clust)

for(i in 1:length(Cluster.vect)){
  
  print(paste0("Performing analysis for Cluster = ", Cluster.vect[i]))
  
  
  # Extract clonotypes found in a specific clust/condition
  clonotype.seurat <- get.clonotypes(clust.cond.clonotypes.seurat, "condition_clust", Cluster.vect[i])
  
  
  ########################
  # Visualisation 
  ########################
  
  # Overall distribution of clonotypes 
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = 1,
                 group.by = "seurat_clusters",
                 split.by = "condition",
                 cols = clust.cols) + 
          xlim(umap.x.lim) + ylim(umap.y.lim) + 
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  dev.copy(pdf, 
           paste0("Clonotypes_found_in_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Scale clonotype size
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = clonotype.seurat@meta.data$Clone_Clust_conditionwise_scaled,
                 group.by = "seurat_clusters", 
                 split.by = "condition",
                 cols = clust.cols) +
          xlim(umap.x.lim) + ylim(umap.y.lim) + 
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  dev.copy(pdf, 
           paste0("Clonotypes_found_in_", Cluster.vect[i], "_pt_scaled.pdf"))
  dev.off()
  

############
# Barplots
############
  
# Number of unique clones
n.clonotypes <- table(clonotype.seurat@meta.data$seurat_clusters)

print(barplot(n.clonotypes, 
              ylim = c(0, 1000),
              ylab = "# of clonotypes",
              main = paste0("# clonotypes found in Cluster ", Cluster.vect[i]), 
              cex.names = 0.7, 
              las = 2))   

  dev.copy(pdf, 
           paste0("Barplot_of_clonotypes_found_in_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Freq of clone overlap
  n.clonotypes <- table(clonotype.seurat@meta.data$seurat_clusters, clonotype.seurat@meta.data$condition)
  total.n.clonotypes <- table(clust.cond.clonotypes.seurat@meta.data$seurat_clusters, clust.cond.clonotypes.seurat@meta.data$condition)
  
  x <- (n.clonotypes/total.n.clonotypes)*100
  
  print(barplot(t(x), 
                ylim = c(0, 100),
                ylab = "% of clonotype overlap",
                main = paste0("% of clonotypes present in ", Cluster.vect[i]), 
                cex.names = 0.9, 
                col = Condition.cols,
                legend = TRUE,
                beside = TRUE,
                las = 2))   
  
  dev.copy(pdf, paste0("Barplot_freq_of_clonotypes_found_in_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Remove unneeded variable
  rm(clonotype.seurat)
}


setwd(working.dir)


  
  
```

### Venn overlap of clonotypes
```{r Unique_shared_clonotypes_Venn}

# Create output directories
setwd(working.dir)

if(!dir.exists("output/figures/TCRseq/Venn_overlap")){
  dir.create("output/figures/TCRseq/Venn_overlap",
             recursive = T)}

output.dir <- "output/figures/TCRseq/Venn_overlap"
setwd(output.dir)

# Load package
library("RVenn")

####################################
# Overlap of all clonotypes
####################################

# Get vector of clonotypes found in US cells
US.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "US") %>%
  dplyr::select(CTaa)

US.clonotypes <- unique(US.clonotypes$CTaa)

length(US.clonotypes) # 1,845 clonotypes

# Get vector of clonotypes found in US cells
Stim.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "Stim") %>%
  dplyr::select(CTaa)

Stim.clonotypes <- unique(Stim.clonotypes$CTaa)

length(Stim.clonotypes) # 1,754 clonotypes

# Venn clonotypes

clonotype.list <- list(US = US.clonotypes, 
                       Stim = Stim.clonotypes)

clonotype.list <- Venn(clonotype.list)


ggvenn(clonotype.list,
       fill = rev(Condition.cols),
       thickness = 0) + 
  ggtitle("All Clonotypes") 

dev.copy(pdf, "Venn_overlap_All_clonotypes.pdf")
dev.off()

# Extract vectors
shared.clonotypes <- overlap(clonotype.list)
unique.US <- discern(clonotype.list, "US")
unique.Stim <- discern(clonotype.list, "Stim")

####################
# Add to metadata
####################
meta.data.vec <- seurat.tcr@meta.data %>%
  dplyr::mutate(Clonotype_overlap = case_when(CTaa %in% shared.clonotypes ~ "Shared", 
                                              CTaa %in% unique.US ~ "US", 
                                              CTaa %in% unique.Stim ~ "Stim")) %>%
  dplyr::select(Clonotype_overlap)


seurat.tcr <- AddMetaData(seurat.tcr, meta.data.vec$Clonotype_overlap, "Clonotype_overlap")


###########################
# Abundant clonotypes only
###########################

condition.min <- 20

# Get vector of clonotypes found in US cells
US.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "US" & Clone_conditionwise_n >= condition.min) %>%
  dplyr::select(CTaa)

US.clonotypes <- unique(US.clonotypes$CTaa)

length(US.clonotypes) #

# Get vector of clonotypes found in US cells
Stim.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "Stim" & Clone_conditionwise_n >= condition.min) %>%
  dplyr::select(CTaa)

Stim.clonotypes <- unique(Stim.clonotypes$CTaa)

length(Stim.clonotypes) #

# Venn overlap
clonotype.list <- list(US = US.clonotypes, 
                       Stim = Stim.clonotypes)

clonotype.list <- Venn(clonotype.list)

ggvenn(clonotype.list,
       fill = rev(Condition.cols),
       thickness = 0) + 
  ggtitle("Abundant clonotypes") 

dev.copy(pdf, "Venn_overlap_abundant_clonotypes.pdf")
dev.off()


################
# Singletons
################

# Get vector of clonotypes found in US cells
US.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "US" & Clone_conditionwise_n == 1) %>%
  dplyr::select(CTaa)

US.clonotypes <- unique(US.clonotypes$CTaa)

length(US.clonotypes)

# Get vector of clonotypes found in US cells
Stim.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "Stim" & Clone_conditionwise_n == 1) %>%
  dplyr::select(CTaa)

Stim.clonotypes <- unique(Stim.clonotypes$CTaa)

length(Stim.clonotypes)

# Venn overlap
clonotype.list <- list(US = US.clonotypes, 
                       Stim = Stim.clonotypes)

clonotype.list <- Venn(clonotype.list)

ggvenn(clonotype.list,
       fill = rev(Condition.cols),
       thickness = 0) + 
  ggtitle("Singletons") 

dev.copy(pdf, "Venn_overlap_singleton_clonotypes.pdf")
dev.off()


##############################################
# Low abundance in US and abundant in Stim
##############################################

# Get vector of clonotypes found in US cells
US.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "US" & Clone_conditionwise_n <= 5) %>%
  dplyr::select(CTaa)

US.clonotypes <- unique(US.clonotypes$CTaa)

length(US.clonotypes)

# Get vector of clonotypes found in US cells
Stim.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "Stim" & Clone_conditionwise_n >= 30) %>%
  dplyr::select(CTaa)

Stim.clonotypes <- unique(Stim.clonotypes$CTaa)

length(Stim.clonotypes)

# Venn overlap 
clonotype.list <- list(US = US.clonotypes, 
                       Stim = Stim.clonotypes)

clonotype.list <- Venn(clonotype.list)

ggvenn(clonotype.list,
       fill = rev(Condition.cols),
       thickness = 0) + 
  ggtitle("US <= 5 and Stim >= 30") 

dev.copy(pdf, "Venn_overlap_low_US_high_Stim_abundance_clonotypes.pdf")
dev.off()

```
 
 
 
 
 
 
 
 
 
 
 ### TO DO ###########
 # scclusteval - to determine stability of identified clusters
 # VDJdb epitope prediction for clonotypes
 # group clonotypes by Gliph cluster 
 # Vis/analyse epitope and Gliph cluster data
 # SENIC analysis of Transcription factor regulon activity in clusters
 # Data-mining for Type I IFN clusters in HNSCC and other cancer datasets
 
 
 
 
 
 ##### WORK in progress
### Dotplot of shared and unique clonotypes
```{r}


# Plot dotplot 
colnames(seurat.tcr@meta.data)

clonotype.var <- unique(clust.cond.clonotypes.seurat@meta.data$CTaa)

temp <- clust.cond.clonotypes.seurat@meta.data$CTaa



clonotype.out <- as.data.frame(matrix(ncol = 3, nrow = length(clonotype.var)))

colnames(clonotype.out) <- c("CTaa", "US_n", "Stim_n")
clonotype.out$CTaa <- clonotype.var



library(tidyr)

# The arguments to spread():
# - data: Data object
# - key: Name of column containing the new column names
# - value: Name of column containing values
data_wide <- spread(temp.data, condition, Clone_conditionwise_n)
data_wide


#876, 1703

temp.data[c(876,1703), ]









which(clust.cond.clonotypes.seurat$CTaa == clonotype.var[i])



temp.data <- clust.cond.clonotypes.seurat@meta.data %>%
  dplyr::select(CTaa, condition, Clone_conditionwise_n)



shared.clonotypes















test.df <- as.data.frame(matrix(ncol = 3, nrow = 5))
colnames(test.df) <- c("CTaa", "US_n", "Stim_n")
test.df[,1] <- paste0("Clone_", 1:5)
test.df[,2] <- c(1,0,5,0,10)
test.df[,3] <- c(7,10,0,8,7)

melt(test.df)


ggplot(melt(test.df), aes())

plot(test.df$US_n, test.df$Stim_n)

ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, color=Species)) + 
    geom_point(size=6) 


x <- melt(temp.data, id.vars = "condition")


?melt



```
 
 
 
 
 

 
 
 
```{r}


























clust.cond.clonotypes.seurat <- highlightClonotypes(clust.cond.clonotypes.seurat, 
                                                    cloneCall= "aa", 
                                                    sequence = "CADDRGSTLGRLYF_CASSHETSLQRYEQYF")
  
  
  
  
  
DimPlot(clust.cond.clonotypes.seurat, 
          group.by = "highlight", 
          #cols = c("red"),
          split.by = "condition",
          pt.size = clust.cond.clonotypes.seurat$Clone_Clust_conditionwise_scaled) 











# Make dotplot of clonotypes in US vs Stim 










```



 ### WORKING ON THIS CHUNK #####
 
### Clonotype tracking UMAP
```{r Clonotype_Tracking}

# set working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output/figures/TCRseq/Clonotype_Tracking_UMAPs")){
  dir.create("output/figures/TCRseq/Clonotype_Tracking_UMAPs",
             recursive = T)}

output.dir <- "output/figures/TCRseq/Clonotype_Tracking_UMAPs"
setwd(output.dir)



# Set Idents
Idents(clust.cond.clonotypes.seurat) <- clust.cond.clonotypes.seurat@meta.data$seurat_clusters

clust.cond.clonotypes.seurat # 4,093 clonotypes in dataset




# Set scale for plotting
Condition.clonotype.scale <- clust.cond.clonotypes.seurat@meta.data$Clone_Clust_conditionwise_scaled 


clonotype.abundance <- sort(table(seurat.tcr@meta.data$CTaa), decreasing = TRUE)

length(clonotype.abundance) # 3,144

# Plot top 10 clonotypes 

clonotype <- names(clonotype.abundance)[1:10]



for(i in 1:length(clonotype)){
  
  
  # Highlight clonotype
  clust.cond.clonotypes.seurat <- highlightClonotypes(clust.cond.clonotypes.seurat, 
                                                    cloneCall= "aa", 
                                                    sequence = clonotype[i])
  
  
  
  
  
  print(DimPlot(clust.cond.clonotypes.seurat, 
          group.by = "highlight", 
          #cols = c("red"),
          split.by = "condition",
          pt.size = Condition.clonotype.scale) + 
    ggtitle(clonotype[i]) +
    NoLegend())

  dev.copy(pdf, paste0("Top_", i, "_Clonotype_", clonotype[i], ".pdf"))
  dev.off()
  
}



temp <- clust.cond.clonotypes.seurat



temp.var <- clust.cond.clonotypes.seurat@meta.data %>% 
  dplyr::mutate(shape_highlight = case_when(highlight == "Clonotype1" ~ 19, 
                                          is.na(highlight) ~ 8)) %>%
  dplyr::select(shape_highlight)


temp@meta.data$highlight_shape <- temp.var[,1]

temp@meta.data$highlight_shape <- as.factor(temp@meta.data$highlight_shape)

DimPlot(temp, 
          group.by = "seurat_clusters", 
        shape.by = "highlight_shape",
          #cols = c("red"),
          split.by = "condition",
          pt.size = Condition.clonotype.scale)






clust.cond.clonotypes.seurat@meta.data$seurat_clusters


clust.cond.clonotypes.seurat@meta.data %>% 
  dplyr::filter(highlight == "Clonotype1")




sum(table(seurat.tcr@meta.data$CTaa) >= 5)



quantile(table(seurat.tcr@meta.data$CTaa), c(0, 0.1, .20, .30, .4, .5, .6, .7, .8, .9, .93, .95))







# set working dir
setwd(working.dir)
```


## TO DO: 
### Alluvial plot of top X clones in y clusters in US vs Stim 
### Circos plots for each cluster showing US vs stim clonotype distribution 



  ################################
  # TO DO 
  #################################
  # Normalise freq by cell number per condition 
  # Calculate total freq (not freq per condition) - change plots to show total freq 
  # track cytotoxic clonotypes - are they converting 
  # get US specific clones and plot 
  # get Stim specific clones 
  # get US/Stim unique clones 
  # Are clones lost or transition ? 
  # Compare no-TCR cells - are clones lost or down-regulate TCR? 
  # Do type1 or Cyto clusters transition to exhausted
  # exhausted 1 vs exhausted 2
  


 ### Cluster-specific & condition-specific clonotypes 
 
 ### Shared clonotypes 
 
 ### Distinct clonotypes 
 
 ### DEG Exh clonotypes 
 
 ### Overlay expression on clonotypes 
 
 ### track/plot top clonotypes 
 
 ### Fix scaling to be by cluster/condition specific 
 
 ### shape by cluster for clonotype tracking plots 
 
```{r track_umap_clonotypes_top}


# Get data of how many cells in each cluster are assigned to what clonotypes
clonotype.data <- table(seurat.tcr@meta.data$CTaa, seurat.tcr@meta.data$seurat_clusters)

head(sort(rowSums(clonotype.data), decreasing = TRUE))

keep.vec <- rownames(clonotype.data) %in% names(aa.keep)

plot.data <- clonotype.data[keep.vec, ]





plot.scale <- clust.cond.clonotypes.seurat@meta.data$Clonotype_freq_per_condition_scaled 






seurat.tcr <- highlightClonotypes(seurat.tcr, 
                                  cloneCall= "aa", 
                                  sequence = c("CVVTSPMDSNYQLIW_CASSSRPTGTGELFF"))



DimPlot(seurat.tcr,
        group.by = "highlight", 
        split.by = "condition",
        pt.size = 2)





clust.cond.clonotypes.seurat <- highlightClonotypes(clust.cond.clonotypes.seurat, cloneCall= "aa", 
                                  sequence = c("CAMFTGNQFYF_CASREGNSPLHF"))



DimPlot(clust.cond.clonotypes.seurat, 
        group.by = "highlight", 
        cols = c("red"),
        #na.value = "white",
                split.by = "condition",
        pt.size = plot.scale)



# VALIDATE PLOTTING IS SCALLING RIGHHT _ ESPECIALLY AFTER SPLIT - find a large clonotype and a small clonotype.




clust.cond.clonotypes.seurat@meta.data %>% 
  dplyr::filter(highlight == "Clonotype1")

```
 

 
 


 ## TCR analysis - Unique and shared clonotypes (US vs. Stim) {.tabset}






















### TCR analysis variable set up
```{r TCR_analysis_setup}

# Create output directories
if(!dir.exists("output/figures/TCRseq")){
  dir.create("output/figures/TCRseq",
             recursive = T)}

# Set up ident
Idents(seurat.combined) <- seurat.combined@meta.data$condition_clust

# General stats on dataset

# Note that vars clonotype_id_A and id_B are identical 
NoClone.N <- sum(is.na(seurat.combined@meta.data$clonotype_id_A))
print(paste0(NoClone.N, " cells have no clonotype identified")) # 4,918

Cell.N <- nrow(seurat.combined@meta.data)
print(paste0("This represents ", signif(NoClone.N/Cell.N * 100), " % of the dataset")) # 41.58% of the data has no clonotype info

# therefore number of cells with a combined alpha/beta tcr call is 
Clone.N <- sum(!is.na(seurat.combined@meta.data$clonotype_id_B))
print(paste0(Clone.N, " cells have complete clonotype identified")) # 6,909

print(paste0("This represents ", signif(Clone.N/Cell.N * 100), " % of the dataset")) # 58.41% of the data has an alpha/beta pair



#################################################################################
# Generate a seurat object for just the cells with a called TCR
#################################################################################
Cells.with.TCR <- rownames(seurat.combined@meta.data[!is.na(seurat.combined@meta.data$clonotype_id_A), ])
seurat.tcr <- subset(seurat.combined, cells = Cells.with.TCR)
seurat.tcr

# Extract metadata for analysis
seurat.tcr.metadata <- seurat.tcr@meta.data

# Generate table number of cells for each clonotype - note clonotype_id_A and B are equiv
All.clonotypes <- sort(table(seurat.tcr.metadata$clonotype_id_A), decreasing = TRUE)
head(All.clonotypes, 20)

#############################################
# Filter out low abundance clonotypes
#############################################

# filt out low clonal clonotypes 
# i.e those expressed in fewer than 3 cells in entire dataset 

clonal.min <- 3

logic.vec <- All.clonotypes < clonal.min
low.n <- sum(logic.vec) # 3,519 clones 
total.n <- length(logic.vec) # 3,918 clones in total 

# Filtering stats
# freq of clones found in < clonal.min cells is
print(paste0("Freq of clones that have < ", clonal.min, " cells = ", signif(low.n/total.n*100, 4), "%"))
print(paste0("Number of clones occur in > than ", clonal.min, " cells = ", sum(!logic.vec)))

# Filter data
clonotypes.keep <- names(All.clonotypes)[!logic.vec]

Idents(seurat.tcr) <- seurat.tcr@meta.data$clonotype_id_A
seurat.tcr <- subset(seurat.tcr, idents = clonotypes.keep)

length(levels((Idents(seurat.tcr)))) # should equal number of clonotypes selected for 

# Reset Ident
Idents(seurat.tcr) <- seurat.tcr@meta.data$condition_clust


```


### WORK IN PROGRESS 
```{r}



# Vis clonotype size on UMAP
UMAPPlot(seurat.tcr, 
         group.by = "cloneType", 
         pt.size = 1) +
  scale_color_manual(values = clonetype.col, 
                     na.value="grey")












freq.val <- seurat.tcr@meta.data$umis_B


UMAPPlot(seurat.tcr, 
         pt.size = (freq.val/10),
         group.by = "seurat_clusters", 
         split.by = "condition")  





UMAPPlot(seurat.tcr, 
         pt.size = (freq.val/5) + 0.5,
         group.by = "seurat_clusters", 
         split.by = "cloneType")  


?scale

scale_size_manual(values = as.factor(freq.val), limits = 10)



UMAPPlot(seurat.tcr, 
         pt.size = freq.val,
         group.by = "seurat_clusters", 
         split.by = "condition", 
         cols = clust.cols)  



UMAPPlot(seurat.tcr, 
         pt.size = 1,
         group.by = "seurat_clusters", 
         label= T,
         cols = clust.cols)  


UMAPPlot(seurat.tcr, 
         pt.size = 1,
         group.by = "Module", 
         label = T, 
         cols = module.cols)








14-8

temp <- seurat.tcr@meta.data[1:50, ]


scale_size(range = freq.val) + 
  guides(color= guide_legend(), size=guide_legend())

scale_size_continuous()

head(temp)


?scale_size_continuous

#S1_clonotype4
#CAMREGRINYGQNFVF_CSARDEEGGYTF

seurat.tcr@meta.data %>% 
  dplyr::filter(CTaa == "CAMREGRINYGQNFVF_CSARDEEGGYTF" & condition == "US")-> temp 



dim(temp)


```


### WORK progress
```{r tcr_analysis_work_in_progress}


?FeaturePlot







VlnPlot(seurat.tcr, "Frequency", pt.size = 0.1, group.by = "Module")


UMAPPlot(seurat.tcr, 
         group.by = "cloneType", 
         split.by = "condition", 
         pt.size = 1) +
  scale_color_manual(values = c(rev(colorblind_vector(5))), 
                     na.value="grey")


UMAPPlot(seurat.tcr, 
         group.by = "condition", 
         split.by = "cloneType", 
         pt.size = 1)# +
scale_color_manual(values = c(rev(colorblind_vector(5))), 
                   na.value="grey")




t_col <- function(color, percent = 50, name = NULL) {
  #      color = color name
  #    percent = % transparency
  #       name = an optional name for the color
  
  ## Get RGB values for named color
  rgb.val <- col2rgb(color)
  
  ## Make new color using input color as base and alpha set by transparency
  t.col <- rgb(rgb.val[1], rgb.val[2], rgb.val[3],
               max = 255,
               alpha = (100 - percent) * 255 / 100,
               names = name)
  
  ## Save the color
  invisible(t.col)
}


transparent <- t_col("blue", perc = 100, name = "transparent.blue")





p1 <- UMAPPlot(seurat.tcr, 
               label = TRUE,
               group.by = "seurat_clusters") + NoLegend()

p2 <- UMAPPlot(seurat.tcr, 
               label = TRUE, 
               group.by = "Module") + NoLegend()



p1




seurat.tcr@meta.data




table <- table(seurat.tcr$condition, seurat.tcr$seurat_clusters)
table[1,] <- table[1,]/sum(table[1,]) # Scaling by the total number of US
table[2,] <- table[2,]/sum(table[2,]) # Scaling by the total number of Stim
table <- as.data.frame(table)
table$Var2 <- factor(table$Var2)

ggplot(table, aes(x=Var2, y=Freq, fill=Var1)) + 
  geom_bar(stat="identity", position="fill", color="black", lwd=0.25) + 
  theme(axis.title.x = element_blank()) + 
  scale_fill_manual(values = c("#FF4B20","#0348A6")) + 
  theme_classic() + 
  theme(axis.title = element_blank(), axis.text.x = element_text(angle = 90))



colorblind_vector <- colorRampPalette(c("#FF4B20", "#FFB433", "#C6FDEC", "#7AC5FF", "#0348A6"))

slot(seurat.tcr, "meta.data")$cloneType <- factor(slot(seurat.tcr, "meta.data")$cloneType, 
                                                  levels = c("Hyperexpanded (100 < X <= 500)", "Large (20 < X <= 100)", 
                                                             "Medium (5 < X <= 20)", "Small (1 < X <= 5)", 
                                                             "Single (0 < X <= 1)", NA))

p3 <- UMAPPlot(seurat.tcr, 
               group.by = "cloneType", 
               split.by = "condition", 
               pt.size = 1) +
  scale_color_manual(values = c(rev(colorblind_vector(5))), 
                     na.value="grey")



cloneType.col <- c(rev(colorblind_vector(5)))

Idents(seurat.tcr) <- seurat.tcr@meta.data$seurat_clusters

temp.seurat <- subset(seurat.tcr, idents = "TRM") 


p3 <- UMAPPlot(seurat.tcr, 
               group.by = "seurat_clusters",
               split.by = "cloneType",
               label = FALSE,
               #cols = cloneType.col,
               pt.size = 1) + NoLegend()


p4 <- UMAPPlot(seurat.tcr, 
               group.by = "Module",
               split.by = "cloneType",
               label = FALSE,
               #cols = cloneType.col,
               pt.size = 1) + NoLegend()


p5 <- UMAPPlot(seurat.tcr, 
               group.by = "cloneType",
               label = FALSE,
               cols = cloneType.col,
               pt.size = 1) + NoLegend()

p6 <- UMAPPlot(seurat.tcr, 
               group.by = "seurat_clusters",
               split.by = "condition",
               label = FALSE,
               #cols = cloneType.col,
               pt.size = 1) + NoLegend()


(p1+p6)/p3



#+
#   scale_color_manual(values = c(rev(colorblind_vector(5))), 
#                     na.value="grey")




p1/p3
seurat.tcr@meta.data



Idents(seurat.tcr) <- seurat.tcr@meta.data$seurat_clusters

meta <- data.frame(seurat.tcr[[]], Idents(seurat.tcr)) 
ggplot(meta, aes(x=Idents.seurat.tcr., y=Frequency)) + 
  geom_boxplot(outlier.alpha = 0.5, aes(fill=Idents.seurat.tcr.)) + 
  guides(fill=FALSE) + 
  theme_classic() + 
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 90))


head(unique(seurat.tcr@meta.data$CTaa[order(seurat.tcr@meta.data$Frequency, decreasing = T)]))

seurat.tcr <- highlightClonotypes(seurat.tcr, cloneCall= "aa", 
                                  sequence = c("CAMFTGNQFYF_CASREGNSPLHF", "CAVRDLAGNMLTF_CASSLSPGQGHYEQYF", "CVVTSPMDSNYQLIW_CASSSRPTGTGELFF"))
DimPlot(seurat.tcr, group.by = "highlight", pt.size = 1, split.by = "condition")







alluvialClonotypes(seurat.tcr, cloneCall = "aa", 
                   y.axes = c("group", "seurat_clusters", "condition"), 
                   color = c("CAVRDLAGNMLTF_CASSLSPGQGHYEQYF", "CVVTSPMDSNYQLIW_CASSSRPTGTGELFF")) + 
  scale_fill_manual(values = c("grey", colorblind_vector(1)))

head(unique(seurat.tcr@meta.data$CTaa[order(seurat.tcr@meta.data$Frequency, decreasing = T)]))


alluvialClonotypes(seurat.tcr, 
                   cloneCall = "aa", 
                   y.axes = c("group", "seurat_clusters", "condition"), 
                   color = "condition") 






```



## Misc analysis {.tabset}

### Analysis with Augur 
```{r Augur_Analysis, echo = TRUE, eval = FALSE}

if(long.compute){
  
  # Install packages required
  
  #devtools::install_github("const-ae/sparseMatrixStats")
  #devtools::install_github("neurorestore/Augur")
  #install.packages("glmnet")
  
  
  ####################################  
  # Run Augur analysis on clusters
  ####################################  
  
  # Metadata info 
  metadata.df <- seurat.combined@meta.data
  
  # see which cols to keep
  colnames(metadata.df)
  
  # Select just cluster and condition cols 
  metadata.df <- metadata.df %>%
    dplyr::select(seurat_clusters, condition)
  
  # Name cols for input into augur function
  colnames(metadata.df) <- c("cell_type", "label")
  
  # output expression dataset
  normed.df <- seurat.combined@assays$RNA@data
  
  # Run Augur analysis // ~45 min compute time
  augur.out <- Augur::calculate_auc(normed.df,
                                    metadata.df, 
                                    n_threads = 8)
  
  # Output is stored in AUC slot 
  augur.out$AUC
  
  # Save RDS file
  saveRDS(augur.out, "Exported_RDS_files/Augur_output_clusters.rds")
  rm(augur.out)
  
  
  
  ###################################
  # Run Augur analysis on modules
  ###################################
  
  # Metadata info 
  metadata.df <- seurat.combined@meta.data
  
  # see which cols to keep
  colnames(metadata.df)
  
  # Select just cluster and condition cols 
  metadata.df <- metadata.df %>%
    dplyr::select(Module, condition)
  
  # Name cols for input into augur function
  colnames(metadata.df) <- c("cell_type", "label")
  
  
  # output expression dataset
  normed.df <- seurat.combined@assays$RNA@data
  
  # Run Augur analysis // ~10 min compute time
  augur.out <- Augur::calculate_auc(normed.df,
                                    metadata.df, 
                                    n_threads = 8)
  
  # Output is stored in AUC slot 
  augur.out$AUC
  
  # Save RDS file
  saveRDS(augur.out, "Exported_RDS_files/Augur_output_module.rds")
  rm(augur.out)
  
}

```



## SCENIC TF analysis {.tabset}

### SCENIC transcription factor analysis 

```{r SCENIC_analysis}

# SCENIC analysis performed using python script as this is considerably faster then R based analysis

# Analysis performed as outlined in Sande et al., 2020 Nature Protocols manuscript

# Input into SCENIC analysis is a .loom file 

# Export seurat object as Loom file

# Generate loom file for SCENIC analysis 

#devtools::install_github(repo = "hhoeflin/hdf5r", force = TRUE)
#devtools::install_github(repo = "mojaveazure/loomR", ref = "develop")

library(loomR)

library(SCENIC)
library(SCopeLoomR)

pyScenicLoomFile <- file.path("../Additional_Analysis/Velocity_loom/GEX1_20200121_BaldNextSeq_CountsOnly.loom")
loom <- open_loom(pyScenicLoomFile, mode="r")




Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

DefaultAssay(seurat.combined) <- "RNA"


as.loom(seurat.combined, 
        assay = "RNA",
        filename = "seurat_combined.loom",
        overwrite = FALSE,
        verbose = TRUE)

dim(seurat.combined@assays$RNA)


lfile <- connect(filename = "seurat_combined.loom", mode = "r+")

lfile[["matrix"]]

lfile$close_all()




```






























## Trajectory analysis {.tabset}


### Destiny pseudotime analysis
```{r destiny_pseudotime}

#BiocManager::install("destiny")


```




## Need to amend root node settings etc 

### Preparing data for trajectory analysis
```{r Trajectory_data_prep, eval = TRUE}

library(dyno)
library(dynplot)
library(dynmethods)
library(dynutils)
library(dynwrap)
library(tidyverse)
dynwrap::test_docker_installation(detailed = TRUE)

############################
# Read in and prepare data
############################

# Read in dataframes
raw.data <- as.data.frame(seurat.combined@assays$RNA@counts)
normed.data <- as.data.frame(seurat.combined@assays$RNA@data)


# data is organized cols = cells and rows = genes
head(raw.data[1:10, 1:10])
head(normed.data[1:10, 1:10])

# Need to inverse data for input into dyno package
raw.data <- t(raw.data)
head(raw.data[1:10, 1:10])

normed.data <- t(normed.data)
head(normed.data[1:10, 1:10])

# Check data structure
dim(raw.data) # 11,658 cells and 16,295 genes
dim(normed.data) # 11,658 cells and 16,295 genes


if(long.compute){  
  ##########################################
  # Creating Dyno formatted data structure
  ##########################################
  
  Dyno.data <- wrap_expression(counts = raw.data,
                               expression = normed.data)
  
  # Add grouping info
  metadata.df <- seurat.combined@meta.data
  
  group.vect <- metadata.df$seurat_clusters
  names(group.vect) <- rownames(metadata.df)
  
  Dyno.data <- add_grouping(Dyno.data,
                            grouping = group.vect)
  
  
  # Add dim reduction
  logic.vect <- grepl("*UMAP", colnames(metadata.df))
  
  UMAP.dims <- metadata.df[ , logic.vect]
  UMAP.dims <- as.matrix(UMAP.dims)
  
  Dyno.data <- add_dimred(Dyno.data,
                          dimred = UMAP.dims)
  
  
  
}else{
  
  
  
  # Create vectors and matrix needed for visualisation of pre-calculated trajectories
  
  # Create grouping vector
  metadata.df <- seurat.combined@meta.data
  
  group.vect <- metadata.df$seurat_clusters
  names(group.vect) <- rownames(metadata.df)
  
  # Create dim reduction matrix
  logic.vect <- grepl("*UMAP", colnames(metadata.df))
  
  UMAP.dims <- metadata.df[ , logic.vect]
  UMAP.dims <- as.matrix(UMAP.dims)
  
  
}




```

### Running trajectory analysis
```{r trajectory_analysis, eval = FALSE}

if(long.compute){
  
  
  
  ################################################
  # selecting best trajectory method for dataset
  ################################################
  # Using shiny app to get guidelines
  # guidelines <- guidelines_shiny(Dyno.total.data)
  
  
  answers <- dynguidelines::answer_questions(multiple_disconnected = NULL, 
                                             expect_topology = NULL, 
                                             expected_topology = NULL, 
                                             n_cells = 11658, 
                                             n_features = 16295, 
                                             memory = "16GB", 
                                             prior_information = NULL, 
                                             docker = TRUE)
  
  guidelines.vals <- dynguidelines::guidelines(answers = answers) 
  
  methods.selected <- guidelines.vals$methods_selected
  
  print(methods.selected)
  
  
  #####################
  # Infer Trajectory
  #####################
  
  ##############
  # Slingshot
  ##############
  
  slingshot <- infer_trajectory(Dyno.data, 
                                method = "dynverse/ti_slingshot:v0.9.9.01", 
                                parameters = NULL, 
                                give_priors = NULL, 
                                seed = set.seed(42),
                                verbose = TRUE)
  
  saveRDS(slingshot, file = "Exported_RDS_files/combined_slingshot.rds")
  rm(slingshot)
  
  
  ##############
  # Scorpius
  ##############
  
  scorpius <- infer_trajectory(Dyno.data, 
                               method = ti_scorpius(), 
                               parameters = NULL, 
                               give_priors = NULL, 
                               seed = set.seed(42),
                               verbose = TRUE)
  
  saveRDS(scorpius, file = "Exported_RDS_files/combined_scorpius.rds")
  rm(scorpius)
  
  
  ##############
  # Angle
  ##############
  
  angle <- infer_trajectory(Dyno.data, 
                            method = ti_angle(), 
                            parameters = NULL, 
                            give_priors = NULL, 
                            seed = set.seed(42),
                            verbose = TRUE)
  
  saveRDS(angle, file = "Exported_RDS_files/combined_angle.rds")
  rm(angle)
  
}


```

### Visualisation trajectory analysis
```{r Visualisation_trajectory, eval = TRUE}

####################################
# Visualise exported trajectories 
####################################


# Create output directory
if(!dir.exists("output/figures/Trajectories")){
  dir.create("output/figures/Trajectories",
             recursive = T)}



###############
# Slingshot
###############

# Create output directory
if(!dir.exists("output/figures/Trajectories/Slingshot")){
  dir.create("output/figures/Trajectories/Slingshot",
             recursive = T)}


# Read data
slingshot <- readRDS("Exported_RDS_files/combined_slingshot.rds")

# Modify variables

# Set root milestone
#slingshot <- add_root(trajectory = slingshot, 
#                        root_milestone_id = "4")

dynplot::plot_dimred(slingshot, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     label_milestones = TRUE,
                     color_cells = "pseudotime")

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_plot_pseudotime.pdf")
dev.off()


dynplot::plot_dimred(slingshot, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     grouping = group.vect,
                     label_milestones = TRUE,
                     color_cells = "grouping")

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_plot_clusters.pdf")
dev.off()


# Rename milestone labels
#milestone.labels <- c("Naive_memory", "Exhausted", "Activated", "Stem-like")
#names(milestone.labels) <- c(1, 2, 3, 4)

#slingshot <- label_milestones(slingshot, 
#                                 labelling = milestone.labels)

dynplot::plot_dimred(slingshot, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     grouping = group.vect,
                     label_milestones = TRUE,
                     color_cells = "grouping")


# Cacluate trajectory feature importance

overall_feature_importances <- dynfeature::calculate_overall_feature_importance(slingshot, 
                                                                                expression_source = normed.data)

top.features <- overall_feature_importances %>% 
  top_n(50, importance) %>% 
  pull(feature_id)


plot_heatmap(slingshot, 
             expression_source = normed.data, 
             features_oi = top.features)

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_heatmap_top50_important_features.pdf")
dev.off()


# Calculate milestone importance
for(i in 1:length(slingshot$milestone_ids)){
  
  # Because milestone ids are not in order get the corresponding ID name for each milestone #
  logic.var <- names(slingshot$milestone_labelling) == i
  milestone.name <- paste0(slingshot$milestone_labelling[logic.var])
  
  
  milestone.feature.importance <- calculate_milestone_feature_importance(slingshot,
                                                                         expression_source = normed.data, 
                                                                         milestones_oi = i, 
                                                                         verbose = TRUE)
  
  
  top.features <- milestone.feature.importance %>% 
    top_n(25, importance) %>% 
    pull(feature_id)
  
  print(plot_heatmap(slingshot, 
                     expression_source = normed.data, 
                     features_oi = top.features))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Slingshot/Combined_heatmap_top25_milestone_", milestone.name, "_important_features.pdf"))
  dev.off()
  
  
}



################################################
# Base plots of other trajectories calculated
################################################


# Generate list of exported trajectories 
trajectories_master <- list.files("Exported_RDS_files/", ".rds")

print(trajectories_master)

for(i in 1:length(trajectories_master)){
  
  print(paste0("Plotting ", trajectories_master[i]))
  
  trajectory.val <- readRDS(paste0("Exported_RDS_files/", trajectories_master[i]))
  trajectory.name <- gsub(".rds", "", trajectories_master[i])
  
  
  #####################
  # Plot trajectory
  #####################
  
  # Vis pseudotime
  print(dynplot::plot_dimred(trajectory.val, 
                             dimred = UMAP.dims,
                             hex_cells = TRUE, 
                             label_milestones = TRUE,
                             color_cells = "pseudotime"))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Pseudotime_", trajectory.name, ".pdf"))
  dev.off()
  
  # Overlay clusters
  print(dynplot::plot_dimred(trajectory.val, 
                             dimred = UMAP.dims,
                             hex_cells = TRUE, 
                             grouping = group.vect,
                             label_milestones = TRUE,
                             color_cells = "grouping"))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Clusters_", trajectory.name, ".pdf"))
  dev.off()
  
  # Group clusters
  print(dynplot::plot_dimred(trajectory.val, 
                             color_cells = "grouping",
                             color_density = "grouping",
                             dimred = UMAP.dims,
                             hex_cells = TRUE,
                             grouping = group.vect))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Clusters_grouped_", trajectory.name, ".pdf"))
  dev.off()
  
}


rm(trajectory.val)




```








### Load Seurat Wrapper
```{r Seurat_Wrapper}

# Package fails to load - use this trick to get tools of the package 
devtools::load_all("~/Documents/Work/Sciebo/Scripts/seurat-wrappers-master/")



```

### Monocle trajectory
```{r Monocle_analysis}

library("monocle")


DefaultAssay(seurat.combined) <- "integrated"

cds <- SeuratWrappers::as.cell_data_set(seurat.combined, group.by = "seurat_clusters")
cds <- monocle3::cluster_cells(cds)


p1 <- monocle3::plot_cells(cds, show_trajectory_graph = FALSE)
p2 <- monocle3::plot_cells(cds, color_cells_by = "partition", show_trajectory_graph = FALSE)

p1|p2

cds <- monocle3::learn_graph(cds)


monocle3::plot_cells(cds, label_groups_by_cluster = FALSE, label_leaves = FALSE, label_branch_points = FALSE)


monocle3::plot_cells(cds, label_groups_by_cluster = F, label_leaves = T, label_branch_points = T)


cds <- monocle3::order_cells(cds)


monocle3::plot_cells(cds, color_cells_by = "pseudotime", label_cell_groups = FALSE, label_leaves = FALSE, 
    label_branch_points = FALSE)

?find_gene_modules

gene_module_df <- monocle3::find_gene_modules(cds, resolution = 1e-2)



monocle3::plot_cells(cds, 
           genes=gene_module_df %>% filter(module %in% c(1, 2, 3, 4)),
           group_cells_by="partition",
           color_cells_by="partition",
           show_trajectory_graph=FALSE)

monocle3::plot_cells(cds,
           color_cells_by = "cluster",
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE)



AFD_genes <- c("ICOS", "PDCD1", "IFNG")
AFD_lineage_cds <- cds[rowData(cds) %in% AFD_genes, ]



monocle3::plot_genes_in_pseudotime(cds,
                         color_cells_by="cluster",
                         label_by_short_name = F,
                         min_expr=0.5)

?plot_genes_in_pseudotime

ciliated_cds_pr_test_res <- monocle3::graph_test(cds, neighbor_graph="principal_graph", cores=4)
pr_deg_ids <- row.names(subset(ciliated_cds_pr_test_res, q_value < 0.05))




ldat <- ReadVelocity(file = "../Additional_Analysis/Velocity_loom/GEX1_20200121_BaldNextSeq_CountsOnly.loom")
bm <- as.Seurat(x = ldat)








```
 
 

## Analysis optimisation code {.tabset}

### Optimise UMAP variables 
```{r Optimise_UMAP_vis, eval = FALSE}


if(long.compute){
  
  #########
  # UMAP
  #########
  # determine best min distance & neighbour val for UMAP
  
  DefaultAssay(seurat.combined) <- "integrated"
  
  # Set Idents
  Idents(seurat.combined) <- seurat.combined@meta.data$Module
  
  
  
  #############
  if (!dir.exists("output/Optimising_UMAP")) {
    dir.create("output/Optimising_UMAP", recursive = T)
  }
  
  min.dist.val <- 0.001
  
  # UMAP loop
  while (min.dist.val < 1) {
    n.neigh.val <- 5
    while (n.neigh.val <= 50) {
      temp <- RunUMAP(object = seurat.combined,
                      reduction = "pca",
                      dims = 1:20,
                      umap.method = "uwot",
                      n.neighbors = n.neigh.val, # 5 to 50
                      min.dist = min.dist.val, # Sensible values are in the range 0.001 to 0.5
                      seed.use = 42)
      
      # Larger values = global structure
      # small value = local structure
      
      print(UMAPPlot(object = temp,
                     group.by = "Module",
                     label = TRUE, 
                     label.size = 4) + ggtitle(paste0("UMAP Min dist = ", min.dist.val, "n.val = ", n.neigh.val)))
      
      dev.copy(pdf, paste0("output/Optimising_UMAP/UMAP_Min_dist_", min.dist.val, "_neighval_", n.neigh.val, ".pdf"))
      dev.off()
      
      n.neigh.val <- n.neigh.val + 20
      print(paste0(n.neigh.val))
    }
    
    min.dist.val <- min.dist.val * 10
    print(paste0(min.dist.val))
  }
}

# Default of n.neighbor = 30 and min.dist = 0.3 work well

```

### Altering the cluster calling resolution
```{r Differing_clust_resolution, eval = FALSE, echo = FALSE}

if(long.compute){
  
  if (!dir.exists("output/figures/Differing_clust_resolution")) {
    dir.create("output/figures/Differing_clust_resolution", recursive = T)
  }
  
  
  DefaultAssay(seurat.combined) <- "integrated"
  
  
  res.val <- 0.1
  
  while(res.val < 5){
    
    print(paste0("calculating clusters for res.val = ", res.val))
    
    # Find clusters
    seurat.combined <- FindClusters(seurat.combined, 
                                    resolution = res.val)
    
    
    # set ident 
    Idents(seurat.combined) <- seurat.combined@meta.data[, paste0("integrated_snn_res.", res.val)]
    
    
    print(UMAPPlot(object = seurat.combined,
                   label = TRUE, 
                   label.size = 6) + 
            ggtitle(paste0("clusters based on res.val = ", res.val)))
    
    dev.copy(pdf, paste0("output/figures/Differing_clust_resolution/UMAP_clust_res_", res.val, ".pdf"))
    dev.off()
    
    res.val <- res.val*2
    
  }
  
  
  
  # Original res val plot put into same folder 
  res.val <- 0.5
  
  # set ident 
  Idents(seurat.combined) <- seurat.combined@meta.data[, paste0("integrated_snn_res.", res.val)]
  
  
  print(UMAPPlot(object = seurat.combined,
                 label = TRUE, 
                 label.size = 6) + 
          ggtitle(paste0("clusters based on res.val = ", res.val)))
  
  dev.copy(pdf, paste0("output/figures/Differing_clust_resolution/UMAP_clust_res_", res.val, ".pdf"))
  dev.off()
}

```






## Script info {.tabset}

### Run time
```{r code_runtime, eval = TRUE}

# calculate compute time for compiling code so far
compute.time <- Sys.time()
print(compute.time-start.time)


```



## Code Archive {.tabset}

### Add TCR data
```{r Add_TCR_data)}

# Keep only TCR clones called with both a productive alpha and beta chain 
# when duplicates exist - keep most abundant alpha-beta paired clone 


#TCR.df <- S1.TCR.df
#Clonotype.df <- S1.Clonotype.df
#input.object <- Sample1.seurat

############################################################
# Function to append TCR data to metadata of seurat object
AddTCRdata <- function(input.object, TCR.df, Clonotype.df){
  
  
  
  # Remove the -1 at the end of each barcode.
  # Subsets so only the first line of each barcode is kept,
  # as each entry for given barcode will have same clonotype.
  #TCR.df$barcode <- gsub("-1", "", TCR.df$barcode)
  
  # Keep only productive calls
  TCR.df <- TCR.df[TCR.df$productive == "True", ]
  
  # Keep only calls annotated to cells - N.B dataset should already only contain calls within cells, this is a double check
  TCR.df <- TCR.df[TCR.df$is_cell == "True", ]
  
  # Keep only high confidence calls - N.B dataset should already only contain high conf calls, this is a double check
  TCR.df <- TCR.df[TCR.df$high_confidence == "True", ]
  
  # Sanity check
  print(paste0("should be zero = ", sum(TCR.df$full_length != "True")))
  
  
  ####################################################################################
  # Note that a number of cells have two productive TCR alpha and/or beta chain calls 
  # therefore for the time being, will sort by UMI and keep only the highest TCRA or TCRB call 
  # note that desipte differing TCRA or TCRB calls, these are annotated as a single clonotype. 
  ####################################################################################
  
  # Sort TCR.df by UMI count
  order.index <- order(TCR.df$umis, decreasing = TRUE)
  TCR.df <- TCR.df[order.index, ]
  head(TCR.df)
  
  # Split data by alpha and beta chain reads
  alpha.chain <- TCR.df[TCR.df$chain == "TRA", ]
  beta.chain <- TCR.df[TCR.df$chain == "TRB", ]
  
  # Get duplicated entries 
  alpha.chain.dup <- alpha.chain[duplicated(alpha.chain$barcode), ]
  beta.chain.dup <- beta.chain[duplicated(beta.chain$barcode), ]
  
  # Remove duplicated entries
  alpha.chain <- alpha.chain[!duplicated(alpha.chain$barcode), ]
  beta.chain <- beta.chain[!duplicated(beta.chain$barcode), ]
  
  print(paste0("% of double alpha chain calls = ", dim(alpha.chain.dup)[1] / dim(alpha.chain)[1] * 100))
  print(paste0("% of double beta chain calls = ", dim(beta.chain.dup)[1] / dim(beta.chain)[1] * 100))
  
  
  # Keep only useful cols 
  alpha.chain <- alpha.chain[ ,c("barcode",
                                 "v_gene",
                                 "j_gene", 
                                 "cdr3", 
                                 "cdr3_nt",
                                 "reads", 
                                 "umis",
                                 "raw_clonotype_id")]
  
  beta.chain <- beta.chain[ ,c("barcode",
                               "v_gene",
                               "j_gene", 
                               "cdr3", 
                               "cdr3_nt",
                               "reads", 
                               "umis",
                               "raw_clonotype_id")]
  
  
  # Change colnames
  names(alpha.chain)[names(alpha.chain) == "raw_clonotype_id"] <- "clonotype_id"
  names(beta.chain)[names(beta.chain) == "raw_clonotype_id"] <- "clonotype_id"
  
  names(alpha.chain) <- paste0(names(alpha.chain), "_A")
  names(beta.chain) <- paste0(names(beta.chain), "_B")
  
  names(alpha.chain)[names(alpha.chain) == "barcode_A"] <- "barcode"
  names(beta.chain)[names(beta.chain) == "barcode_B"] <- "barcode"
  
  
  # Keep only entries for cells that have both a functional alpha and beta chain
  length(alpha.chain$barcode)
  length(beta.chain$barcode)
  
  keep.A <- alpha.chain$barcode %in% beta.chain$barcode
  print(paste0("sum of keep.A = ", sum(keep.A)))
  
  keep.B <- beta.chain$barcode %in% alpha.chain$barcode
  print(paste0("sum of keep.A = ", sum(keep.B)))
  
  alpha.chain.paired <- alpha.chain[keep.A, ]
  beta.chain.paired <- beta.chain[keep.B, ]
  
  print(paste0("length paired A = length paired b = ", length(alpha.chain.paired$barcode) == length(beta.chain.paired$barcode)))
  
  # Set Barcode as rownames and remove from df
  rownames(alpha.chain.paired) <- alpha.chain.paired$barcode
  alpha.chain.paired <- alpha.chain.paired[, colnames(alpha.chain.paired) != "barcode"]
  
  rownames(beta.chain.paired) <- beta.chain.paired$barcode
  beta.chain.paired <- beta.chain.paired[, colnames(beta.chain.paired) != "barcode"]
  
  
  ###################################################################
  # add in filter of clonotype table and for easy cross ref
  ###################################################################
  
  
  # Add data to metadata 
  input.object <- AddMetaData(object = input.object, metadata = alpha.chain.paired)
  input.object <- AddMetaData(object = input.object, metadata = beta.chain.paired)
  
  print(head(input.object@meta.data, 10))
  
  # Slap the AA sequences onto our original table by clonotype_id.
  
  # dim(TCR.df) # 2545 cells
  # dim(Clonotype.df) #1716 clonotypes
  # sum(duplicated(Clonotype.df$clonotype_id)) # 0 duplicated clonotype entries 
  
  # # need a table of same nrow as S1_VDJ
  # 
  # TCR.df <- base::merge(TCR.df, Clonotype.df[, c("clonotype_id", "cdr3s_aa")], all = TRUE)
  # dim(TCR.df) # 2545
  # 
  # # Reorder so barcodes are first column and set them as rownames.
  # rownames(TCR.df) <- TCR.df$barcode
  # TCR.df <- TCR.df[, colnames(TCR.df) != "barcode"]
  # 
  # # Add to the Seurat object's metadata.
  # input.object <- AddMetaData(object = input.object, metadata = TCR.df)
  
  print(paste0("# of NA in TCRA calls in metadata = ", sum(is.na(input.object@meta.data$clonotype_id_A))))
  print(paste0("# of NA in TCRB calls in metadata = ", sum(is.na(input.object@meta.data$clonotype_id_B))))
  
  print(paste0("# of cells in input.object = ", ncol(input.object)))
  
  print(paste0("# of cells with alpha chain call = ", nrow(alpha.chain)))
  print(paste0("# of cells with beta chain call = ", nrow(beta.chain)))
  
  print(paste0("therefore should only be ", ncol(input.object) - nrow(alpha.chain), " missing alpha vals"))
  print(paste0("therefore should only be ", ncol(input.object) - nrow(beta.chain), " missing beta vals"))
  
  print(paste0("Number of alpha paired beta chains = ", nrow(alpha.chain.paired)))
  print(paste0("Number of beta paired alpha chains = ", nrow(beta.chain.paired)))
  
  return(input.object)
}
############################################################


# VDJ data 
S1.TCR.df <- read.csv("Input_data/VDJ_data/Sample1_filtered_contig_annotations.csv")
S2.TCR.df <- read.csv("Input_data/VDJ_data/Sample2_filtered_contig_annotations.csv")
S3.TCR.df <- read.csv("Input_data/VDJ_data/Sample3_filtered_contig_annotations.csv")
S4.TCR.df <- read.csv("Input_data/VDJ_data/Sample4_filtered_contig_annotations.csv")

# Clonotype info
S1.Clonotype.df <- read.csv("Input_data/VDJ_data/Sample1_clonotypes.csv")
S2.Clonotype.df <- read.csv("Input_data/VDJ_data/Sample2_clonotypes.csv")
S3.Clonotype.df <- read.csv("Input_data/VDJ_data/Sample3_clonotypes.csv")
S4.Clonotype.df <- read.csv("Input_data/VDJ_data/Sample4_clonotypes.csv")



# Add a unique identifyer to TCR clonotype ID as this is sample specific
# TCR df
S1.TCR.df$raw_clonotype_id <- paste0("S1_", S1.TCR.df$raw_clonotype_id)
S2.TCR.df$raw_clonotype_id <- paste0("S2_", S2.TCR.df$raw_clonotype_id)
S3.TCR.df$raw_clonotype_id <- paste0("S3_", S3.TCR.df$raw_clonotype_id)
S4.TCR.df$raw_clonotype_id <- paste0("S4_", S4.TCR.df$raw_clonotype_id)

# Clonotype df
S1.Clonotype.df$clonotype_id <- paste0("S1_", S1.Clonotype.df$clonotype_id)
S2.Clonotype.df$clonotype_id <- paste0("S2_", S2.Clonotype.df$clonotype_id)
S3.Clonotype.df$clonotype_id <- paste0("S3_", S3.Clonotype.df$clonotype_id)
S4.Clonotype.df$clonotype_id <- paste0("S4_", S4.Clonotype.df$clonotype_id)

# Add TCR data to seurat object metadata
Sample1.seurat <- AddTCRdata(Sample1.seurat, S1.TCR.df, S1.Clonotype.df) 
Sample2.seurat <- AddTCRdata(Sample2.seurat, S2.TCR.df, S2.Clonotype.df)
Sample3.seurat <- AddTCRdata(Sample3.seurat, S3.TCR.df, S3.Clonotype.df)
Sample4.seurat <- AddTCRdata(Sample4.seurat, S4.TCR.df, S4.Clonotype.df)

head(Sample4.seurat@meta.data, 10)

# Add Sample ID to seurat object metadata
Sample1.seurat@meta.data$group <- "S1"
Sample2.seurat@meta.data$group <- "S2"
Sample3.seurat@meta.data$group <- "S3"
Sample4.seurat@meta.data$group <- "S4"


####################################################################################
# Function to determine how many cells have double TCR or single Alpha/Beta calls
####################################################################################


get.TCR.stats <- function(input.df){
  
  input.df.productive <- input.df[input.df$productive == "True", ]
  input.df.nonproductive <- input.df[input.df$productive == "False", ]
  
  total.n <-   length(unique(input.df$barcode))
  productive.n <- length(unique(input.df.productive$barcode))
  nonproductive.n <- length(unique(input.df.nonproductive$barcode))
  
  print(paste0("Total # of cells with productive call = ", productive.n))
  print(paste0("Total # of cells with non-productive call = ", nonproductive.n))
  
  print(paste0("% of dataset with productive call = ", signif(productive.n/total.n * 100)))
  print(paste0("% of dataset with non-productive call = ", signif(nonproductive.n/total.n * 100)))
  
  alpha.chain <- input.df.productive[input.df.productive$chain == "TRA", ]
  beta.chain <- input.df.productive[input.df.productive$chain == "TRB", ]
  
  alpha.chain.dup <- alpha.chain[duplicated(alpha.chain$barcode), ]
  beta.chain.dup <- beta.chain[duplicated(beta.chain$barcode), ]
  
  alpha.chain.No.dup <- alpha.chain[!duplicated(alpha.chain$barcode), ]
  beta.chain.No.dup <- beta.chain[!duplicated(beta.chain$barcode), ]
  
  ##############################
  # Get stats
  ##############################
  
  alpha.total.n <- nrow(alpha.chain)
  betal.total.n <- nrow(beta.chain)
  
  alpha.dup.n <- nrow(alpha.chain.dup)
  beta.dup.n <- nrow(beta.chain.dup)
  
  alpha.NonDup.n <- nrow(alpha.chain.No.dup)
  beta.NonDup.n <- nrow(beta.chain.No.dup)
  
  # Number of cells with an alpha/beta chain call (TOTAL)
  print(paste0("Total # of cells with an alpha chain call = ", alpha.total.n))
  print(paste0("Total # of cells with an beta chain call = ", betal.total.n))
  
  # Number of cells with two alpha/beta chain calls
  print(paste0("# of cells with double alpha chain calls = ", alpha.dup.n))
  print(paste0("# of cells with double beta chain calls = ", beta.dup.n))
  
  # Percentage of cells with two alpha/beta chain calls
  print(paste0("% of cells with double alpha chain calls = ", signif(alpha.dup.n/alpha.total.n * 100)))
  print(paste0("% of cells with double beta chain calls = ", signif(beta.dup.n/betal.total.n * 100)))
  
  ################################################
  # How many cells have a single chain call
  ################################################
  
  # Alpha chain
  logic.vec <- alpha.chain.No.dup$barcode %in% beta.chain.No.dup$barcode
  
  alpha.only <- alpha.chain.No.dup[!logic.vec, ]
  
  alpha.only.n <- nrow(alpha.only)
  
  
  # Beta chain
  logic.vec <- beta.chain.No.dup$barcode %in% alpha.chain.No.dup$barcode
  
  beta.only <- beta.chain.No.dup[!logic.vec, ] 
  
  beta.only.n <- nrow(beta.only)
  
  # Number of cells with a single alpha or single beta chain call
  print(paste0("# of cells with only an alpha chain call = ", alpha.only.n))
  print(paste0("# of cells with only a beta chain call = ", beta.only.n))
  
  # Percentage of cells with only a single chain call
  print(paste0("% of cells with only an alpha chain call = ", signif(alpha.only.n/alpha.total.n * 100)))
  
  print(paste0("% of cells with only a beta chain call = ", signif(beta.only.n/betal.total.n * 100)))
  
  
  
  ################################################
  # How many cells have a double chains
  ################################################
  
  # Double Alpha and double Beta 
  logic.vec <- alpha.chain.dup$barcode %in% beta.chain.dup$barcode
  
  dup.alpha.dup.beta <- alpha.chain.dup[logic.vec, ]
  
  dim(dup.alpha.dup.beta)
  
  
  logic.vec <- beta.chain.dup$barcode %in% alpha.chain.dup$barcode
  
  dup.alpha.dup.beta <- beta.chain.dup[logic.vec, ]
  
  dim(dup.alpha.dup.beta)
  
  D.Alpha.d.Beta.n <- nrow(dup.alpha.dup.beta)
  
  # Double Alpha and single Beta 
  logic.vec <- alpha.chain.dup$barcode %in% beta.chain.No.dup$barcode
  
  dup.alpha.single.beta <- alpha.chain.dup[logic.vec, ]
  
  dim(dup.alpha.single.beta)
  
  
  logic.vec <- beta.chain.No.dup$barcode %in% alpha.chain.dup$barcode
  
  dup.alpha.single.beta <- beta.chain.No.dup[logic.vec, ]
  
  dim(dup.alpha.single.beta)
  D.Alpha.s.Beta.n <- nrow(dup.alpha.single.beta)
  
  
  # single Alpha and double Beta 
  logic.vec <- alpha.chain.No.dup$barcode %in% beta.chain.dup$barcode
  
  single.alpha.double.beta <- alpha.chain.No.dup[logic.vec, ]
  
  dim(single.alpha.double.beta)
  
  
  logic.vec <- beta.chain.dup$barcode %in% alpha.chain.No.dup$barcode
  
  single.alpha.double.beta <- beta.chain.dup[logic.vec, ]
  
  S.Alpha.D.Beta.n <- nrow(single.alpha.double.beta)
  
  
  # Number of cells with a double - single combos
  print(paste0("# of cells with a double alpha & double beta chain call = ", D.Alpha.d.Beta.n))
  print(paste0("# of cells with a double alpha & single beta chain call = ", D.Alpha.s.Beta.n))
  print(paste0("# of cells with a single alpha & double betachain call = ", S.Alpha.D.Beta.n))
  
  
  
  # Percentage of cells with double chain calls
  print(paste0("% of cells with a double A and double B chain call = ", signif(D.Alpha.d.Beta.n/total.n * 100)))
  print(paste0("% of cells with a double A and single B chain call = ", signif(D.Alpha.s.Beta.n/total.n * 100)))
  print(paste0("% of cells with a single A and double B chain call = ", signif(S.Alpha.D.Beta.n/total.n * 100)))
  
  
  
  
  
  
}


# Get stats on TCR info
get.TCR.stats(S1.TCR.df)
get.TCR.stats(S2.TCR.df)
get.TCR.stats(S3.TCR.df)
get.TCR.stats(S4.TCR.df)


```


