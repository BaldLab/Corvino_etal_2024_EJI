---
title: "HNSCC_scRNAseq_Descriptive_paper"
author: "Dillon Corvino"
date: "03/02/2020"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: united
    highlight: tango
    df_print: paged
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

Built with R version `r getRversion()`

## Setup {.tabset}

### Dataset information
```{r Dataset_Info}

# Human samples from HNSCC patients
# samples 1 and 2 are unstimulated 
# samples 3 and 4 are stimulated 
# Patients in 1 match patients in 3 and sample 2 pairs with 4
# Cells are HNSCC TILs sorted on Lymphocytes/Live/CD3+/CD4-/CD8+
# Data acquired was transcript expression, ADT (antibody expression), and TCRA & B sequences
# This analysis uses just Transcript and TCR data

```

### Environment
```{r Environment_setup, message = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,  
  eval = TRUE, 
  tidy = TRUE
)

# Environment Set up
rm(list = ls()) #Clean workspace
cat("\014")     #Clean Console
gc() # Free memory

start.time <- Sys.time()
quick.load <- TRUE
long.compute <- FALSE

###################
# Install packages
###################

# CITEseq requires latest version of Seurat i.e at least V3
# Install development version of seurat
# devtools::install_github(repo = 'satijalab/seurat', ref = 'develop')

pkgs <- c("remedy", "Seurat", "dplyr", "rstudioapi",
          "cowplot", "ggplot2", "grid", "gridExtra",
          "styler", "stringr", "inlmisc", "RColorBrewer",
          "readxl", "devtools", "tidyverse", "hdf5r", "scales", "useful")

for(i in 1:length(pkgs)){
  if(!require(pkgs[i], character.only = T)){
    install.packages(pkgs[i])
    require(pkgs[i], character.only = T)
  }else{
    require(pkgs[i], character.only = T)
  }
}

pkgs <- c("gplots", "fgsea", "biomaRt", "clusterProfiler", 
          "GSEABase", "org.Hs.eg.db", "org.Mm.eg.db", "pcaMethods",
          "SingleCellExperiment", "batchelor", "DelayedArray", "DelayedMatrixStats",
          "limma", "SummarizedExperiment")

for(i in 1:length(pkgs)){
  if(!require(pkgs[i], character.only = T)){
    BiocManager::install(pkgs[i])
    require(pkgs[i], character.only = T)
  }else{
    require(pkgs[i], character.only = T)
  }
}


#####################
# Github packages
#####################


# Installed packages 

#library("devtools")

#usethis::browse_github_pat()
#usethis::edit_r_environ()
# GITHUB_PAT = "d8207153aef7b295cdf66eb1e1b2a2ed38b0ca18"
# R_MAX_VSIZE = 30Gb


#install.packages("~/Desktop/scRepertoire-master.zip", repos=NULL, INSTALL_opts = "--no-test-load", type = "source")


# celltalker
#devtools::install_github("arc85/celltalker")

# Scillus 
#devtools::install_github("xmc811/Scillus", ref = "development")

#devtools::install_github('satijalab/seurat-data')

#devtools::install_github("velocyto-team/velocyto.R")

#devtools::install_github("dynverse/dyno")



#devtools::install_github('cole-trapnell-lab/leidenbase')
#devtools::install_github('cole-trapnell-lab/monocle3')

#devtools::install_github("immunomind/immunarch")
#devtools::install_github("Coolgenome/iTALK", build_vignettes = TRUE)






#########################
# Failed installations
#########################


#devtools::install_github("ncborcherding/scRepertoire")

#devtools::install_github('satijalab/seurat-wrappers')


# Moncle packages to load 
#library(monocle3)
#library(Seurat)
#library(SeuratData)
#library(SeuratWrappers)
#library(ggplot2)
#library(patchwork)
#library(magrittr)


#.rs.restartR()

####################
# Colour scheme
####################

Condition.cols <- c("turquoise", "red")

clust.cols <- c("#E41A1C", # Naive_like_1_CM
                "#A6761D", # Naive_like_2_SC
                "#8DA0CB", # Naive_like_3
                "#666666", # Cytotoxic
                "#A6D854", # Type_I_IFN
                "#984EA3", # Stimulated_1
                "#1B9E77", # Stimulated_exhausted
                "#D95F02", # Exhausted_1
                "#7570B3", # Exhausted_2
                "#E7298A", # TRM
                "#E6AB02", # gd_T_g9d2
                "#8DD3C7", # gd_T_non_g9d2
                "#FF7F00", # MAIT 
                "#E78AC3") # Proliferative


module.cols <- c("#E41A1C", # Naive_Stem
                 "#1B9E77", # Activated
                 "#7570B3", # Exhaustion
                 "#FF7F00", # Innate
                 "#E78AC3") # Cycling



# Archive code for colour scheme tinkering 
# display.brewer.all()
# 14 cols needed
#clust.cols <-  c(brewer.pal(11, "Set3"), brewer.pal(3, "Dark2"))
# names(clust.cols) <- levels(seurat.tcr@meta.data$seurat_clusters)
# clust.cols























# Set working directory to source file location
setwd(dirname(getActiveDocumentContext()$path))
working.dir <- getwd()


# create output directories
if(!dir.exists("Exported_RDS_files")){dir.create("Exported_RDS_files", recursive = T)}
if(!dir.exists("output")){dir.create("output", recursive = T)}
if(!dir.exists("output/figures")){dir.create("output/figures", recursive = T)}
if(!dir.exists("output/tables")){dir.create("output/tables", recursive = T)}
if(!dir.exists("output/QC")){dir.create("output/QC", recursive = T)}


# load saved seurat object with cluster annotations and imputation performed
if(quick.load){
  seurat.combined <- readRDS("Exported_RDS_files/seurat_combined.rds")
}


```

### Reading data
```{r reading_data}

# Load dataset from output generated by Ross, file is annotated as filtered_feature_bc_matrix

Sample1.data <- Read10X(data.dir = "Input_data/GEX_filtered_feature_bc_matrix_GEX_Only/Sample1_US/")
Sample2.data <- Read10X(data.dir = "Input_data/GEX_filtered_feature_bc_matrix_GEX_Only/Sample2_US/")
Sample3.data <- Read10X(data.dir = "Input_data/GEX_filtered_feature_bc_matrix_GEX_Only/Sample3_Stim/")
Sample4.data <- Read10X(data.dir = "Input_data/GEX_filtered_feature_bc_matrix_GEX_Only/Sample4_Stim/")


Sample1.seurat <- CreateSeuratObject(
  counts = Sample1.data,
  min.cells = 3,
  min.features = 200
)

Sample2.seurat <- CreateSeuratObject(
  counts = Sample2.data,
  min.cells = 3,
  min.features = 200
)

Sample3.seurat <- CreateSeuratObject(
  counts = Sample3.data,
  min.cells = 3,
  min.features = 200
)

Sample4.seurat <- CreateSeuratObject(
  counts = Sample4.data,
  min.cells = 3,
  min.features = 200
)


```

### Add TCR data
```{r Add_TCR_data)}

# Keep only TCR clones called with both a productive alpha and beta chain 
# when duplicates exist - keep most abundant alpha-beta paired clone 


#TCR.df <- S1.TCR.df
#Clonotype.df <- S1.Clonotype.df
#input.object <- Sample1.seurat

############################################################
# Function to append TCR data to metadata of seurat object
AddTCRdata <- function(input.object, TCR.df, Clonotype.df){
  
  
  
  # Remove the -1 at the end of each barcode.
  # Subsets so only the first line of each barcode is kept,
  # as each entry for given barcode will have same clonotype.
  #TCR.df$barcode <- gsub("-1", "", TCR.df$barcode)
  
  # Keep only productive calls
  TCR.df <- TCR.df[TCR.df$productive == "True", ]
  
  # Keep only calls annotated to cells - N.B dataset should already only contain calls within cells, this is a double check
  TCR.df <- TCR.df[TCR.df$is_cell == "True", ]
  
  # Keep only high confidence calls - N.B dataset should already only contain high conf calls, this is a double check
  TCR.df <- TCR.df[TCR.df$high_confidence == "True", ]
  
  # Sanity check
  print(paste0("should be zero = ", sum(TCR.df$full_length != "True")))
  
  
  ####################################################################################
  # Note that a number of cells have two productive TCR alpha and/or beta chain calls 
  # therefore for the time being, will sort by UMI and keep only the highest TCRA or TCRB call 
  # note that desipte differing TCRA or TCRB calls, these are annotated as a single clonotype. 
  ####################################################################################
  
  # Sort TCR.df by UMI count
  order.index <- order(TCR.df$umis, decreasing = TRUE)
  TCR.df <- TCR.df[order.index, ]
  head(TCR.df)
  
  # Split data by alpha and beta chain reads
  alpha.chain <- TCR.df[TCR.df$chain == "TRA", ]
  beta.chain <- TCR.df[TCR.df$chain == "TRB", ]
  
  # Get duplicated entries 
  alpha.chain.dup <- alpha.chain[duplicated(alpha.chain$barcode), ]
  beta.chain.dup <- beta.chain[duplicated(beta.chain$barcode), ]
  
  # Remove duplicated entries
  alpha.chain <- alpha.chain[!duplicated(alpha.chain$barcode), ]
  beta.chain <- beta.chain[!duplicated(beta.chain$barcode), ]
  
  print(paste0("% of double alpha chain calls = ", dim(alpha.chain.dup)[1] / dim(alpha.chain)[1] * 100))
  print(paste0("% of double beta chain calls = ", dim(beta.chain.dup)[1] / dim(beta.chain)[1] * 100))
  
  
  # Keep only useful cols 
  alpha.chain <- alpha.chain[ ,c("barcode",
                                 "v_gene",
                                 "j_gene", 
                                 "cdr3", 
                                 "cdr3_nt",
                                 "reads", 
                                 "umis",
                                 "raw_clonotype_id")]
  
  beta.chain <- beta.chain[ ,c("barcode",
                               "v_gene",
                               "j_gene", 
                               "cdr3", 
                               "cdr3_nt",
                               "reads", 
                               "umis",
                               "raw_clonotype_id")]
  
  
  # Change colnames
  names(alpha.chain)[names(alpha.chain) == "raw_clonotype_id"] <- "clonotype_id"
  names(beta.chain)[names(beta.chain) == "raw_clonotype_id"] <- "clonotype_id"
  
  names(alpha.chain) <- paste0(names(alpha.chain), "_A")
  names(beta.chain) <- paste0(names(beta.chain), "_B")
  
  names(alpha.chain)[names(alpha.chain) == "barcode_A"] <- "barcode"
  names(beta.chain)[names(beta.chain) == "barcode_B"] <- "barcode"
  
  
  # Keep only entries for cells that have both a functional alpha and beta chain
  length(alpha.chain$barcode)
  length(beta.chain$barcode)
  
  keep.A <- alpha.chain$barcode %in% beta.chain$barcode
  print(paste0("sum of keep.A = ", sum(keep.A)))
  
  keep.B <- beta.chain$barcode %in% alpha.chain$barcode
  print(paste0("sum of keep.A = ", sum(keep.B)))
  
  alpha.chain.paired <- alpha.chain[keep.A, ]
  beta.chain.paired <- beta.chain[keep.B, ]
  
  print(paste0("length paired A = length paired b = ", length(alpha.chain.paired$barcode) == length(beta.chain.paired$barcode)))
  
  # Set Barcode as rownames and remove from df
  rownames(alpha.chain.paired) <- alpha.chain.paired$barcode
  alpha.chain.paired <- alpha.chain.paired[, colnames(alpha.chain.paired) != "barcode"]
  
  rownames(beta.chain.paired) <- beta.chain.paired$barcode
  beta.chain.paired <- beta.chain.paired[, colnames(beta.chain.paired) != "barcode"]
  
  
  ###################################################################
  # add in filter of clonotype table and for easy cross ref
  ###################################################################
  
  
  # Add data to metadata 
  input.object <- AddMetaData(object = input.object, metadata = alpha.chain.paired)
  input.object <- AddMetaData(object = input.object, metadata = beta.chain.paired)
  
  print(head(input.object@meta.data, 10))
  
  # Slap the AA sequences onto our original table by clonotype_id.
  
  # dim(TCR.df) # 2545 cells
  # dim(Clonotype.df) #1716 clonotypes
  # sum(duplicated(Clonotype.df$clonotype_id)) # 0 duplicated clonotype entries 
  
  # # need a table of same nrow as S1_VDJ
  # 
  # TCR.df <- base::merge(TCR.df, Clonotype.df[, c("clonotype_id", "cdr3s_aa")], all = TRUE)
  # dim(TCR.df) # 2545
  # 
  # # Reorder so barcodes are first column and set them as rownames.
  # rownames(TCR.df) <- TCR.df$barcode
  # TCR.df <- TCR.df[, colnames(TCR.df) != "barcode"]
  # 
  # # Add to the Seurat object's metadata.
  # input.object <- AddMetaData(object = input.object, metadata = TCR.df)
  
  print(paste0("# of NA in TCRA calls in metadata = ", sum(is.na(input.object@meta.data$clonotype_id_A))))
  print(paste0("# of NA in TCRB calls in metadata = ", sum(is.na(input.object@meta.data$clonotype_id_B))))
  
  print(paste0("# of cells in input.object = ", ncol(input.object)))
  
  print(paste0("# of cells with alpha chain call = ", nrow(alpha.chain)))
  print(paste0("# of cells with beta chain call = ", nrow(beta.chain)))
  
  print(paste0("therefore should only be ", ncol(input.object) - nrow(alpha.chain), " missing alpha vals"))
  print(paste0("therefore should only be ", ncol(input.object) - nrow(beta.chain), " missing beta vals"))
  
  print(paste0("Number of alpha paired beta chains = ", nrow(alpha.chain.paired)))
  print(paste0("Number of beta paired alpha chains = ", nrow(beta.chain.paired)))
  
  return(input.object)
}
############################################################


# VDJ data 
S1.TCR.df <- read.csv("Input_data/VDJ_data/Sample1_filtered_contig_annotations.csv")
S2.TCR.df <- read.csv("Input_data/VDJ_data/Sample2_filtered_contig_annotations.csv")
S3.TCR.df <- read.csv("Input_data/VDJ_data/Sample3_filtered_contig_annotations.csv")
S4.TCR.df <- read.csv("Input_data/VDJ_data/Sample4_filtered_contig_annotations.csv")

# Clonotype info
S1.Clonotype.df <- read.csv("Input_data/VDJ_data/Sample1_clonotypes.csv")
S2.Clonotype.df <- read.csv("Input_data/VDJ_data/Sample2_clonotypes.csv")
S3.Clonotype.df <- read.csv("Input_data/VDJ_data/Sample3_clonotypes.csv")
S4.Clonotype.df <- read.csv("Input_data/VDJ_data/Sample4_clonotypes.csv")



# Add a unique identifyer to TCR clonotype ID as this is sample specific
# TCR df
S1.TCR.df$raw_clonotype_id <- paste0("S1_", S1.TCR.df$raw_clonotype_id)
S2.TCR.df$raw_clonotype_id <- paste0("S2_", S2.TCR.df$raw_clonotype_id)
S3.TCR.df$raw_clonotype_id <- paste0("S3_", S3.TCR.df$raw_clonotype_id)
S4.TCR.df$raw_clonotype_id <- paste0("S4_", S4.TCR.df$raw_clonotype_id)

# Clonotype df
S1.Clonotype.df$clonotype_id <- paste0("S1_", S1.Clonotype.df$clonotype_id)
S2.Clonotype.df$clonotype_id <- paste0("S2_", S2.Clonotype.df$clonotype_id)
S3.Clonotype.df$clonotype_id <- paste0("S3_", S3.Clonotype.df$clonotype_id)
S4.Clonotype.df$clonotype_id <- paste0("S4_", S4.Clonotype.df$clonotype_id)

# Add TCR data to seurat object metadata
Sample1.seurat <- AddTCRdata(Sample1.seurat, S1.TCR.df, S1.Clonotype.df) 
Sample2.seurat <- AddTCRdata(Sample2.seurat, S2.TCR.df, S2.Clonotype.df)
Sample3.seurat <- AddTCRdata(Sample3.seurat, S3.TCR.df, S3.Clonotype.df)
Sample4.seurat <- AddTCRdata(Sample4.seurat, S4.TCR.df, S4.Clonotype.df)

head(Sample4.seurat@meta.data, 10)

# Add Sample ID to seurat object metadata
Sample1.seurat@meta.data$group <- "S1"
Sample2.seurat@meta.data$group <- "S2"
Sample3.seurat@meta.data$group <- "S3"
Sample4.seurat@meta.data$group <- "S4"


####################################################################################
# Function to determine how many cells have double TCR or single Alpha/Beta calls
####################################################################################


get.TCR.stats <- function(input.df){
  
  input.df.productive <- input.df[input.df$productive == "True", ]
  input.df.nonproductive <- input.df[input.df$productive == "False", ]
  
  total.n <-   length(unique(input.df$barcode))
  productive.n <- length(unique(input.df.productive$barcode))
  nonproductive.n <- length(unique(input.df.nonproductive$barcode))
  
  print(paste0("Total # of cells with productive call = ", productive.n))
  print(paste0("Total # of cells with non-productive call = ", nonproductive.n))
  
  print(paste0("% of dataset with productive call = ", signif(productive.n/total.n * 100)))
  print(paste0("% of dataset with non-productive call = ", signif(nonproductive.n/total.n * 100)))
  
  alpha.chain <- input.df.productive[input.df.productive$chain == "TRA", ]
  beta.chain <- input.df.productive[input.df.productive$chain == "TRB", ]
  
  alpha.chain.dup <- alpha.chain[duplicated(alpha.chain$barcode), ]
  beta.chain.dup <- beta.chain[duplicated(beta.chain$barcode), ]
  
  alpha.chain.No.dup <- alpha.chain[!duplicated(alpha.chain$barcode), ]
  beta.chain.No.dup <- beta.chain[!duplicated(beta.chain$barcode), ]
  
  ##############################
  # Get stats
  ##############################
  
  alpha.total.n <- nrow(alpha.chain)
  betal.total.n <- nrow(beta.chain)
  
  alpha.dup.n <- nrow(alpha.chain.dup)
  beta.dup.n <- nrow(beta.chain.dup)
  
  alpha.NonDup.n <- nrow(alpha.chain.No.dup)
  beta.NonDup.n <- nrow(beta.chain.No.dup)
  
  # Number of cells with an alpha/beta chain call (TOTAL)
  print(paste0("Total # of cells with an alpha chain call = ", alpha.total.n))
  print(paste0("Total # of cells with an beta chain call = ", betal.total.n))
  
  # Number of cells with two alpha/beta chain calls
  print(paste0("# of cells with double alpha chain calls = ", alpha.dup.n))
  print(paste0("# of cells with double beta chain calls = ", beta.dup.n))
  
  # Percentage of cells with two alpha/beta chain calls
  print(paste0("% of cells with double alpha chain calls = ", signif(alpha.dup.n/alpha.total.n * 100)))
  print(paste0("% of cells with double beta chain calls = ", signif(beta.dup.n/betal.total.n * 100)))
  
  ################################################
  # How many cells have a single chain call
  ################################################
  
  # Alpha chain
  logic.vec <- alpha.chain.No.dup$barcode %in% beta.chain.No.dup$barcode
  
  alpha.only <- alpha.chain.No.dup[!logic.vec, ]
  
  alpha.only.n <- nrow(alpha.only)
  
  
  # Beta chain
  logic.vec <- beta.chain.No.dup$barcode %in% alpha.chain.No.dup$barcode
  
  beta.only <- beta.chain.No.dup[!logic.vec, ] 
  
  beta.only.n <- nrow(beta.only)
  
  # Number of cells with a single alpha or single beta chain call
  print(paste0("# of cells with only an alpha chain call = ", alpha.only.n))
  print(paste0("# of cells with only a beta chain call = ", beta.only.n))
  
  # Percentage of cells with only a single chain call
  print(paste0("% of cells with only an alpha chain call = ", signif(alpha.only.n/alpha.total.n * 100)))
  
  print(paste0("% of cells with only a beta chain call = ", signif(beta.only.n/betal.total.n * 100)))
  
  
  
  ################################################
  # How many cells have a double chains
  ################################################
  
  # Double Alpha and double Beta 
  logic.vec <- alpha.chain.dup$barcode %in% beta.chain.dup$barcode
  
  dup.alpha.dup.beta <- alpha.chain.dup[logic.vec, ]
  
  dim(dup.alpha.dup.beta)
  
  
  logic.vec <- beta.chain.dup$barcode %in% alpha.chain.dup$barcode
  
  dup.alpha.dup.beta <- beta.chain.dup[logic.vec, ]
  
  dim(dup.alpha.dup.beta)
  
  D.Alpha.d.Beta.n <- nrow(dup.alpha.dup.beta)
  
  # Double Alpha and single Beta 
  logic.vec <- alpha.chain.dup$barcode %in% beta.chain.No.dup$barcode
  
  dup.alpha.single.beta <- alpha.chain.dup[logic.vec, ]
  
  dim(dup.alpha.single.beta)
  
  
  logic.vec <- beta.chain.No.dup$barcode %in% alpha.chain.dup$barcode
  
  dup.alpha.single.beta <- beta.chain.No.dup[logic.vec, ]
  
  dim(dup.alpha.single.beta)
  D.Alpha.s.Beta.n <- nrow(dup.alpha.single.beta)
  
  
  # single Alpha and double Beta 
  logic.vec <- alpha.chain.No.dup$barcode %in% beta.chain.dup$barcode
  
  single.alpha.double.beta <- alpha.chain.No.dup[logic.vec, ]
  
  dim(single.alpha.double.beta)
  
  
  logic.vec <- beta.chain.dup$barcode %in% alpha.chain.No.dup$barcode
  
  single.alpha.double.beta <- beta.chain.dup[logic.vec, ]
  
  S.Alpha.D.Beta.n <- nrow(single.alpha.double.beta)
  
  
  # Number of cells with a double - single combos
  print(paste0("# of cells with a double alpha & double beta chain call = ", D.Alpha.d.Beta.n))
  print(paste0("# of cells with a double alpha & single beta chain call = ", D.Alpha.s.Beta.n))
  print(paste0("# of cells with a single alpha & double betachain call = ", S.Alpha.D.Beta.n))
  
  
  
  # Percentage of cells with double chain calls
  print(paste0("% of cells with a double A and double B chain call = ", signif(D.Alpha.d.Beta.n/total.n * 100)))
  print(paste0("% of cells with a double A and single B chain call = ", signif(D.Alpha.s.Beta.n/total.n * 100)))
  print(paste0("% of cells with a single A and double B chain call = ", signif(S.Alpha.D.Beta.n/total.n * 100)))
  
  
  
  
  
  
}


# Get stats on TCR info
get.TCR.stats(S1.TCR.df)
get.TCR.stats(S2.TCR.df)
get.TCR.stats(S3.TCR.df)
get.TCR.stats(S4.TCR.df)


```

### Merge Seurat objects
```{r merge_seurat}


######################
# Merge samples
######################

# Unstimulated samples 1 & 2
US.seurat <- merge(x = Sample1.seurat, 
                   y = Sample2.seurat,
                   add.cell.ids = c("S1", "S2"), 
                   merge.data = FALSE, # Should normed data be merged as well or just raw data slot
                   project = "Unstimulated")

x <- ncol(Sample1.seurat) + ncol(Sample2.seurat)
paste0("expected number of cells after merge is ", ncol(US.seurat) == x)

Sample1.seurat # 14,695 genes and 3,042 cells
Sample2.seurat # 14,706 genes and 3,536 cells
US.seurat # 15,428 genes and 6,578 cells

head(US.seurat@meta.data)


# Stimulated samples 3 & 4
Stim.seurat <- merge(x = Sample3.seurat, 
                     y = Sample4.seurat,
                     add.cell.ids = c("S3", "S4"), 
                     merge.data = FALSE, # Should normed data be merged as well or just raw data slot
                     project = "Stimulated")

x <- ncol(Sample3.seurat) + ncol(Sample4.seurat)
paste0("expected number of cells after merge is ", ncol(Stim.seurat) == x)

Sample3.seurat # 14,740 genes and 3,885 cells
Sample4.seurat # 14,926 genes and 3,279 cells
Stim.seurat # 15,619 genes and 7,164 cells

head(Stim.seurat@meta.data)



# Add a condition metadata column
US.seurat@meta.data$condition <- "US"
Stim.seurat@meta.data$condition <- "Stim"


```

### Remove large variables that are no longer needed
```{r Remove_unneeded_variables}

rm(Sample1.data, 
   Sample2.data, 
   Sample3.data, 
   Sample4.data,
   S1.Clonotype.df, 
   S2.Clonotype.df,
   S3.Clonotype.df,
   S4.Clonotype.df,
   S1.TCR.df, 
   S2.TCR.df,
   S3.TCR.df,
   S4.TCR.df,
   Sample1.seurat, 
   Sample2.seurat,
   Sample3.seurat,
   Sample4.seurat)


```

## QC and Normalisation {.tabset}

### QC & Normalisation
```{r QC_and_normalisation}


# QC metrics commonly used
# The number of unique genes detected in each cell.
# Low-quality cells or empty droplets will often have very few genes
# Cell doublets or multiplets may exhibit an aberrantly high gene count

# Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes)

# The percentage of reads that map to the mitochondrial genome
# Low-quality / dying cells often exhibit extensive mitochondrial contamination


################################################
#  Get percentage Mitochondria gene expression
################################################

# Unstimulated
US.seurat[["percent.mito"]] <- PercentageFeatureSet(US.seurat, pattern = "^MT-")

# Stimulated
Stim.seurat[["percent.mito"]] <- PercentageFeatureSet(Stim.seurat, pattern = "^MT-")

##################################
# Plot mitochondria percentage
##################################

# nFeature & nCount & Mito (US)
VlnPlot(object = US.seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))
dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_US.pdf")
dev.off()

# Mito (US)
VlnPlot(US.seurat, features = "percent.mito", y.max = 20)
dev.copy(pdf, "output/QC/QC_RNA_percentMito_US.pdf")
dev.off()

# nFeature & nCount & Mito (Stim)
VlnPlot(object = Stim.seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))
dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Stim.pdf")
dev.off()

# Mito (Stim)
VlnPlot(Stim.seurat, features = "percent.mito", y.max = 20)
dev.copy(pdf, "output/QC/QC_RNA_percentMito_Stim.pdf")
dev.off()



########################################
# Count vs Mito & Count vs Feature
########################################

# Unstimulated
plot1 <- FeatureScatter(US.seurat, feature1 = "nCount_RNA", feature2 = "percent.mito")
plot2 <- FeatureScatter(US.seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(plot1, plot2))
dev.copy(pdf, "output/QC/QC_RNA_percentMito_nCount_nFeature_corr_US.pdf")
dev.off()

# Stimulated
plot1 <- FeatureScatter(Stim.seurat, feature1 = "nCount_RNA", feature2 = "percent.mito")
plot2 <- FeatureScatter(Stim.seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(plot1, plot2))
dev.copy(pdf, "output/QC/QC_RNA_percentMito_nCount_nFeature_corr_Stim.pdf")
dev.off()


############################
# Structure and metadata 
############################

# Unstimulated
head(US.seurat@meta.data)
str(US.seurat@meta.data)

# Stimulated
head(Stim.seurat@meta.data)
str(Stim.seurat@meta.data)

###################
#  Filter cells
###################

# Seurat recommends removing cells with <200 or >2,500 genes or >10% mito genes

# Unstimulated
US.seurat.filt <- subset(US.seurat,
                         subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mito < 10)


# Post-filtering metrics

US.seurat # 15,429 genes across 6,584 cells
US.seurat.filt # 15,429 genes across 5,785 cells

# Therefore
6584 - 5785
# 799 cells were deleted

# Stimulated
Stim.seurat.filt <- subset(Stim.seurat,
                           subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mito < 10)

# Post-filtering metrics

Stim.seurat # 15,618 genes across 7,167 cells
Stim.seurat.filt # 15,618 genes across 6,042 cells

# Therefore
7167 - 6042
# 1125 cells were deleted


##########################################
# Visualise QC metrics after filtering
##########################################

# Unstimulated

# Before Filtering
VlnPlot(object = US.seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))

# After filtering
VlnPlot(object = US.seurat.filt, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))
dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Post_filtering_US.pdf")
dev.off()

# Stimulated

# Before Filtering
VlnPlot(object = Stim.seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))

# After filtering
VlnPlot(object = Stim.seurat.filt, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))
dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Post_filtering_Stim.pdf")
dev.off()



################################################
# Normalise, scale & find variable genes 
################################################

#################
# Unstimulated
#################

# Normalise
US.seurat.filt <- NormalizeData(
  object = US.seurat.filt,
  assay = "RNA",
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  verbose = TRUE
)

# Find variable genes
US.seurat.filt <- FindVariableFeatures(
  object = US.seurat.filt,
  verbose = TRUE
)

# Scale data
US.seurat.filt <- ScaleData(
  object = US.seurat.filt,
  assay = "RNA",
  vars.to.regress = c("nCount_RNA", "percent.mito"),
  model.use = "linear",
  do.scale = TRUE,
  do.center = TRUE,
  verbose = TRUE
)

#################
# Stimulated
#################

# Normalise
Stim.seurat.filt <- NormalizeData(
  object = Stim.seurat.filt,
  assay = "RNA",
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  verbose = TRUE
)

# Find variable genes
Stim.seurat.filt <- FindVariableFeatures(
  object = Stim.seurat.filt,
  verbose = TRUE
)

# Scale data
Stim.seurat.filt <- ScaleData(
  object = Stim.seurat.filt,
  assay = "RNA",
  vars.to.regress = c("nCount_RNA", "percent.mito"),
  model.use = "linear",
  do.scale = TRUE,
  do.center = TRUE,
  verbose = TRUE
)


###############################
# Remove unneeded variables
###############################

rm(US.seurat, Stim.seurat)


```

## Combine treatment conditions {.tabset}

### Integrate data
```{r Integrate_across_conditions}

# Set activate assay to RNA
DefaultAssay(US.seurat.filt) <- "RNA"
DefaultAssay(Stim.seurat.filt) <- "RNA"

# Create list of seurat objects
seurat.list <- list(US = US.seurat.filt, Stim = Stim.seurat.filt)

# Find Integration Anchors
immune.anchors <- FindIntegrationAnchors(object.list = seurat.list, 
                                         anchor.features = 2000, 
                                         scale = TRUE, 
                                         normalization.method = "LogNormalize", 
                                         reduction = "cca", 
                                         l2.norm = TRUE,
                                         dims = 1:30,
                                         k.anchor = 5,
                                         k.filter = 200,
                                         k.score = 30,
                                         max.features = 200,
                                         nn.method = "rann",
                                         eps = 0,
                                         verbose = TRUE)

# Integrate dataset
seurat.combined <- IntegrateData(anchorset = immune.anchors,
                                 new.assay.name = "integrated",
                                 normalization.method = "LogNormalize",
                                 dims = 1:30,
                                 k.weight = 100,
                                 sd.weight = 1,
                                 verbose = TRUE)


# Basic overview of data
seurat.combined # 11,827 cells and 18,295 genes 

US.seurat.filt # 5,785 cells
Stim.seurat.filt # 6,042 cells


# Save files 
saveRDS(US.seurat.filt, file = "Exported_RDS_files/US_seurat_filt.rds")
saveRDS(Stim.seurat.filt, file = "Exported_RDS_files/Stim_seurat_filt.rds")

# Remove unnecessary data
rm(US.seurat.filt)
rm(Stim.seurat.filt)


# Format metadata in integrated seurat object
seurat.combined@meta.data$condition <- factor(seurat.combined@meta.data$condition, levels = c("US", "Stim"))



```

## Clustering and dim reduction {.tabset}

### PCA and cluster identificaton
```{r Cluster_data}

DefaultAssay(seurat.combined) <- "integrated"

# Scale data
seurat.combined <- ScaleData(seurat.combined, 
                             verbose = TRUE)

# Run PCA
seurat.combined <- RunPCA(seurat.combined, 
                          npcs = 30, 
                          verbose = TRUE)

# Find Neighbors
seurat.combined <- FindNeighbors(seurat.combined, 
                                 reduction = "pca", 
                                 k.param = 20,
                                 dims = 1:20)

# Find clusters
seurat.combined <- FindClusters(seurat.combined, 
                                random.seed = 42,
                                resolution = 0.4) # 0.4 is cluster resolution decided upon


```

### Run UMAP
```{r UMAP}

# Create output directory
if(!dir.exists("output/figures/UMAP_no_clusts_removed")){
  dir.create("output/figures/UMAP_no_clusts_removed", 
             recursive = T)
}


# Run UMAP
seurat.combined <- RunUMAP(object = seurat.combined,
                           reduction = "pca",
                           dims = 1:20,
                           umap.method = "uwot",
                           n.neighbors = 30, # 5 to 50
                           min.dist = 0.3, # Sensible values are in the range 0.001 to 0.5
                           seed.use = 42)


# Plot UMAP projection
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + ggtitle("Integrated (n.neigh = 30 & min.dist = 0.3)")

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_clusts_clust.pdf")
dev.off()



# UMAP projection grouped by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         cols = Condition.cols,
         group.by = "condition") + ggtitle("UMAP vis by Condition") 

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_condition.pdf")
dev.off()



p1 <- DimPlot(seurat.combined, 
              reduction = "umap", 
              cols = Condition.cols,
              group.by = "condition")

p2 <- DimPlot(seurat.combined, 
              reduction = "umap", 
              label = TRUE)

p1|p2

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_clusters_conditions_sidebyside.pdf")
dev.off()


```

## Remove uninformative clusters {.tabset}

### Visualise and justify removing clusters 
```{r Justify_clusts_to_remove}

# Based on resolution of 0.4 for cluster identification 
# Cluster #15 and 13 are to be removed 
# 15 = Myeloid population 
# 13 = ?? 


# Create output directory
if(!dir.exists("output/figures/Cluster_removal_validation")){
  dir.create("output/figures/Cluster_removal_validation", 
             recursive = T)
}


# Show overall number and frequency of clusters

x <- table(seurat.combined@meta.data$seurat_clusters)
y <- prop.table(table(seurat.combined@meta.data$seurat_clusters))*100

barplot(x, 
        main = "# of cells per cluster", 
        xlab = "Cluster #", 
        ylab = "# of cells",
        cex.names = 0.8, 
        ylim = c(0, 2000))

dev.copy(pdf, "output/figures/Cluster_removal_validation/Number_cells_per_cluster.pdf")
dev.off()

barplot(y,
        main = "% of cells per cluster",
        xlab = "Cluster #",
        ylab = "% of cells",
        cex.names = 0.8, 
        ylim = c(0, 20))

dev.copy(pdf, "output/figures/Cluster_removal_validation/Percent_cells_per_cluster.pdf")
dev.off()


##########################################################################################
# Get differentially expressed genes for clusters to be removed and show heatmaps
##########################################################################################

# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

################
# Positive only
################

# Find markers for clust 13
Clust.13.Markers <- FindMarkers(seurat.combined,
                                assay = "RNA",
                                ident.1 = "13",
                                only.pos = TRUE,
                                min.diff.pct = 0.1,
                                return.thresh = 0.05)


# Find markers for clust 15
Clust.15.Markers <- FindMarkers(seurat.combined,
                                assay = "RNA",
                                ident.1 = "15",
                                only.pos = TRUE,
                                min.diff.pct = 0.1,
                                return.thresh = 0.05)

###################
# Heatmap vis
###################

# Downsample for heatmap vis
seurat.combined.small <- subset(seurat.combined, downsample = 300)

# Heatmap of Clust 13 markers
sig.genes <- Clust.13.Markers[Clust.13.Markers$p_val_adj < 0.1, ]




# Heatmap of Clust 15 markers
sig.genes <- Clust.15.Markers[Clust.15.Markers$p_val_adj < 0.1, ]








# Plot DEGs as heatmap for vis justification for removal


```

### Use Clustifyr to call cluster identities
```{r Clustifyr_cell_ID}

# Create output directories
if(!dir.exists("output/figures/Cell_type_annotation")){
  dir.create("output/figures/Cell_type_annotation", 
             recursive = T)
}

if(!dir.exists("output/figures/Cell_type_annotation/Clustifyr")){
  dir.create("output/figures/Cell_type_annotation/Clustifyr", 
             recursive = T)
}


#devtools::install_github("rnabioco/clustifyr")
library(clustifyr)

mouse.ref <- cbmc_ref
rownames(mouse.ref) <- str_to_title(rownames(mouse.ref))


res <- clustify(input = seurat.combined,
                cluster_col = "seurat_clusters",
                ref_mat = cbmc_ref,
                seurat_out = FALSE,
                query_genes = seurat.combined@assays$integrated@var.features)


res2 <- cor_to_call(cor_mat = res,                  # matrix correlation coefficients
                    cluster_col = "seurat_clusters") # name of column in meta.data containing cell clusters



print(plot_cor_heatmap(cor_mat = res))
dev.copy(pdf, "output/figures/Cell_type_annotation/Clustifyr/Heatmap_cluster_annotations.pdf")
dev.off()


```

### Use various SingleR databases to call cluster identities
```{r SingleR_cell_clasification}

# Create output directory
if(!dir.exists("output/figures/Cell_type_annotation")){
  dir.create("output/figures/Cell_type_annotation", 
             recursive = T)
}

if(!dir.exists("output/figures/Cell_type_annotation/SingleR")){
  dir.create("output/figures/Cell_type_annotation/SingleR", 
             recursive = T)
}

# Load package
#BiocManager::install("SingleR")
library(SingleR)

################################################################
# Use a couple databased to get broad overview of clusters 
################################################################

##################################
# Use HumanPrimaryCellAtlasData
##################################
# Info: Human, Microarray, 713 samples, 37 main labels, 157 fine lables, Non-specific focus

HumanPrimaryCellAtlasData.data <- HumanPrimaryCellAtlasData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = HumanPrimaryCellAtlasData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = HumanPrimaryCellAtlasData.data$label.fine)

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_HumanPrimaryCellAtlasData_db.pdf")
dev.off()

##########################
# Use BlueprintEncodeData
##########################
# Info: Human, RNAseq, 259 samples, 24 main labels, 43 fine lables, Non-specific focus

BlueprintEncodeData.data <- BlueprintEncodeData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = BlueprintEncodeData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = BlueprintEncodeData.data$label.fine)

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_BlueprintEncodeData_db.pdf")
dev.off()

##########################################
# Use NovershternHematopoieticData
##########################################
# Info: Human, Microarray, 211 samples, 17 main labels, 38 fine lables, Hematopoietic & Immune focus

NovershternHematopoieticData.data <- NovershternHematopoieticData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = NovershternHematopoieticData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = NovershternHematopoieticData.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_NovershternHematopoietic_db.pdf")
dev.off()

#####################
# Use ImmGenData
#####################
# Info: Mouse, Microarray, 830 samples, 20 main labels, 253 fine lables, Hematopoietic & Immune focus

ImmGen.data <- ImmGenData()

# Convert GeneID to match human
ImmGen.data.counts <- ImmGen.data@assays@data$logcounts
rownames(ImmGen.data.counts) <- toupper(rownames(ImmGen.data.counts))


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = ImmGen.data.counts, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = ImmGen.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_ImmGen_db.pdf")
dev.off()




################################################################
# Most useful database is probably the MonacoImmuneData
################################################################

#########################
# Use MonacoImmuneData
#########################
# Info: Human, RNAseq, 114 samples, 11 main labels, 29 fine lables, Immune cell focus
Immune.data <- MonacoImmuneData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = Immune.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = Immune.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_Monaco_db.pdf")
dev.off()


# Restrict labels to biologicaly relevant 
Immune.data.counts <- Immune.data@assays@data$logcounts

pattern <- c("CD8", "MAIT", "gd", "Intermediate")

labels.keep <- grepl(paste0(pattern, collapse = "|"), Immune.data$label.fine)

Immune.data.counts <- Immune.data.counts[,labels.keep]

SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = Immune.data.counts, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = Immune.data$label.fine[labels.keep])

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_limited_labels_Monaco_db.pdf")
dev.off()


```

### Myeloid and Mitochondrial populations
```{r Remove_clusters}

# Remove cluster 13 and 15
seurat.combined <- subset(seurat.combined, idents = c(0:12, 14))

# Check clusters are removed
levels(seurat.combined@meta.data$seurat_clusters)

# Save old cluster IDs
seurat.combined@meta.data$seurat_clusters_old <- seurat.combined@meta.data$seurat_clusters


```

## Recalculate UMAP and Visualise {.tabset}

### Recalculate UMAP
```{r Recalculate_UMAP}

###########################
# Recalculate UMAP
###########################

DefaultAssay(seurat.combined) <- "integrated"

# Scale data
seurat.combined <- ScaleData(seurat.combined, 
                             verbose = TRUE)

# Run PCA
seurat.combined <- RunPCA(seurat.combined, 
                          npcs = 30, 
                          verbose = TRUE)

# Find Neighbors
seurat.combined <- FindNeighbors(seurat.combined, 
                                 reduction = "pca", 
                                 k.param = 20,
                                 dims = 1:20)

# Find clusters
seurat.combined <- FindClusters(seurat.combined, 
                                random.seed = 42,
                                resolution = 0.4)


# Run UMAP
seurat.combined <- RunUMAP(object = seurat.combined,
                           reduction = "pca",
                           dims = 1:20,
                           umap.method = "uwot",
                           n.neighbors = 30, # 5 to 50
                           min.dist = 0.3, # Sensible values are in the range 0.001 to 0.5
                           seed.use = 42)

```

### Vis new UMAP
```{r Visualise_new_UMAP_projection}

# Create output directory
if(!dir.exists("output/figures/UMAP")){
  dir.create("output/figures/UMAP", 
             recursive = T)
}


Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters_new

# Plot UMAP projection
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + 
  ggtitle("UMAP new projection and clust IDs")

dev.copy(pdf, "output/figures/UMAP/UMAP_new_clust_IDs_numbered.pdf")
dev.off()

# Plot UMAP projection with old clust IDs
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters_old

UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + 
  ggtitle("UMAP new projection - original clust IDs")

dev.copy(pdf, "output/figures/UMAP/UMAP_original_clust_IDs_numbered.pdf")
dev.off()

```

### Rename clusters
```{r rename_clusters}

# Name clusters

# Save cluster IDs - new ids = those after removal of clusters
seurat.combined@meta.data$seurat_clusters_new <- seurat.combined@meta.data$seurat_clusters

# Set Idents to cluster IDs following cluster removal 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Rename classes.
seurat.combined <- RenameIdents(object = seurat.combined,
                                `0` = "Cytotoxic",
                                `1` = "Naive_like_3",
                                `2` = "Exhausted_1", 
                                `3` = "Type_I_IFN",
                                `4` = "Naive_like_1_CM", # Central memory?
                                `5` = "Naive_like_2_SC", # Stem-cell-like
                                `6` = "Stimulated_1", # Derived from cytotoxic ?
                                `7` = "Stimulated_exhausted",
                                `8` = "gd_T_non_g9d2", 
                                `9` = "Exhausted_2",
                                `10` = "MAIT", 
                                `11` = "TRM", 
                                `12` = "gd_T_g9d2", 
                                `13` = "Proliferative")


# Relevel idents variable to group clusters into order of future modules 

# Module: Naive / Stem-like 
# Naïve_like_1_CM
# Naïve_like_2_SC
# Naïve_like_3

# Module: Activated
# Cytotoxic
# Type_I_IFN
# Stimulated_1

# Module: Exhaustion
# Stimulated_exhausted
# Exhausted_1, 
# Exhausted_2
# TRM

# Module: Innate
# gd_T_g9d2
# gd_T_non_g9d2 
# MAIT 

# Module: Cycling
# Proliferative


# reset levels of factor variable 
seurat.combined@active.ident <- factor(seurat.combined@active.ident, 
                                       levels = c("Naive_like_1_CM",
                                                  "Naive_like_2_SC", 
                                                  "Naive_like_3", 
                                                  "Cytotoxic",
                                                  "Type_I_IFN",
                                                  "Stimulated_1",
                                                  "Stimulated_exhausted",
                                                  "Exhausted_1",
                                                  "Exhausted_2", 
                                                  "TRM", 
                                                  "gd_T_g9d2", 
                                                  "gd_T_non_g9d2", 
                                                  "MAIT",
                                                  "Proliferative"))



# Change "seurat_clusters" metadata label to new ident names as this slot is used in downstream plotting
seurat.combined@meta.data$seurat_clusters <- Idents(seurat.combined)

```

### UMAP with Named clusters
```{r Vis_Named_Clusters_UMAP}

# Create output directory
if(!dir.exists("output/figures/UMAP")){
  dir.create("output/figures/UMAP", 
             recursive = T)
}


##########################################
# Plot UMAPs with cluster names
##########################################


Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# UMAP named clusters
UMAPPlot(object = seurat.combined,
         pt.size = 1,
         label = FALSE, 
         cols = clust.cols) + 
  ggtitle("UMAP named clusters")

dev.copy(pdf, "output/figures/UMAP/UMAP_clusters.pdf")
dev.off()

# UMAP named clusters - labeled 
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         pt.size = 1,
         label.size = 6,
         cols = clust.cols) + 
  NoLegend() +
  ggtitle("UMAP named clusters")

dev.copy(pdf, "output/figures/UMAP/UMAP_clusters_labeled.pdf")
dev.off()


#############
# Condition
#############

# Split by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "condition",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by condition")

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_conditions.pdf")
dev.off()

# Split by condition // No legend
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "condition",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by condition") + 
  NoLegend()

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_conditions_Nolegend.pdf")
dev.off()

# Group by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         group.by = "condition",
         cols = Condition.cols,
         label.size = 6) + 
  ggtitle("UMAP group by condition")

dev.copy(pdf, "output/figures/UMAP/UMAP_groupby_conditions.pdf")
dev.off()


#############
# Sample
#############

# Split by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "group",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by Sample")

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_sample.pdf")
dev.off()


# Group by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         group.by = "group",
         pt.size = 1,
         label.size = 6) + 
  ggtitle("UMAP group by Sample")

dev.copy(pdf, "output/figures/UMAP/UMAP_groupby_sample.pdf")
dev.off()







```

### Saving dim reduction Embeddings to metadata
```{r Save_dimreduction_embeddings}

# UMAP embeddings
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$umap@cell.embeddings[,1], "UMAP_1")
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$umap@cell.embeddings[,2], "UMAP_2")

# Save PCA (Dim 1 and 2) embeddings
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$pca@cell.embeddings[,1], "PCA_1")
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$pca@cell.embeddings[,2], "PCA_2")

head(seurat.combined@meta.data)

```

## Group clusters into modules {.tabset}

### Create Modules
```{r Create_modules}

# Create output directory
if(!dir.exists("output/figures/Modules")){
  dir.create("output/figures/Modules", 
             recursive = T)
}


# Group clusters together into functional modules 
# Module aggregation based on visualisation and analysis of DEGs in each cluster 


# Use numeric cluster IDs followin myeloid and mitochondrial cluster removal 
# use numeric ids as allows easy changing of cluster names without impacting module creation

# Exhaustion module
# 2, 7, 9, 11 (NB 11 is likely Tissue_resident)

# Activated
# 0, 3, 6

# Innate
# 8, 10, 12

# Naive / Stem-like 
# 1, 4, 5

# Cycling
# 13


# Get cluster IDs
Module.groups <- seurat.combined@meta.data$seurat_clusters_new
Module.groups <- as.numeric(as.character(Module.groups)) # need to remove factorisation

#######################################################
# Assign cluster IDs to module groups // use ^ and $ start and end anchors to create exact match, exclude selecting 11 for grep("1") etc
#######################################################

# Exhaustion Module \\ 2, 7, 9, 11
logic.vec <- grepl(paste0(c("^2$", "^7$", "^9$", "^11$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Exhaustion"

# Activated Module \\ 0, 3, 6
logic.vec <- grepl(paste0(c("^0$", "^3$", "^6$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Activated"

# Innate Module \\ 8, 10, 12
logic.vec <- grepl(paste0(c("^8$", "^10$", "^12$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Innate"

# Naive/Stem-like Module \\ 1, 4, 5
logic.vec <- grepl(paste0(c("^1$", "^4$", "^5$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Naive_Stem"

# Cycling Module \\ 13
logic.vec <- grepl("^13$", Module.groups)
Module.groups[logic.vec] <- "Cycling"


# Assign Module groups to metadata
seurat.combined@meta.data$Module <- factor(Module.groups,
                                           levels = c("Naive_Stem",
                                                      "Activated", 
                                                      "Exhaustion", 
                                                      "Innate", 
                                                      "Cycling"))


##############################
# UMAP vis of module grouping
##############################

# Plot clusters
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

p1 <- UMAPPlot(object = seurat.combined,
               label = TRUE, 
               pt.size = 1,
               label.size = 6) + 
  NoLegend() +
  ggtitle("Clusters")


# Plot modules
Idents(seurat.combined) <- seurat.combined@meta.data$Module

p2 <- UMAPPlot(object = seurat.combined,
               label = FALSE, 
               pt.size = 1,
               label.size = 6) + 
  ggtitle("Modules")


# Plot side by side
p1|p2


dev.copy(pdf, "output/figures/Modules/UMAP_Clusts_to_Modules.pdf")
dev.off()

```

### Create Cluster/Module by condition metadata
```{r Generate_metadata_for_Cluster_Module_by_Condition}

######################################################
# Create additional Metadata for downstream analysis
######################################################
# Now that clusters are cleaned and renamed 
# Generate a joint cluster/Module & condition_ID variable

# Using named clusters
seurat.combined@meta.data$condition_clust <- paste(seurat.combined@meta.data$condition, 
                                                   seurat.combined@meta.data$seurat_clusters, sep = "_")

# Using numeric cluster IDs
seurat.combined@meta.data$condition_clust_numeric <- paste(seurat.combined@meta.data$condition, 
                                                           seurat.combined@meta.data$seurat_clusters_new, sep = "_")

# Condition & Module variable
seurat.combined@meta.data$condition_module <- paste(seurat.combined@meta.data$condition, 
                                                    seurat.combined@meta.data$Module, sep = "_")


```

### Vis overview of Modules
```{r Visualise_modules}

# Create output directory
if(!dir.exists("output/figures/Modules")){
  dir.create("output/figures/Modules", 
             recursive = T)
}

#########################################
# Vis distribution of modules in UMAPs
#########################################

Idents(seurat.combined) <- seurat.combined@meta.data$Module


# Modules
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         label.size = 6, 
         cols = module.cols) + 
  ggtitle("Modules")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules.pdf")
dev.off()

# Modules No legend
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         pt.size = 1,
         label.size = 6,
         cols = module.cols) + 
  NoLegend() +
  ggtitle("Modules")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_labelled.pdf")
dev.off()

##########
# Sample
##########

# Split by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "group",
         label.size = 6,
         cols = module.cols) + 
  ggtitle("UMAP Modules split by sample")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_splitby_sample.pdf")
dev.off()


# Grouped by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         group.by = "group",
         label.size = 6) + 
  ggtitle("UMAP Modules group by sample")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_groupby_sample.pdf")
dev.off()

##############
# Condition
##############

# Split by Condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "condition",
         label.size = 6,
         cols = module.cols) + 
  ggtitle("UMAP Modules split by Condition")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_splitby_condition.pdf")
dev.off()

# group by Condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         group.by = "condition",
         cols = Condition.cols,
         label.size = 6) + 
  ggtitle("UMAP Modules group by Condition")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_groupby_condition.pdf")
dev.off()

```


## Export large data {.tabset}

### Export seurat object
```{r export_RDS}
if(!quick.load){
  saveRDS(seurat.combined, file = "Exported_RDS_files/seurat_combined_no_imputation.rds")
}

```

### Save large data tables
```{r write_data, eval = FALSE}

if(long.compute){
  
  
  # Create output directory
  if(!dir.exists("output/tables/Large_dataframes")){
    dir.create("output/tables/Large_dataframes", 
               recursive = T)
  }
  
  
  save.data.frame.function <- function(df, title){
    
    x <- as.data.frame(as.matrix(df))
    
    write.table(x, 
                paste0("output/tables/Large_dataframes/", title, ".txt"),
                sep = "\t",
                quote = FALSE)
  }
  
  # Raw data
  save.data.frame.function(seurat.combined@assays$RNA@counts, "Raw_dataframe")
  
  # Normed data
  save.data.frame.function(seurat.combined@assays$RNA@data, "filtered_dataframe")
  
  # Scaled data
  save.data.frame.function(seurat.combined@assays$RNA@scale.data, "scaled_dataframe")
  
  # PCA embeddings
  save.data.frame.function(seurat.combined@reductions$pca@cell.embeddings, "RNA_PCA")
  
  # UMAP embeddings
  save.data.frame.function(seurat.combined@reductions$umap@cell.embeddings, "RNA_UMAP")
  
  # Metadata
  save.data.frame.function(seurat.combined@meta.data, "Meta_data_dataframe")
  
  # Integrated normed values
  save.data.frame.function(seurat.combined@assays$integrated@data, "filtered_integrated_dataframe")
  
  # Integrated scaled data
  save.data.frame.function(seurat.combined@assays$integrated@scale.data, "scaled_integrated_dataframe")
  
}

```


## Imputation {.tabset}

### Imputation calculation
```{r seurat_imputation}


######################
# Impute values 
######################
if(long.compute){
  seurat.combined <- RunALRA(seurat.combined, 
                             genes.use = rownames(seurat.combined))
}

# 8.37% of the values became negative in the scaling process and were set to zero
# The matrix went from 29.63% nonzero to 38.95% nonzero


####################
# Calculate k value
####################
if(long.compute){
  
  Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
  seurat.combined.small <- subset(seurat.combined, downsample = 100)
  
  ALRA.out <- RunALRA(seurat.combined.small,
                      k.only = TRUE)
  
  ggouts <- ALRAChooseKPlot(ALRA.out)
  
  ggouts
  dev.copy(pdf, "output/QC/Imputation_K_plot.pdf")
  dev.off()
}


# set default assay back to RNA
DefaultAssay(seurat.combined) <- "RNA"


```


## Export large data after imputation {.tabset}

### Export seurat object with imputation
```{r export_RDS}
if(!quick.load){
  saveRDS(seurat.combined, file = "Exported_RDS_files/seurat_combined.rds")
}

if(long.compute){
  
  
  # Create output directory
  if(!dir.exists("output/tables/Large_dataframes")){
    dir.create("output/tables/Large_dataframes", 
               recursive = T)
  }
  
  
  save.data.frame.function <- function(df, title){
    
    x <- as.data.frame(as.matrix(df))
    
    write.table(x, 
                paste0("output/tables/Large_dataframes/", title, ".txt"),
                sep = "\t",
                quote = FALSE)
  }
  
  # Imputed values
  save.data.frame.function(seurat.combined@assays$alra@counts, "Imputed_counts_dataframe")
  
}


```



## Visualise distribution of cells across clusters/condition/modules {.tabset}

### Plot distribution of cells per each cluster 
```{r Distribution_cells_per_cluster}

# Create output directory
if(!dir.exists("output/figures/Clust_and_Module_distribution")){
  dir.create("output/figures/Clust_and_Module_distribution", 
             recursive = T)
}

################################
# Plot cluster wise distribution
################################
default.mar <- par()$mar

par(mar = c(10.1, 5.1, 4.1, 2.1))


# Number of cells 
x <- table(seurat.combined@meta.data$seurat_clusters)

barplot(t(x), 
        main = "Number of cells per clust",
        ylab = "Number of cells",
        cex.names = 1,
        las = 2,
        ylim = c(0, 2500),
        legend = TRUE, 
        beside = TRUE)


dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Number_cells_per_clust.pdf")
dev.off()

# Frequency 
x <- prop.table(table(seurat.combined@meta.data$seurat_clusters)) * 100

barplot(t(x), 
        main = "Freq of cells per clust",
        ylab = "% of total",
        cex.names = 1, 
        las = 2,
        ylim = c(0, 20),
        legend = TRUE, 
        beside = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Freq_cells_per_clust.pdf")
dev.off()



###################################################
# Plot Freq per cluster per condition 
###################################################

# Be aware, US and Stim have diff total number of cells and therefore should be represented as a % normalised to total condition cell #

condition.cell.n <- table(seurat.combined@meta.data$condition)
US.cell.n <- condition.cell.n[1]
Stim.cell.n <- condition.cell.n[2]

Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
Cluster.cell.n <- table(Idents(seurat.combined), seurat.combined@meta.data$condition)

Cluster.cell.n[,1] <- Cluster.cell.n[,1]/US.cell.n*100
Cluster.cell.n[,2] <- Cluster.cell.n[,2]/Stim.cell.n*100

colSums(Cluster.cell.n) # sanity check, both should = 100%

barplot(t(Cluster.cell.n),
        main = "% of cells per cluster per condition",
        ylab = "% of cells",
        col = Condition.cols,
        cex.names = 1, 
        las = 2,
        ylim = c(0, 30), 
        beside = TRUE, 
        legend = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_cluster_per_condition.pdf")
dev.off()


# reset margin to default 
par(mar = c(default.mar))


#########################################
# Plot Module wise distribution
#########################################

# Plot total cell # per module 

Module.cell.n <- table(seurat.combined@meta.data$Module)

barplot(Module.cell.n, 
        main = "# of cells per Module", 
        xlab = "Module", 
        ylab = "# of cells",
        cex.names = 0.8, 
        ylim = c(0, 5000))

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Number_cells_per_Module.pdf")
dev.off()


# Plot freq of total per module
Module.freq <- prop.table(table(seurat.combined@meta.data$Module))*100

barplot(Module.freq,
        main = "% of cells per Module",
        xlab = "Module",
        ylab = "% of cells",
        cex.names = 0.8, 
        ylim = c(0, 40))

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_Module.pdf")
dev.off()


###################################################
# Plot Freq per module per condition 
###################################################

# Be aware, US and Stim have diff total number of cells and therefore should be represented as a % normalised to total condition cell #

condition.cell.n <- table(seurat.combined@meta.data$condition)
US.cell.n <- condition.cell.n[1]
Stim.cell.n <- condition.cell.n[2]

Idents(seurat.combined) <- seurat.combined@meta.data$Module
Module.cell.n <- table(Idents(seurat.combined), seurat.combined@meta.data$condition)

Module.cell.n[,1] <- Module.cell.n[,1]/US.cell.n*100
Module.cell.n[,2] <- Module.cell.n[,2]/Stim.cell.n*100

colSums(Module.cell.n) # sanity check, both should = 100%


barplot(t(Module.cell.n),
        main = "% of cells per Module per condition",
        xlab = "Module",
        ylab = "% of cells",
        col = Condition.cols,
        cex.names = 0.8, 
        ylim = c(0, 50), 
        beside = TRUE, 
        legend = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_Module_per_condition.pdf")
dev.off()



```


## DEG analysis {.tabset}

### DEG between modules
```{r DEG_between_modules}

# Create output directory
if(!dir.exists("output/tables/DEG_Modules")){
  dir.create("output/tables/DEG_Modules", 
             recursive = T)
}

# Set Idents
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

################
# Pos DEGs
################

# Find markers
Module.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA",
                                 only.pos = TRUE,
                                 min.diff.pct = 0.1,
                                 return.thresh = 0.05)

# Write data to file
write.csv(Module.markers, "output/tables/DEG_Modules/Module_markers_unfiltered_pos.csv")

# Filter by sig Padj val
sum(Module.markers$p_val_adj < 0.05) # 772 genes 

write.csv(Module.markers[Module.markers$p_val_adj < 0.05, ], "output/tables/DEG_Modules/Module_markers_sig_only_pos.csv")


################
# Pos and Neg
################

# Find markers
Module.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA",
                                 only.pos = FALSE,
                                 min.diff.pct = 0.1,
                                 return.thresh = 0.05)

# Write data to file
write.csv(Module.markers, "output/tables/DEG_Modules/Module_markers_unfiltered.csv")

# Filter by sig Padj val
sum(Module.markers$p_val_adj < 0.05) 

write.csv(Module.markers[Module.markers$p_val_adj < 0.05, ], "output/tables/DEG_Modules/Module_markers_sig_only.csv")


################################################
# Extract the top markers for each module
################################################

# Get top markers for each module - use Positive markers only
sig.markers <- Module.markers[Module.markers$p_val_adj < 0.05, ]

Module.vect <- unique(Module.markers$cluster)

for(i in 1:length(Module.vect)){
  
  print(paste0("Getting markers for Module ", Module.vect[i]))
  
  input.df <- sig.markers[sig.markers$cluster == Module.vect[i], ]
  
  assign(paste0("Module_", Module.vect[i]), top_n(input.df, 40,  avg_logFC))
  
  x <- eval(parse(text = paste0("Module_", Module.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Modules/Top_40_markers_for_Module_", Module.vect[i], ".csv"))
  
}


```

### DEGs of modules between conditions
```{r DEGs_of_modules_between_conditions}


# Create output directories
if(!dir.exists("output/tables/DEG_Modules_btn_conditions")){
  dir.create("output/tables/DEG_Modules_btn_conditions", 
             recursive = T)
}


if(!dir.exists("output/figures/DEG_Modules_btn_conditions")){
  dir.create("output/figures/DEG_Modules_btn_conditions", 
             recursive = T)
}


# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

# Get vector of clusters
Module.vect <- seurat.combined@meta.data$Module
Module.vect <- levels(Module.vect)

for(i in 1:length(Module.vect)){
  
  print(paste0("Analysis for Module ", Module.vect[i]))
  
  # Set idents to the condition_cluster
  Idents(seurat.combined) <- seurat.combined@meta.data$condition_module
  
  # Calculating DEGs for each cluster across condition
  DEG.var <- FindMarkers(seurat.combined,
                         ident.1 = paste0("Stim_", Module.vect[i]), 
                         ident.2 = paste0("US_", Module.vect[i]),
                         test.use = "wilcox",
                         logfc.threshold = 0.25,
                         min.pct = 0.1,
                         only.pos = FALSE,
                         verbose = FALSE)
  
  # create column for gene ID
  DEG.var$gene <- rownames(DEG.var)
  
  # Write data to file
  write.csv(DEG.var, paste0("output/tables/DEG_Modules_btn_conditions/Stim_vs_US_DEG_module_", Module.vect[i], ".csv"))
  
  #########################################
  # Get top DEGs for clusters Stim vs. US
  #########################################
  
  print(paste0("Getting top markers for module ", Module.vect[i], " Stim vs. US"))
  
  sig.markers <- DEG.var[DEG.var$p_val_adj < 0.05, ]
  
  assign(paste0("Condition_Module_DEGs_", Module.vect[i]), top_n(sig.markers, 40,  avg_logFC))
  
  x <- eval(parse(text = paste0("Condition_Module_DEGs_", Module.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Modules_btn_conditions/Top_40_markers_for_Stim_vs_US_Module_", Module.vect[i], ".csv"))
  
  ############################################
  # plotting DEG per module across condition
  ############################################
  
  # Set idents to Module ID
  Idents(seurat.combined) <- seurat.combined@meta.data$Module
  
  # Subset for Module ID
  subset.seurat <- subset(seurat.combined, idents = paste0(Module.vect[i]))
  
  # Set idents to condition var
  Idents(subset.seurat) <- subset.seurat@meta.data$condition
  
  # Get top 10 genes
  # up-regulated genes
  genes.to.label.1 <- top_n(DEG.var, 10, avg_logFC)$gene
  
  # Down-regulated genes
  genes.to.label.2 <- top_n(DEG.var, -10, avg_logFC)$gene
  
  # Create vector of genes
  genes.to.label <- unique(c(genes.to.label.1, genes.to.label.2))
  
  # Average expression
  avg.subset.seurat <- log1p(AverageExpression(subset.seurat, verbose = FALSE)$RNA)
  
  # Create column with gene id 
  avg.subset.seurat$gene <- rownames(avg.subset.seurat)
  
  # Generate plot
  p1 <- ggplot(avg.subset.seurat, 
               aes(US, Stim)) + 
    geom_point() + 
    ggtitle(paste0("Module ", Module.vect[i]))
  
  p1 <-  LabelPoints(plot = p1,
                     points = genes.to.label,
                     repel = TRUE)
  
  print(plot(p1))
  dev.copy(pdf, paste0("output/figures/DEG_Modules_btn_conditions/ScatterPlot_Stim_vs_US_Module_", Module.vect[i], ".pdf"))
  dev.off()
  
  # Remove large variable
  rm(subset.seurat)
  rm(DEG.var)
  
}



```

### DEGs between clusters 
```{r DEGs_between_clusters}

# Create output directory
if(!dir.exists("output/tables/DEG_Clusters")){
  dir.create("output/tables/DEG_Clusters", 
             recursive = T)
}

# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

################
# Positive only
################

# Find markers
Cluster.markers.pos <- FindAllMarkers(seurat.combined,
                                      assay = "RNA",
                                      only.pos = TRUE,
                                      min.diff.pct = 0.1,
                                      return.thresh = 0.05)

# Write data to file
write.csv(Cluster.markers.pos, "output/tables/DEG_Clusters/Cluster_markers_unfiltered_pos.csv")

# Filter by sig Padj val
sum(Cluster.markers.pos$p_val_adj < 0.05) # 2,919 genes 

write.csv(Cluster.markers.pos[Cluster.markers.pos$p_val_adj < 0.05, ], "output/tables/DEG_Clusters/Cluster_markers_sig_only_pos.csv")


################
# Pos and Neg
################

# Find markers
Cluster.markers <- FindAllMarkers(seurat.combined,
                                  assay = "RNA",
                                  only.pos = FALSE,
                                  min.diff.pct = 0.1,
                                  return.thresh = 0.05)

# Write data to file
write.csv(Cluster.markers, "output/tables/DEG_Clusters/Cluster_markers_unfiltered.csv")

# Filter by sig Padj val
sum(Cluster.markers$p_val_adj < 0.05) # 4,890 genes 

write.csv(Cluster.markers[Cluster.markers$p_val_adj < 0.05, ], "output/tables/DEG_Clusters/Cluster_markers_sig_only.csv")


########################
# Get top markers
########################

# Get top markers for each cluster - use Positive markers only
sig.markers <- Cluster.markers.pos[Cluster.markers.pos$p_val_adj < 0.05, ]

Cluster.vect <- unique(sig.markers$cluster)

for(i in 1:length(Cluster.vect)){
  
  
  print(paste0("Getting markers for cluster ", Cluster.vect[i]))
  
  input.df <- sig.markers[sig.markers$cluster == Cluster.vect[i], ]
  
  assign(paste0("Cluster_", Cluster.vect[i]), top_n(input.df, 40,  avg_logFC))
  
  
  x <- eval(parse(text = paste0("Cluster_", Cluster.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Clusters/Top_40_markers_for_cluster_", Cluster.vect[i], ".csv"))
  
}


```

### DEGs of clusters between conditions
```{r DEGs_of_clusts_between_conditions}

# Create output directories
if(!dir.exists("output/tables/DEG_Clusters_btn_conditions")){
  dir.create("output/tables/DEG_Clusters_btn_conditions", 
             recursive = T)
}


if(!dir.exists("output/figures/DEG_Clusters_btn_conditions")){
  dir.create("output/figures/DEG_Clusters_btn_conditions", 
             recursive = T)
}


# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

# Get vector of clusters
clust.var <- seurat.combined@meta.data$seurat_clusters
clust.var <- levels(clust.var)

for(i in 1:length(clust.var)){
  
  print(paste0("Analysis for cluster ", clust.var[i]))
  
  # Set idents to the condition_cluster
  Idents(seurat.combined) <- seurat.combined@meta.data$condition_clust
  
  # Calculating DEGs for each cluster across condition
  DEG.var <- FindMarkers(seurat.combined,
                         ident.1 = paste0("Stim_", clust.var[i]), 
                         ident.2 = paste0("US_", clust.var[i]),
                         test.use = "wilcox",
                         logfc.threshold = 0.25,
                         min.pct = 0.1,
                         only.pos = FALSE,
                         verbose = FALSE)
  
  # create column for gene ID
  DEG.var$gene <- rownames(DEG.var)
  
  # Write data to file
  write.csv(DEG.var, paste0("output/tables/DEG_Clusters_btn_conditions/Stim_vs_US_DEG_clust_", clust.var[i], ".csv"))
  
  #########################################
  # Get top DEGs for clusters Stim vs. US
  #########################################
  
  print(paste0("Getting top markers for cluster ", Cluster.vect[i], " Stim vs. US"))
  
  sig.markers <- DEG.var[DEG.var$p_val_adj < 0.05, ]
  
  assign(paste0("Condition_Cluster_DEGs_", Cluster.vect[i]), top_n(sig.markers, 40,  avg_logFC))
  
  x <- eval(parse(text = paste0("Condition_Cluster_DEGs_", Cluster.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Clusters_btn_conditions/Top_40_markers_for_Stim_vs_US_cluster_", Cluster.vect[i], ".csv"))
  
  ############################################
  # plotting DEG per cluster across condition
  ############################################
  
  # Set idents to cluster ID
  Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
  
  # Subset for cluster ID
  subset.seurat <- subset(seurat.combined, idents = paste0(clust.var[i]))
  
  # Set idents to condition var
  Idents(subset.seurat) <- subset.seurat@meta.data$condition
  
  # Get top 10 genes
  # up-regulated genes
  genes.to.label.1 <- top_n(DEG.var, 10, avg_logFC)$gene
  
  # Down-regulated genes
  genes.to.label.2 <- top_n(DEG.var, -10, avg_logFC)$gene
  
  # Create vector of genes
  genes.to.label <- unique(c(genes.to.label.1, genes.to.label.2))
  
  # Average expression
  avg.subset.seurat <- log1p(AverageExpression(subset.seurat, verbose = FALSE)$RNA)
  
  # Create column with gene id 
  avg.subset.seurat$gene <- rownames(avg.subset.seurat)
  
  # Generate plot
  p1 <- ggplot(avg.subset.seurat, 
               aes(US, Stim)) + 
    geom_point() + 
    ggtitle(paste0("Cluster ", clust.var[i]))
  
  p1 <-  LabelPoints(plot = p1,
                     points = genes.to.label,
                     repel = TRUE)
  
  print(plot(p1))
  dev.copy(pdf, paste0("output/figures/DEG_Clusters_btn_conditions/ScatterPlot_Stim_vs_US_cluster_", clust.var[i], ".pdf"))
  dev.off()
  
  # Remove large variable
  rm(subset.seurat)
  rm(DEG.var)
  
}


```


## Visualise DEGs {.tabset}

### Heatmaps and dotplots of Module DEGs
```{r Heatmaps_and_dotplots_of_Module_DEGs}

# Output directory
# Heatmaps
if(!dir.exists("output/figures/Module_DEG_Heatmaps")){
  dir.create("output/figures/Module_DEG_Heatmaps", 
             recursive = T)
}

# Dotplots
if(!dir.exists("output/figures/Module_DEG_dotplots")){
  dir.create("output/figures/Module_DEG_dotplots", 
             recursive = T)
}



# Set assay to integrated
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)


# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)


################################################
# Visualise top markers for each Module
################################################
# as single cell heatmap, averaged heatmap, and dotplot


# get vector of Modules to iterate over
Module.vect <- unique(seurat.combined@meta.data$Module)


for(i in 1:length(Module.vect)){
  
  print(paste0("Evaluating Module = ", Module.vect[i]))
  
  x <- eval(parse(text = paste0("Module_", Module.vect[i])))
  
  # Single cell heatmap
  print(DoHeatmap(seurat.combined.small, 
                  features = x$gene, 
                  size = 4, 
                  angle = 0, 
                  hjust = 0.5,
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Module_DEG_Heatmaps/Heatmap_topDEGs_Module_", Module.vect[i], ".pdf"))
  dev.off()
  
  
  # Average expression heatmap
  print(DoHeatmap(average.seurat, 
                  features = x$gene, 
                  size = 4, 
                  angle = 0, 
                  draw.lines = FALSE,
                  hjust = 0.1,
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Module_DEG_Heatmaps/Heatmap_topDEGs_Module_", Module.vect[i], "_average.pdf"))
  dev.off()
  
  
  print(DotPlot(seurat.combined, 
                assay = "RNA",
                features = x$gene, 
                dot.scale = 8) + 
          RotatedAxis() +  
          theme(text = element_text(size = 4)) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Module_DEG_dotplots/DotPlot_TopDEGs_Module_", Module.vect[i], ".pdf"))
  dev.off()
  
  
}



```

### Curated Module heatmaps
```{r Curated_Module_heatmaps}

# Curated Module Heatmaps
if(!dir.exists("output/figures/Modules/Curated_Heatmaps")){
  dir.create("output/figures/Modules/Curated_Heatmaps", 
             recursive = T)
}

# Set assay to RNA
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)

#################################################
# Plot single cell heatmaps for curated goi
#################################################

# Exhaustion
Exhaustion.sig <- c("CD226", "LAG3", "TIGIT", 
                    "HAVCR2", "TCF7", "TOX",
                    "PDCD1", "IFNG", "GZMA",
                    "ENTPD1", "ICOS", "NKG7", 
                    "GZMB", "PRF1", "CTLA4",
                    "GNLY", "LAYN")

DoHeatmap(seurat.combined.small, 
          features = Exhaustion.sig, 
          size = 4, 
          angle = 0, 
          hjust = 0.5,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_Exhaustion_sig.pdf")
dev.off()


# Naive
Naive.sig <- c("CCR7", "SELL", "IL7R",
               "LTB", "LEF1", "TCF7")

# Stem-like 
Stem.sig <- c("FOSB", "PPP1R15A", "KLF6",
              "JUNB", "NFKBIA", "TCF7",
              "RELB", "CCR7", "CRTAM")

Naive.stem.sig <-unique(c(Naive.sig, Stem.sig))


DoHeatmap(seurat.combined.small, 
          features = Naive.stem.sig, 
          size = 4, 
          angle = 0, 
          hjust = 0.5,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_NaiveStem_sig.pdf")
dev.off()



########################
# Curated heatmaps 
########################

# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)


# Exhaustion
DoHeatmap(average.seurat, 
          features = Exhaustion.sig, 
          size = 4, 
          angle = 0, 
          draw.lines = FALSE,
          hjust = 0.1,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_Exhaustion_sig_Averaged.pdf")
dev.off()

# NaiveStem
DoHeatmap(average.seurat, 
          features = Naive.stem.sig, 
          size = 4, 
          angle = 0, 
          draw.lines = FALSE,
          hjust = 0.1,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_NaiveStem_sig_Averaged.pdf")
dev.off()


```

### Heatmaps and dotplots of Cluster DEGs
```{r Heatmaps_and_dotplots_of_Cluster_DEGs}

# Output directory
# Heatmaps
if(!dir.exists("output/figures/Cluster_DEG_Heatmaps")){
  dir.create("output/figures/Cluster_DEG_Heatmaps", 
             recursive = T)
}

# Dotplots
if(!dir.exists("output/figures/Cluster_DEG_dotplots")){
  dir.create("output/figures/Cluster_DEG_dotplots", 
             recursive = T)
}



# Set assay to RNA
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)


# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)


################################################
# Visualise top markers for each Cluster
################################################
# as single cell heatmap, averaged heatmap, and dotplot


# get vector of clusters to iterate over
Cluster.vect <- unique(seurat.combined.small@meta.data$seurat_clusters)


for(i in 1:length(Cluster.vect)){
  
  print(paste0("Evaluating cluster = ", Cluster.vect[i]))
  
  x <- eval(parse(text = paste0("Cluster_", Cluster.vect[i])))
  
  # Single cell heatmap
  print(DoHeatmap(seurat.combined.small, 
                  features = x$gene, 
                  size = 4, 
                  angle = 90, 
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Cluster_DEG_Heatmaps/Heatmap_topDEGs_clust_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Average expression heatmap
  print(DoHeatmap(average.seurat, 
                  features = x$gene, 
                  size = 4, 
                  angle = 90, 
                  draw.lines = FALSE,
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Cluster_DEG_Heatmaps/Heatmap_topDEGs_clust_", Cluster.vect[i], "_average.pdf"))
  dev.off()
  
  
  print(DotPlot(seurat.combined, 
                assay = "RNA",
                features = x$gene, 
                dot.scale = 8) + 
          RotatedAxis() +  
          theme(text = element_text(size = 4)) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Cluster_DEG_dotplots/DotPlot_TopDEGs_clust_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
}


```


### Large heatmaps of top DEGs by foldchange // Average and single cell
```{r Large_Heatmaps_of_top_DEGs}

# Output directory
if(!dir.exists("output/figures/Large_Summary_heatmaps")){
  dir.create("output/figures/Large_Summary_heatmaps", 
             recursive = T)
}


# Set assay to integrated
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)

# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)



###########################
# Get top overall DEGs
###########################

# Get top Module markers
sig.genes <- Module.markers[Module.markers$p_val_adj < 0.05, ]

clusts <- unique(sig.genes$cluster)
output.vect <- NA
top.n <- 100

for(i in 1:length(clusts)){
  
  temp.gene <- sig.genes[sig.genes$cluster == paste0(clusts[i]), ]
  temp.top <- top_n(temp.gene, top.n, avg_logFC)$gene
  
  output.vect <- c(output.vect, temp.top)
  output.vect <- unique(output.vect)
  
}


DoHeatmap(average.seurat, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_byModule_Averaged.pdf")
dev.off()

DoHeatmap(seurat.combined.small, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = TRUE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_byModule.pdf")
dev.off()




# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)

# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)



# Get top cluster markers
sig.genes <- Cluster.markers[Cluster.markers$p_val_adj < 0.05, ]

clusts <- unique(sig.genes$cluster)
output.vect <- NA
top.n <- 40

for(i in 1:length(clusts)){
  
  temp.gene <- sig.genes[sig.genes$cluster == paste0(clusts[i]), ]
  temp.top <- top_n(temp.gene, top.n, avg_logFC)$gene
  
  output.vect <- c(output.vect, temp.top)
  output.vect <- unique(output.vect)
}





DoHeatmap(average.seurat, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_bycluster_Averaged.pdf")
dev.off()

DoHeatmap(seurat.combined.small, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = TRUE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_bycluster.pdf")
dev.off()




```

### DEGs and selected genes Vlnplots || Modules & Clusters
```{r Vln_feature_plots}

# Create output directories
if(!dir.exists("output/figures/Top_DEG_plots")){
  dir.create("output/figures/Top_DEG_plots", 
             recursive = T)
}

if(!dir.exists("output/figures/Top_DEG_plots/Modules")){
  dir.create("output/figures/Top_DEG_plots/Modules", 
             recursive = T)
}

if(!dir.exists("output/figures/Top_DEG_plots/Clusters")){
  dir.create("output/figures/Top_DEG_plots/Clusters", 
             recursive = T)
}



# Set assay
DefaultAssay(seurat.combined) <- "RNA"



# Custom list of genes to plot


goi <- c("IFNG", "TNF", "ENTPD1",
         "PDCD1", "TIGIT", "LAYN", 
         "EOMES", "GZMA", "GZMB", 
         "GZMK", "CXCR3", "TOX",
         "CASZ1", "CD226", "CXCL13",
         "CD160", "TBX21",
         "TRBC1", "CD8A", "CD8B", 
         "CD4",
         "FOXP3", "IL2RA", "CTLA4", 
         "CD14", "LYZ", 
         "PRF1", "NKG7", "GNLY", 
         "FCGR3A",
         "KLRB1", "KLRC1", 
         "MKI67", 
         "KIT", 
         "HAVCR2", "LAG3", "TCF7",
         "ICOS", 
         "CCR7", "IL7R", "CD7", "CD69",  
         "ITGAX", "ITGAM", "IL3RA",
         "CD86", "CD83", "IL4I1")



################################################################
# Plot Feature plot and VlnPlot for top DEGs for modules
################################################################

# Generate vector of genes to plot
Top.module.genes <- unique(c(Module_Naive_Stem$gene,
                             Module_Activated$gene,
                             Module_Cycling$gene,
                             Module_Exhaustion$gene,
                             Module_Innate$gene))

# Add custom genes 
Top.module.genes <- unique(c(Top.module.genes, goi))

# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module


for(i in 1:length(Top.module.genes)){
  
  print(paste0("Plotting ", Top.module.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.module.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots/Modules/VlnPlot_", Top.module.genes[i], ".pdf"))
  dev.off()
  
  # Plot feature plot on UMAP projection
  print(FeaturePlot(seurat.combined,
                    features = Top.module.genes[i],
                    reduction = "umap") + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots/FeaturePlot_", Top.module.genes[i], ".pdf"))
  dev.off()
  
}


################################################################
# Plot Feature plot and VlnPlot for top DEGs for Clusters
################################################################


# Generate vector of genes to plot
Top.cluster.genes <- unique(c(Cluster_Cytotoxic$gene,
                              Cluster_Exhausted_1$gene,
                              Cluster_Exhausted_2$gene,
                              Cluster_gd_T_g9d2$gene,
                              Cluster_gd_T_non_g9d2$gene,
                              Cluster_MAIT$gene,
                              Cluster_Naïve_like_1_CM$gene,
                              Cluster_Naïve_like_2_SC$gene,
                              Cluster_Naïve_like_3$gene,
                              Cluster_Proliferative$gene,
                              Cluster_Stimulated_1$gene,
                              Cluster_Stimulated_exhausted$gene,
                              Cluster_TRM$gene,
                              Cluster_Type_I_IFN$gene))



# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Add custom genes 
Top.cluster.genes <- unique(c(Top.cluster.genes, goi))

for(i in 1:length(Top.cluster.genes)){
  
  print(paste0("Plotting ", Top.cluster.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.cluster.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots/Clusters/VlnPlot_", Top.cluster.genes[i], ".pdf"))
  dev.off()
  
  # If gene is already in top.module.gene list this will have already been plotted
  if(Top.cluster.genes[i] %in% Top.module.genes){
    next()
  }else{
    # Plot feature plot on UMAP projection
    print(FeaturePlot(seurat.combined,
                      features = Top.cluster.genes[i],
                      reduction = "umap") + 
            NoLegend())
    
    dev.copy(pdf, paste0("output/figures/Top_DEG_plots/FeaturePlot_", Top.cluster.genes[i], ".pdf"))
    dev.off()
  }
  
}




```

### DEGs and selected genes Vlnplots || Modules & Clusters || Imputed
```{r Vln_feature_plots}

# Create output directories
if(!dir.exists("output/figures/Top_DEG_plots_Imputed")){
  dir.create("output/figures/Top_DEG_plots_Imputed", 
             recursive = T)
}

if(!dir.exists("output/figures/Top_DEG_plots_Imputed/Modules")){
  dir.create("output/figures/Top_DEG_plots_Imputed/Modules", 
             recursive = T)
}

if(!dir.exists("output/figures/Top_DEG_plots_Imputed/Clusters")){
  dir.create("output/figures/Top_DEG_plots_Imputed/Clusters", 
             recursive = T)
}



# Set assay
DefaultAssay(seurat.combined) <- "alra"



# Custom list of genes to plot


goi <- c("IFNG", "TNF", "ENTPD1",
         "PDCD1", "TIGIT", "LAYN", 
         "EOMES", "GZMA", "GZMB", 
         "GZMK", "CXCR3", "TOX",
         "CASZ1", "CD226", "CXCL13",
         "CD160", "TBX21",
         "TRBC1", "CD8A", "CD8B", 
         "CD4",
         "FOXP3", "IL2RA", "CTLA4", 
         "CD14", "LYZ", 
         "PRF1", "NKG7", "GNLY", 
         "FCGR3A",
         "KLRB1", "KLRC1", 
         "MKI67", 
         "KIT", 
         "HAVCR2", "LAG3", "TCF7",
         "ICOS", 
         "CCR7", "IL7R", "CD7", "CD69",  
         "ITGAX", "ITGAM", "IL3RA",
         "CD86", "CD83", "IL4I1")



################################################################
# Plot Feature plot and VlnPlot for top DEGs for modules
################################################################

# Generate vector of genes to plot
Top.module.genes <- unique(c(Module_Naive_Stem$gene,
                             Module_Activated$gene,
                             Module_Exhaustion$gene,
                             Module_Innate$gene,
                             Module_Cycling$gene))

# Add custom genes 
Top.module.genes <- unique(c(Top.module.genes, goi))

# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module


for(i in 1:length(Top.module.genes)){
  
  print(paste0("Plotting ", Top.module.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.module.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/Modules/VlnPlot_", Top.module.genes[i], "_imputed.pdf"))
  dev.off()
  
  # Plot feature plot on UMAP projection
  print(FeaturePlot(seurat.combined,
                    features = Top.module.genes[i],
                    reduction = "umap") + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/FeaturePlot_", Top.module.genes[i], "_imputed.pdf"))
  dev.off()
  
}


################################################################
# Plot Feature plot and VlnPlot for top DEGs for Clusters
################################################################


# Generate vector of genes to plot
Top.cluster.genes <- unique(c(Cluster_Naïve_like_1_CM$gene,
                              Cluster_Naïve_like_2_SC$gene,
                              Cluster_Naïve_like_3$gene,
                              Cluster_Cytotoxic$gene,
                              Cluster_Type_I_IFN$gene,
                              Cluster_Stimulated_1$gene,
                              Cluster_Stimulated_exhausted$gene,
                              Cluster_Exhausted_1$gene,
                              Cluster_Exhausted_2$gene,
                              Cluster_TRM$gene,
                              Cluster_gd_T_g9d2$gene,
                              Cluster_gd_T_non_g9d2$gene,
                              Cluster_MAIT$gene,
                              Cluster_Proliferative$gene))




# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Add custom genes 
Top.cluster.genes <- unique(c(Top.cluster.genes, goi))

for(i in 1:length(Top.cluster.genes)){
  
  print(paste0("Plotting ", Top.cluster.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.cluster.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/Clusters/VlnPlot_", Top.cluster.genes[i], "_imputed.pdf"))
  dev.off()
  
  # If gene is already in top.module.gene list this will have already been plotted
  if(Top.cluster.genes[i] %in% Top.module.genes){
    next()
  }else{
    # Plot feature plot on UMAP projection
    print(FeaturePlot(seurat.combined,
                      features = Top.cluster.genes[i],
                      reduction = "umap") + 
            NoLegend())
    
    dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/FeaturePlot_", Top.cluster.genes[i], "_imputed.pdf"))
    dev.off()
  }
  
}




```


### Volcano DEGs
```{r Volcano_plots}

# Generate output directories
if(!dir.exists("output/figures/VolcanoPlots")){
  dir.create("output/figures/VolcanoPlots", 
             recursive = TRUE)
}

if(!dir.exists("output/figures/VolcanoPlots/Clusters")){
  dir.create("output/figures/VolcanoPlots/Clusters", 
             recursive = TRUE)
}

if(!dir.exists("output/figures/VolcanoPlots/Modules")){
  dir.create("output/figures/VolcanoPlots/Modules", 
             recursive = TRUE)
}

##############################
# Install and load package
##############################

# "EnhancedVolcano" package from Github repo
# devtools::install_github('kevinblighe/EnhancedVolcano')

library(EnhancedVolcano)


#############
# Functions
#############

clean.data <- function(input.data, group.id){
  
  output.data <- input.data %>%
    dplyr::filter(cluster == paste0(group.id))
  
  rownames(output.data) <- output.data$gene
  
  output.data <- output.data %>%
    dplyr::select(avg_logFC, p_val_adj)
  
  colnames(output.data) <- c("logFC", "FDR")
  return(output.data)
  
}



colour.points <- function(volcano.data, 
                          increase.col = "Red",
                          decreased.col = "Blue",
                          FDR.cutoff = 0.05,
                          logFC.cutoff = 0.25){
  
  # set the base colour
  keyvals <- rep('grey50', nrow(volcano.data))
  
  # set the base name/label as 'NS'
  names(keyvals) <- rep('NS', nrow(volcano.data))
  
  # modify keyvals for vars meeting FDR and LogFC threshold
  
  # Increased
  keyvals[which(volcano.data$logFC > logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- increase.col
  names(keyvals)[which(volcano.data$logFC > logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- 'Increased'
  
  # Decreased
  keyvals[which(volcano.data$logFC < -logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- decreased.col
  names(keyvals)[which(volcano.data$logFC < -logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- 'Decreased'
  
  return(keyvals)
  
}

# edited enhancedvolcano() function to have the default variables for aesthetics I want

source("~/Documents/Work/Sciebo/Scripts/Enhanced_volcano_custom_defaults.R")



################
# Clusters
################

cluster.markers.df <- read.csv("output/tables/DEG_Clusters/Cluster_markers_unfiltered.csv")


cluster.var <- unique(cluster.markers.df$cluster)


for(i in 1:length(cluster.var)){
  
  # format data
  volcano.data <- clean.data(cluster.markers.df,
                             group.id = cluster.var[i])
  
  keyvals <- colour.points(volcano.data)
  
  
  # get list of top 10 up and 10 downregulated genes
  goi.up <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(10, logFC)
  
  goi.dn <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(-10, logFC)
  
  # combine vectors
  goi <- unique(c(rownames(goi.up), rownames(goi.dn)))
  
  
  
  print(custom.enhanced.volcano(volcano.data, 
                                selectLab = goi, 
                                colCustom = keyvals, 
                                title = paste0(cluster.var[i])))
  
  
  dev.copy(pdf, paste0("output/figures/VolcanoPlots/Clusters/Volcano_", cluster.var[i], ".pdf"))
  dev.off()
  
  
}



################
# Modules
################

Module.markers.df <- read.csv("output/tables/DEG_Modules/Module_markers_unfiltered.csv")


module.var <- unique(Module.markers.df$cluster)


for(i in 1:length(module.var)){
  
  # format data
  volcano.data <- clean.data(Module.markers.df,
                             group.id = module.var[i])
  
  keyvals <- colour.points(volcano.data)
  
  
  # get list of top 10 up and 10 downregulated genes
  goi.up <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(10, logFC)
  
  goi.dn <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(-10, logFC)
  
  # combine vectors
  goi <- unique(c(rownames(goi.up), rownames(goi.dn)))
  
  
  
  print(custom.enhanced.volcano(volcano.data, 
                                selectLab = goi, 
                                colCustom = keyvals, 
                                title = paste0(module.var[i])))
  
  
  dev.copy(pdf, paste0("output/figures/VolcanoPlots/Modules/Volcano_", module.var[i], ".pdf"))
  dev.off()
  
  
}















########################################################################
### Below code is kept for any future tweeking of volcano aesthetics 
########################################################################


# Custom point size for points of particular type 
# pointSize = c(ifelse(volcano.data$genes %in% goi, 10, 4))

# Add custom ticks
# +
#  ggplot2::coord_cartesian(xlim=c(-1.5, 3)) +
#  ggplot2::scale_x_continuous(
#    breaks=seq(-1.5, 3, 0.5))




#EnhancedVolcano(volcano.data,
#                lab = rownames(volcano.data),
#                x = 'logFC',
#                y = 'FDR',
#                selectLab = goi,
#xlim = c(-2.5, 2.5),
#ylim = c(0, 500),
#                title = "DNAM1 High vs. Neg",
#                subtitle = "",
#                ylab = bquote(~-Log[10]~adjusted~italic(P)),
##                pCutoff = 0.05,
#                FCcutoff = 0.25,
#                pointSize = 5, 
#col = c("black", "black", "black", "red2"),
#                colCustom = keyvals,
#                colAlpha = 0.2, 
#                drawConnectors = TRUE,
#                widthConnectors = 0.5,
#                colConnectors = 'grey30',
#                typeConnectors = "open",
#                labSize = 4,
#                gridlines.major = TRUE,
#                gridlines.minor = FALSE,
#                border = 'partial',
#                borderWidth = 0.5,
#                borderColour = 'black')   

```



## Cell-cell receptor-ligand analysis {.tabset}

### Celltalker analysis
```{r celltalker}

# Create output directories
if(!dir.exists("output/figures/Cell_cell_interaction")){
  dir.create("output/figures/Cell_cell_interaction", 
             recursive = T)
}

if(!dir.exists("output/figures/Cell_cell_interaction/celltalker")){
  dir.create("output/figures/Cell_cell_interaction/celltalker", 
             recursive = T)
}



# load library
library("celltalker")

# Ref dataset supplied with celltalker
head(ramilowski_pairs)
tail(ramilowski_pairs)

dim(ramilowski_pairs) #There are 2,557 unique ligand/receptor interactions in this dataset


###########################################################################
#Identification of differentially expressed ligands and receptors
###########################################################################

# Identify ligands and receptors in our dataset
ligs <- as.character(unique(ramilowski_pairs$ligand))
recs <- as.character(unique(ramilowski_pairs$receptor))

ligs.present <- rownames(seurat.combined)[rownames(seurat.combined) %in% ligs]
recs.present <- rownames(seurat.combined)[rownames(seurat.combined) %in% recs]

genes.to.use <- union(ligs.present,recs.present)
length(genes.to.use) # 760


# Use FindAllMarkers for deferentially expressed ligands and receptors between groups

# Set idents to clusters
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

ligand.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA", 
                                 features = genes.to.use,
                                 only.pos = TRUE)

nrow(ligand.markers) # 269 


# Filter by adjusted P.value 
ligand.markers <- ligand.markers[ligand.markers$p_val_adj < 0.05, ]

nrow(ligand.markers) # 254

# get vector of unique ligands/receptors
ligs.recs.use <- unique(ligand.markers$gene)
length(ligs.recs.use) # 111




# Filter ramilowski pairs
interactions.forward1 <- ramilowski_pairs[as.character(ramilowski_pairs$ligand) %in% ligs.recs.use, ]

interactions.forward2 <- ramilowski_pairs[as.character(ramilowski_pairs$receptor) %in% ligs.recs.use, ]

interact.for <- rbind(interactions.forward1, interactions.forward2)

dim(interact.for) # 494 ligand receptor interactions




# Create data for celltalker
DefaultAssay(seurat.combined) <- "RNA"

expr.mat <- GetAssayData(seurat.combined, 
                         slot = "counts")

# define clusters and groups(condition)
defined.clusters <- seurat.combined@meta.data$seurat_clusters
defined.groups <- seurat.combined@meta.data$condition


# Need to get a replicates vector 
defined.replicates <- seurat.combined@meta.data$group
defined.replicates <- gsub("S1", "US_1", defined.replicates)
defined.replicates <- gsub("S2", "US_2", defined.replicates)
defined.replicates <- gsub("S3", "Stim_1", defined.replicates)
defined.replicates <- gsub("S4", "Stim_2", defined.replicates)

# Needs to be a named vector
names(defined.clusters) <- rownames(seurat.combined@meta.data)
names(defined.groups) <- rownames(seurat.combined@meta.data)
names(defined.replicates) <- rownames(seurat.combined@meta.data)

# should be a factor vector
defined.clusters <- factor(defined.clusters, levels = c("Naïve_like_1_CM",
                                                        "Naïve_like_2_SC",
                                                        "Naïve_like_3",
                                                        "Cytotoxic",
                                                        "Type_I_IFN",
                                                        "Stimulated_1",
                                                        "Stimulated_exhausted",
                                                        "Exhausted_1",
                                                        "Exhausted_2",
                                                        "TRM",
                                                        "gd_T_g9d2",
                                                        "gd_T_non_g9d2",
                                                        "MAIT",
                                                        "Proliferative"))

defined.groups <- factor(defined.groups, levels = c("US",
                                                    "Stim"))

defined.replicates <- factor(defined.replicates, levels = c("US_1",
                                                            "US_2",
                                                            "Stim_1",
                                                            "Stim_2"))



reshaped.matrices <- reshape_matrices(count.matrix = expr.mat,
                                      clusters = defined.clusters,
                                      groups = defined.groups,
                                      replicates = defined.replicates,
                                      ligands.and.receptors = interact.for)


#Check out the hierarchy of the tibble
reshaped.matrices
reshaped.matrices$group
reshaped.matrices$samples

unnest(reshaped.matrices,
       cols = "samples")

names(pull(unnest(reshaped.matrices, cols = "samples"))[[1]])

# small bug in create_lig_rec_tib function, required small modification 
source("~/Documents/Work/Sciebo/Scripts/Modified_Celltalker_function.R")

consistent.lig.recs <- create_lig_rec_tib.mod(exp.tib = reshaped.matrices,
                                              clusters = defined.clusters,
                                              groups = defined.groups,
                                              replicates = defined.replicates,
                                              cells.reqd = 10,
                                              freq.pos.reqd = 0.5,
                                              ligands.and.receptors = interact.for)





consistent.lig.recs


unnest(consistent.lig.recs[1,2], 
       cols = "lig.rec.exp")

pull(unnest(consistent.lig.recs[1,2],
            cols = "lig.rec.exp")[1,2])[[1]]

# Determine putative ligand/receptor pairs
put.int <- putative_interactions(ligand.receptor.tibble = consistent.lig.recs,
                                 clusters = defined.clusters,
                                 groups = defined.groups,
                                 freq.group.in.cluster = 0.05,
                                 ligands.and.receptors = interact.for)

# Identify and visualise unique ligand/receptor pairs in a group

# Identify unique ligand/receptor interactions present in each sample
unique.ints <- unique_interactions(put.int,
                                   group1 = "US",
                                   group2 = "Stim",
                                   interact.for)

temp.df <- as.data.frame(unique.ints)

# Get data to plot circos unique to US
US.to.plot <- pull(unique.ints[1,2])[[1]]
for.circos.US <- pull(put.int[1,2])[[1]][US.to.plot]

circos_plot(interactions = for.circos.US,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray") 

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_US_clusters.pdf")
dev.off()




#Get data to plot circos unique to Stim
Stim.to.plot <- pull(unique.ints[2,2])[[1]]
for.circos.Stim <- pull(put.int[2,2])[[1]][Stim.to.plot]

circos_plot(interactions = for.circos.Stim,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_Stim_clusters.pdf")
dev.off()





# Get data to plot circos common 
Common.to.plot <- pull(unique.ints[3,2])[[1]]
for.circos.common <- pull(put.int[1,2])[[1]][Common.to.plot]

circos_plot(interactions = for.circos.common,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_Common_clusters.pdf")
dev.off()









##################################################
### repeat analysis for modules 
##################################################

# Set idents
Idents(seurat.combined) <- seurat.combined@meta.data$Module

ligand.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA", 
                                 features = genes.to.use,
                                 only.pos = TRUE)

nrow(ligand.markers) # 104 


# Filter by adjusted P.value 
ligand.markers <- ligand.markers[ligand.markers$p_val_adj < 0.05, ]

nrow(ligand.markers) # 91

# get vector of unique ligands/receptors
ligs.recs.use <- unique(ligand.markers$gene)
length(ligs.recs.use) # 76



# Filter ramilowski pairs
interactions.forward1 <- ramilowski_pairs[as.character(ramilowski_pairs$ligand) %in% ligs.recs.use,]
interactions.forward2 <- ramilowski_pairs[as.character(ramilowski_pairs$receptor) %in% ligs.recs.use,]
interact.for <- rbind(interactions.forward1, interactions.forward2)

dim(interact.for) # 373



# Create data for celltalker
DefaultAssay(seurat.combined) <- "RNA"

expr.mat <- GetAssayData(seurat.combined, 
                         slot = "counts")

# Groups and replicates are defined in code for celltalk on clusters 
# Just "clusters" needs to be redefined to modules

defined.clusters <- seurat.combined@meta.data$Module

# Needs to be a named vector
names(defined.clusters) <- rownames(seurat.combined@meta.data)

# should be a factor vector
defined.clusters <- factor(defined.clusters, levels = c("Naive_Stem",
                                                        "Activated",
                                                        "Exhaustion",
                                                        "Innate",
                                                        "Cycling"))

reshaped.matrices <- reshape_matrices(count.matrix = expr.mat,
                                      clusters = defined.clusters,
                                      groups = defined.groups,
                                      replicates = defined.replicates,
                                      ligands.and.receptors = interact.for)


# Check out the hierarchy of the tibble
reshaped.matrices

unnest(reshaped.matrices,
       cols = "samples")

names(pull(unnest(reshaped.matrices, cols = "samples"))[[1]])


consistent.lig.recs <- create_lig_rec_tib.mod(exp.tib = reshaped.matrices,
                                              clusters = defined.clusters,
                                              groups = defined.groups,
                                              replicates = defined.replicates,
                                              cells.reqd = 10,
                                              freq.pos.reqd = 0.5,
                                              ligands.and.receptors = interact.for)

consistent.lig.recs


unnest(consistent.lig.recs[1,2], 
       cols = "lig.rec.exp")

pull(unnest(consistent.lig.recs[1,2],
            cols = "lig.rec.exp")[1,2])[[1]]

# Determine putative ligand/receptor pairs
put.int <- putative_interactions(ligand.receptor.tibble = consistent.lig.recs,
                                 clusters = defined.clusters,
                                 groups = defined.groups,
                                 freq.group.in.cluster = 0.05,
                                 ligands.and.receptors = interact.for)

# Identify and visualise unique ligand/receptor pairs in a group

# Identify unique ligand/receptor interactions present in each sample
unique.ints <- unique_interactions(put.int,
                                   group1 = "US",
                                   group2 = "Stim",
                                   interact.for)


#temp.df <- as.data.frame(unique.ints)

# Get data to plot circos unique to US
US.to.plot <- pull(unique.ints[1,2])[[1]]
for.circos.US <- pull(put.int[1,2])[[1]][US.to.plot]

circos_plot(interactions = for.circos.US,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray") 

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_US_modules.pdf")
dev.off()


#Get data to plot circos unique to Stim
Stim.to.plot <- pull(unique.ints[2,2])[[1]]
for.circos.Stim <- pull(put.int[2,2])[[1]][Stim.to.plot]

circos_plot(interactions = for.circos.Stim,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_Stim_modules.pdf")
dev.off()


# Get data to plot circos common 
Common.to.plot <- pull(unique.ints[3,2])[[1]]
for.circos.common <- pull(put.int[1,2])[[1]][Common.to.plot]

circos_plot(interactions = for.circos.common,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_Common_modules.pdf")
dev.off()


```

### Cellphonedb
```{r Cellphonedb}

# Create output directories
if(!dir.exists("output/tables/cellphonedb")){
  dir.create("output/tables/cellphonedb", 
             recursive = T)
}

# Cellphonedb is a python program - can also be used via an online webportal

# Prepare and export data for cellphonedb analysis



save.data.frame.function <- function(df, title){
  
  x <- as.data.frame(as.matrix(df))
  
  write.table(x, 
              paste0("output/tables/cellphonedb/", title, ".txt"),
              sep = "\t",
              quote = FALSE)
}




# Export dataset of all cells (US and Stim)

Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

save.data.frame.function(seurat.combined@assays$RNA@data, "cellphonedb_both_conditions_normed")


# Metadata with cluster annotation
tmp.meta.data <- cbind(rownames(seurat.combined@meta.data),
                       seurat.combined@meta.data[ ,"seurat_clusters", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_both_conditions_clusters.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)

# Metadata with module annotation
tmp.meta.data <- cbind(rownames(seurat.combined@meta.data),
                       seurat.combined@meta.data[ ,"Module", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_both_conditions_modules.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)


# Export dataset of just US cells
Idents(seurat.combined) <- seurat.combined@meta.data$condition

temp.seurat <- subset(seurat.combined, idents = "US")

Idents(temp.seurat) <- temp.seurat@meta.data$seurat_clusters

save.data.frame.function(temp.seurat@assays$RNA@data, "cellphonedb_US_normed")

# Metadata with cluster annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"seurat_clusters", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_US_clusters.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)

# Metadata with Module annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"Module", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_US_modules.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)



# Export dataset of just Stim cells
Idents(seurat.combined) <- seurat.combined@meta.data$condition

temp.seurat <- subset(seurat.combined, idents = "Stim")

Idents(temp.seurat) <- temp.seurat@meta.data$seurat_clusters

save.data.frame.function(temp.seurat@assays$RNA@data, "cellphonedb_Stim_normed")

# Metadata with cluster annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"seurat_clusters", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_Stim_clusters.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)


# Metadata with Module annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"Module", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_Stim_modules.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)


rm(tmp.meta.data, temp.seurat)


```

### iTalk
```{r iTalk}

# Create output directories
if(!dir.exists("output/figures/Cell_cell_interaction")){
  dir.create("output/figures/Cell_cell_interaction", 
             recursive = T)
}

if(!dir.exists("output/figures/Cell_cell_interaction/iTALK")){
  dir.create("output/figures/Cell_cell_interaction/iTALK", 
             recursive = T)
}


# Load library
library(iTALK)


#############################
# Run analysis for clusters
#############################

# Downsample dataset
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

seurat.combined.small <- subset(seurat.combined, downsample = 300)

iTalk.input <- as.data.frame(seurat.combined.small@assays$RNA@data)

# Append metadata
temp <- as.data.frame(seurat.combined.small@meta.data)
sum(rownames(temp) != colnames(iTalk.input))

iTalk.input <- t(iTalk.input)
iTalk.input <- as.data.frame(iTalk.input)

iTalk.input$cell_type <- temp$seurat_clusters


# find top 50 percent highly expressed genes
highly_exprs_genes <- rawParse(iTalk.input, top_genes = 50, stats = 'mean')

# find the ligand-receptor pairs from highly expressed genes
comm_list<-c('growth factor','other','cytokine','checkpoint')

cell_col <- structure(c('Red','Blue','Green','Purple', 'Orange', 'Grey','Black', "Yellow", "Darkred", "lightblue", "Pink", "burlywood", "Brown", "Darkgreen"), names = unique(iTalk.input$cell_type))


par(mfrow = c(1,2))
par(mfrow = c(1,1))

res <- NULL

for(comm_type in comm_list){
  res_cat <- FindLR(highly_exprs_genes, 
                    datatype = 'mean count', 
                    comm_type = comm_type)
  
  res_cat <- res_cat[order(res_cat$cell_from_mean_exprs*res_cat$cell_to_mean_exprs, 
                           decreasing = TRUE), ]
  
  #plot by ligand category
  
  #top 50 ligand-receptor pairs
  LRPlot(res_cat[1:50,],
         datatype = 'mean count', 
         cell_col = cell_col,
         link.arr.lwd = res_cat$cell_from_mean_exprs[1:50], 
         link.arr.width = res_cat$cell_to_mean_exprs[1:50])
  title(comm_type)
  
  dev.copy(pdf, paste0("output/figures/Cell_cell_interaction/iTALK/Ligand_receptor_plot_", comm_type, ".pdf"))
  dev.off()
  
  res <- rbind(res,res_cat)
}






# Archived code below to plot network 1 by 1 for each cell type

#for(i in 1:14){

# col.vec <- rep("#BEBEBE00", 14)
#col.vec[i] <- "Red"


#cell_col <- structure(col.vec, names = unique(iTalk.input$cell_type))

#NetView(res_cat, 
#        col = cell_col,
#        vertex.label.cex = 1,
#        label = FALSE,
#        arrow.width = 1, 
#        edge.max.width = 20)

#}


```


## GSEA analysis {.tabset}

### Scillus
```{r Scillus_GSEA}

#remotes::install_github("xmc811/Scillus")

# Scillus package would not compile
# I took the functions and made a new .R file
# Some of the functions called and used in this script required modifications to work outside of the package environment

source("~/Documents/Work/Sciebo/Scripts/Scillus_package/Scillus_functions.R")
load("~/Documents/Work/Sciebo/Scripts/Scillus_package/pathways.hallmark.rda")



# Create output directories
if(!dir.exists("output/figures/GO_analysis")){
  dir.create("output/figures/GO_analysis", 
             recursive = T)
}

if(!dir.exists("output/figures/GO_analysis/Scillus_GO")){
  dir.create("output/figures/GO_analysis/Scillus_GO", 
             recursive = T)
}

######################
# Module analysis
######################

# set idents to Module
Idents(seurat.combined) <- seurat.combined@meta.data$Module


# get a broad list of DEG markers 
Module.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA",
                                 only.pos = FALSE,
                                 min.diff.pct = 0.1,
                                 logfc.threshold = 0,
                                 return.thresh = 0.01)




# Threshold marker list by P value and fold change for GO analysis 

GO.markers <- Module.markers[Module.markers$p_val_adj < 0.05, ]
GO.markers <- GO.markers[abs(GO.markers$avg_logFC) > 0.25, ]
dim(Module.markers) #2,132 genes
dim(GO.markers) # 1,232 genes

table(GO.markers$cluster) # number of genes DEG per cluster // used to justify using topn = 100

# Plot Gene Ontology analysis
# CC, BP, MF

# To plot graph for a specific cluster use below code
#plot_cluster_go(Module.markers, cluster_name = "Activated", org = "human", ont = "MF")

# CC 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Modules_CC.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "CC")

dev.off()


# BP 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Modules_BP.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "BP")

dev.off()

# MF 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Modules_MF.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "MF")
dev.off()




# Perform GSEA 
gsea_res <- test_GSEA(Module.markers, 
                      pathway = pathways.hallmark)



plot_GSEA(gsea_res)
dev.copy(pdf, "output/figures/GO_analysis/Scillus_GO/GSEA_Module.pdf")
dev.off()


######################
# Cluster analysis
######################

# set idents to cluster
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# get a broad list of DEG markers 
Cluster.markers <- FindAllMarkers(seurat.combined,
                                  assay = "RNA",
                                  only.pos = FALSE,
                                  min.diff.pct = 0.1,
                                  logfc.threshold = 0,
                                  return.thresh = 0.01)




# Threshold marker list by P value and fold change for GO analysis 

GO.markers <- Cluster.markers[Cluster.markers$p_val_adj < 0.05, ]
GO.markers <- GO.markers[abs(GO.markers$avg_logFC) > 0.25, ]
dim(Cluster.markers) # 8,635 genes
dim(GO.markers) # 4,890 genes

table(GO.markers$cluster) # number of genes DEG per cluster // used to justify using topn = 100

# Plot Gene Ontology analysis
# CC, BP, MF

# To plot graph for a specific cluster use below code
#plot_cluster_go(Module.markers, cluster_name = "Activated", org = "human", ont = "MF")

# CC 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Clusters_CC.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "CC")

dev.off()


# BP 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Clusters_BP.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "BP")

dev.off()

# MF 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Clusters_MF.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "MF")
dev.off()




# Perform GSEA 
gsea_res <- test_GSEA(Cluster.markers, 
                      pathway = pathways.hallmark)



plot_GSEA(gsea_res)
dev.copy(pdf, "output/figures/GO_analysis/Scillus_GO/GSEA_Clusters.pdf")
dev.off()


```


## Additional analysis {.tabset}

### Cell cycle analysis
```{r cell_cycle}

# Analyse if there is any enrichment for cell cycle stage

if(!dir.exists("output/figures/cell_cycle")){
  dir.create("output/figures/cell_cycle")
}

##################################
# Ensure idents is set up
##################################

Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters



################
# Read in data
################

exp.mat <- read.table(file = "Input_data/Cell_cycle_input_dataset/cell_cycle_vignette_files/nestorawa_forcellcycle_expressionMatrix.txt", 
                      header = TRUE, 
                      as.is = TRUE, row.names = 1)

# A list of cell cycle markers, from Tirosh et al, 2015, is loaded with Seurat.
# We can segregate this list into markers of G2/M phase and markers of S phase

cc.genes$s.genes
cc.genes$g2m.genes

s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes


#######################
# Cell cycle analysis
#######################

seurat.combined <- CellCycleScoring(seurat.combined, 
                                    s.features = s.genes, 
                                    g2m.features = g2m.genes, 
                                    set.ident = FALSE)


head(seurat.combined@meta.data)


#######################
# Visualisation
#######################

UMAPPlot(seurat.combined, 
         group.by = "Phase",
         split.by = "condition",
         pt.size = 1)

dev.copy(pdf, "output/figures/cell_cycle/UMAP_CellCycle_Phase.pdf")
dev.off()


FeaturePlot(seurat.combined, 
            reduction = "umap",
            features = "S.Score",
            pt.size = 1.5, 
            label = TRUE, 
            label.size = 5,
            order = TRUE, 
            cols = c("lightgray", "orange", "red")) + NoLegend()

dev.copy(pdf, "output/figures/cell_cycle/FeaturePlot_S.pdf")
dev.off()

FeaturePlot(seurat.combined, 
            reduction = "umap",
            features = "G2M.Score",
            pt.size = 1.5, 
            label = TRUE, 
            label.size = 5,
            order = TRUE, 
            cols = c("lightgray", "orange", "red")) + NoLegend()

dev.copy(pdf, "output/figures/cell_cycle/FeaturePlot_G2M.pdf")
dev.off()

#######################
# Vln plots
#######################

VlnPlot(seurat.combined, 
        features = "S.Score")

dev.copy(pdf, "output/figures/cell_cycle/VlnPlot_Sscore.pdf")
dev.off()


VlnPlot(seurat.combined,
        features = "G2M.Score")

dev.copy(pdf, "output/figures/cell_cycle/VlnPlot_G2Mscore.pdf")
dev.off()

#######################
# Ridge plots
#######################

RidgePlot(seurat.combined, 
          features = c("S.Score", "G2M.Score"), 
          log = TRUE)

dev.copy(pdf, "output/figures/cell_cycle/RidgePlot_S_and_G2Mscore.pdf")
dev.off()


table(seurat.combined@meta.data$Phase)


```

### CytoTRACE
```{r cytoTRACE_analysis}

#####################
# Install package
#####################

#BiocManager::install("sva")

# Package wont install, killed 9 error. so load locally workaround 
#devtools::install_local("~/Documents/Work/Sciebo/Scripts/CytoTRACE_0.3.2.tar.gz")
devtools::load_all("~/Documents/Work/Sciebo/Scripts/CytoTRACE/")

# run in terminal 
# pip install scanoramaCT
# pip install numpy

# Example dataset
#data.file <- read.delim("CytoTRACE_Analysis/Example_datasets/Bone_marrow_10x_matrix.txt")
#data.pheno <- read.delim("CytoTRACE_Analysis/Example_datasets/Bone_marrow_10x_metadata.txt")


##############################
# Create output directories
##############################

if(!dir.exists("output/figures/CytoTRACE")){dir.create("output/figures/CytoTRACE", recursive = T)}

##############
# Load library
##############

library("CytoTRACE")


# Prepare data

# Expression matrix (Raw data)
data.file <- as.data.frame(seurat.combined@assays$RNA@counts)
head(data.file[1:10, 1:10])

# Metadata file
data.pheno <- as.data.frame(seurat.combined@meta.data)
head(data.pheno)

# Run cytoTRACE
Trace.object <- CytoTRACE(data.file,
                          enableFast = TRUE,
                          ncores = 6, 
                          subsamplesize = 1000)


# Create phenotype label vector
pheno.labels <- as.character(data.pheno$seurat_clusters)
names(pheno.labels) <- rownames(data.pheno)



# Small error in plotCytoTRACE function, needed to correct function locally
source("~/Documents/Work/Sciebo/Scripts/CytoTrace_modified_function.R")

# Plot data
cytoTRACE.mod(Trace.object,
              emb = data.pheno[ , c("UMAP_1", "UMAP_2")],
              phenotype = pheno.labels,
              outputDir = paste0(working.dir, "/output/figures/CytoTRACE/"))



plotCytoGenes(Trace.object, 
              numOfGenes = 50,
              outputDir = paste0(working.dir, "/output/figures/CytoTRACE/"))




# Remove variables to save space and prevent errors
rm(data.file, data.pheno, Trace.object, pheno.labels)


```


## TCR analysis {.tabset}

### Format data with scRepertoire
```{r Format_data_with_scRep}

# If using R < 4, should use the dev version with @dev
#devtools::install_github("ncborcherding/scRepertoire")
#install.packages("ggalluvial")

# Package fails to load - use this trick to get tools of the package 
devtools::load_all("~/Documents/Work/Sciebo/Scripts/scRepertoire/")


#################################
# Read in and format data
#################################

# read in contig files
S1.contig <- read.csv("Input_data/VDJ_data/Sample1_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S2.contig <- read.csv("Input_data/VDJ_data/Sample2_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S3.contig <- read.csv("Input_data/VDJ_data/Sample3_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S4.contig <- read.csv("Input_data/VDJ_data/Sample4_filtered_contig_annotations.csv", stringsAsFactors = FALSE)

# create list of contigs
contig.list <- list(S1.contig, S2.contig,
                    S3.contig, S4.contig)

# Combine contig list
combined.contig <- combineTCR(contig.list, 
                              samples = c("S1", "S2", "S3", "S4"), 
                              ID = c("US", "US", "Stim", "Stim"), 
                              cells = "T-AB",
                              removeNA = TRUE,
                              removeMulti = FALSE, 
                              filterMulti = TRUE) # take the top 2 expressed chains for cells with multiple chains 

# on average, filteringMulti results in approx. 200 more cells for each sample than outright removing cells


# Need to amend BarcodeID to match with seurat object
combined.contig$S1_US$barcode <- gsub("US_", "", combined.contig$S1_US$barcode)
combined.contig$S2_US$barcode <- gsub("US_", "", combined.contig$S2_US$barcode)
combined.contig$S3_Stim$barcode <- gsub("Stim_", "", combined.contig$S3_Stim$barcode)
combined.contig$S4_Stim$barcode <- gsub("Stim_", "", combined.contig$S4_Stim$barcode)


# Combine seurat object with contig info
seurat.tcr <- combineExpression(combined.contig,
                                seurat.combined,
                                cloneCall = "aa",
                                cloneTypes = c(None = 0, Single = 1, Small = 5, Medium = 10, Large = 20, Hyperexpanded = 150),
                                groupBy = "none", # Alternative frequencies are calculated in next code Chunk
                                filterNA = TRUE) # should seurat object be subsetted to remove NA values

# Max freq of a clonotype is 127, therefore reset cloneTypes accordingly

# Seurat object went from 11658 samples to 6625 samples 
# Therefore 56% of original dataset remains 


# Rename frequency column
logic.vec <- grepl("Frequency", colnames(seurat.tcr@meta.data))
colnames(seurat.tcr@meta.data)[logic.vec] <- "Total_clonotype_n"


# Ensure seurat object cloneType var is a factor with correct levels
seurat.tcr@meta.data$cloneType <- factor(seurat.tcr@meta.data$cloneType, 
                                         levels = c("Hyperexpanded (20 < X <= 150)",
                                                    "Large (10 < X <= 20)", 
                                                    "Medium (5 < X <= 10)",
                                                    "Small (1 < X <= 5)", 
                                                    "Single (0 < X <= 1)"))

# remove unneeded objects
rm(combined.contig, contig.list, S1.contig, S2.contig, S3.contig, S4.contig)

```

### Count clonotype frequencies and normalise
```{r Count_and_normalise_clonotype_frequencies}

####################################################################################
# Need to count clonotype occurrence per condition and then normalise this value 
####################################################################################

# create temp meta.data df and append cell_ID as column (lost in dplyr workflow)
meta.data.temp <- seurat.tcr@meta.data
meta.data.temp$cell_ID <- rownames(seurat.tcr@meta.data)
corner(meta.data.temp, c = ncol(meta.data.temp))


# Get total number of cells in each condition
US.cell.n <- table(meta.data.temp$condition)[1]
Stim.cell.n <- table(meta.data.temp$condition)[2]

# Count occurances of clonotypes per condition 
# then normalise by number of cells in each condition 
meta.data.temp <- meta.data.temp %>%
  dplyr::group_by(CTaa, condition) %>%
  dplyr::mutate(Clonotype_freq_per_condition = n()) %>%
  dplyr::group_by(condition) %>%
  dplyr::mutate(Clonotype_freq_per_condition = case_when(condition == "US" ~ (Clonotype_freq_per_condition/US.cell.n)*100, 
                                                         condition == "Stim" ~ (Clonotype_freq_per_condition/Stim.cell.n)*100)) %>%
  dplyr::ungroup()




sum(rownames(seurat.tcr@meta.data) != meta.data.temp$cell_ID) # order of cells matches


seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Clonotype_freq_per_condition",
                          metadata = meta.data.temp$Clonotype_freq_per_condition)



rm(meta.data.temp)



#############################################
# Scale variables for downstream plotting
#############################################

seurat.tcr@meta.data$Total_clonotype_n_scaled <- scales::rescale(seurat.tcr@meta.data$Total_clonotype_n, 
                                                                 to = c(0, 10))



seurat.tcr@meta.data$Clonotype_freq_per_condition_scaled <- scales::rescale(seurat.tcr@meta.data$Clonotype_freq_per_condition, 
                                                                            to = c(0, 10))

# Use cases: 
# Total_clonotype_n_scaled = total occurrences of clonotypes across entire dataset
# -- use when plotting dataset all together (not split by condition)
# -- Scaled for pt.size plotting

# Clonotype_freq_per_condition_scaled = number of clonotype occurrences per condition normalised by condition // i.e percentage of all cells in condition 
#  -- use when plotting dataset split by condition
# -- Scaled for pt.size plotting


```

### Export or read in tcr seurat object
```{r export_RDS}

if(quick.load){
  seurat.tcr <- readRDS("Exported_RDS_files/seurat_tcr.rds")
}else if(!quick.load){
  saveRDS(seurat.tcr, file = "Exported_RDS_files/seurat_tcr.rds")
}

```

### Analysis with scRepertoire
```{r scRepertoire_analysis}

# Create output directories
if(!dir.exists("output/figures/TCRseq/scRepertoire")){
  dir.create("output/figures/TCRseq/scRepertoire",
             recursive = T)}

if(!dir.exists("output/figures/TCRseq/scRepertoire/clusters")){
  dir.create("output/figures/TCRseq/scRepertoire/clusters",
             recursive = T)}

if(!dir.exists("output/figures/TCRseq/scRepertoire/modules")){
  dir.create("output/figures/TCRseq/scRepertoire/modules",
             recursive = T)}



#########################
# Set uniform variables 
#########################

# for clonalProportion split
split.var <- c(1, 5, 10, 20, 50, 500, 5000, 1e+05)

# for clonalHomeostasis split
homeostasis.var <- c(Rare = 0.001, 
                     very_small = 0.002,
                     Small = 0.005, 
                     Medium = 0.01, 
                     Large = 0.05, 
                     very_Large = 0.1, 
                     Hyperexpanded = 1)


#########################################################
# Perform basic clonotype analysis and visualisation
#########################################################

# quantify % unique clonotype per sample
quantContig(combined.contig,
            cloneCall="aa", 
            scale = TRUE)

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/Quant_contig_sample.pdf")
dev.off()

# quantify % unique clonotype per group
quantContig(combined.contig,
            cloneCall="aa", 
            group = "ID",
            scale = TRUE)

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/Quant_contig_treatment.pdf")
dev.off()


# abundance of clonotypes
abundanceContig(combined.contig,
                cloneCall = "aa",
                group = "ID", 
                scale = TRUE)

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/Clonotype_abundance_by_treatment.pdf")
dev.off()



# Chain length overview 
lengthContig(combined.contig, 
             cloneCall="aa", 
             chains = "combined",
             group = "ID") 

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/Chain_length_combined.pdf")
dev.off()

# Chain length by chain
lengthContig(combined.contig, 
             cloneCall="aa", 
             chains = "single",
             group = "ID")

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/Chain_length_by_locus.pdf")
dev.off()


## Something looks weird with the alluvial plots - lines dont line up

# Compare clonotypes across samples

compareClonotypes(combined.contig,
                  numbers = 20, 
                  samples = c("S1_US", "S3_Stim"), 
                  cloneCall = "aa", 
                  graph = "alluvial") + NoLegend()


compareClonotypes(combined.contig,
                  numbers = 20, 
                  samples = c("S2_US", "S4_Stim"), 
                  cloneCall = "aa", 
                  graph = "alluvial") + NoLegend()



# Overview of clonal homeostasis
clonalHomeostasis(combined.contig, 
                  cloneType = homeostasis.var,
                  cloneCall = "aa")

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/clonalHomeostasis.pdf")
dev.off()


# Clonal Proportion
clonalProportion(combined.contig,
                 split = split.var,
                 cloneCall = "aa") 

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/clonalProportion.pdf")
dev.off()

# clonal overlap
clonalOverlap(combined.contig, 
              cloneCall = "aa", 
              method = "morisita")

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/cloncalOverlap.pdf")
dev.off()


# clone size distribution
clonesizeDistribution(combined.contig, 
                      cloneCall = "aa", 
                      method = "ward.D2")

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/cloneSizeDistribution.pdf")
dev.off()

# Clonal Diversity 
clonalDiversity(combined.contig,
                cloneCall = "aa",
                group = "ID")

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/clonalDiversity.pdf")
dev.off()



########################################################################
# perform basic repertoire analysis across clusters & modules
########################################################################

# Modified function, original was not subsetting correctly
expression2List.mod <- function(sc, group){
  meta <- grabMeta(sc)
  unique.var <- str_sort(as.character(unique(meta[,group])), numeric = TRUE)
  df <- NULL
  for (i in seq_along(unique.var)) {
    subset.var <- meta[meta[,group] == unique.var[i],]
    df[[i]] <- subset.var
  }
  names(df) <- unique.var
  
  return(df)
}


tcr.clusters <- expression2List.mod(seurat.tcr, group = "seurat_clusters")

tcr.modules <- expression2List.mod(seurat.tcr, group = "Module")



####################
# Clonal Diversity 
####################

# Clusters
clonalDiversity(tcr.clusters, 
                cloneCall = "aa")

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/clusters/clonalDiversity_clusters.pdf")
dev.off()

# Modules
clonalDiversity(tcr.modules, 
                cloneCall = "aa")

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/modules/clonalDiversity_modules.pdf")
dev.off()



####################
# Clonal Homeostasis
####################


# Clusters
clonalHomeostasis(tcr.clusters, 
                  cloneType = homeostasis.var,
                  cloneCall = "aa") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/clusters/clonalHomeostasis_clusters.pdf")
dev.off()

# Modules
clonalHomeostasis(tcr.modules, 
                  cloneType = homeostasis.var,
                  cloneCall = "aa") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/modules/clonalHomeostasis_modules.pdf")
dev.off()


####################
# Clonal Proportion
####################

# Clusters
clonalProportion(tcr.clusters, 
                 split = split.var,
                 cloneCall = "aa") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/clusters/clonalproportion_clusters.pdf")
dev.off()


# Modules
clonalProportion(tcr.modules, 
                 split = split.var,
                 cloneCall = "aa") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/modules/clonalproportion_modules.pdf")
dev.off()



####################
# Clonal Overlap
####################

# Clusters
clonalOverlap(tcr.clusters, 
              cloneCall = "aa", 
              method = "overlap") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/clusters/clonaloverlap_clusters.pdf")
dev.off()

# Modules
clonalOverlap(tcr.modules, 
              cloneCall = "aa", 
              method = "overlap") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "output/figures/TCRseq/scRepertoire/modules/clonaloverlap_modules.pdf")
dev.off()





###################################
# Split dataset by condition
###################################

Idents(seurat.tcr) <- seurat.tcr@meta.data$condition

# US
US.seurat.tcr <- subset(seurat.tcr, ident = "US")
tcr.clusters.US <- expression2List.mod(US.seurat.tcr, group = "seurat_clusters")

# Stimulated
Stim.seurat.tcr <- subset(seurat.tcr, ident = "Stim")
tcr.clusters.Stim <- expression2List.mod(Stim.seurat.tcr, group = "seurat_clusters")




p1 <- clonalOverlap(tcr.clusters.US, 
                    cloneCall = "aa", 
                    method = "overlap") + 
  theme(axis.text.x = element_text(angle = 90))

p2 <- clonalOverlap(tcr.clusters.Stim, 
                    cloneCall = "aa", 
                    method = "overlap") + 
  theme(axis.text.x = element_text(angle = 90))


p1|p2


rm(US.seurat.tcr, tcr.clusters.US, Stim.seurat.tcr, tcr.clusters.Stim, tcr.modules, tcr.clusters)


```

### Clonotype frequency on UMAP
```{r Clonotype_freq}
###################################
# Plot dataset on UMAP projection
###################################

Idents(seurat.tcr) <- seurat.tcr@meta.data$seurat_clusters

clonetype.col <- c("Red", "Black", "blue", "orange", "lightblue")

# Vis clonotype size on UMAP
UMAPPlot(seurat.tcr, 
         group.by = "cloneType", 
         pt.size = 1) +
  scale_color_manual(values = clonetype.col, 
                     na.value="grey")


dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_UMAP.pdf")
dev.off()

# Split by condition
UMAPPlot(seurat.tcr, 
         group.by = "cloneType", 
         split.by = "condition", 
         pt.size = 1) +
  scale_color_manual(values = clonetype.col, 
                     na.value="grey")

dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_UMAP_split_condition.pdf")
dev.off()


# Split by cloneType visualise clusters
UMAPPlot(seurat.tcr, 
         group.by = "seurat_clusters", 
         split.by = "cloneType", 
         pt.size = 1, 
         cols = clust.cols) 

dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_UMAP_split_cloneType_Clusters.pdf")
dev.off()

# Split by cloneType visualise clusters
UMAPPlot(seurat.tcr, 
         group.by = "Module", 
         split.by = "cloneType", 
         pt.size = 1,
         cols = module.cols) 

dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_UMAP_split_cloneType_Modules.pdf")
dev.off()


```

### Points scaled with clonotype frequency
```{r point_size_clonotype_freq}

# Create output directories 
if(!dir.exists("output/figures/TCRseq/Clonotype_size_Ptsize")){
  dir.create("output/figures/TCRseq/Clonotype_size_Ptsize",
             recursive = T)}

##############################
# Establish plotting variables 
##############################

# For total dataset plots use:
Total.clonotype.scale <- seurat.tcr@meta.data$Total_clonotype_n_scaled

# If split by condition use:
Condition.clonotype.scale <- seurat.tcr@meta.data$Clonotype_freq_per_condition_scaled


# Plot by cluster
UMAPPlot(seurat.tcr, 
         pt.size = Total.clonotype.scale,
         group.by = "seurat_clusters", 
         cols = clust.cols) 

dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_Ptsize/Clonotype_size_clusters.pdf")
dev.off()

# Plot by module
UMAPPlot(seurat.tcr, 
         pt.size = Total.clonotype.scale,
         group.by = "Module", 
         cols = module.cols) 

dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_Ptsize/Clonotype_size_module.pdf")
dev.off()


# Plot by cluster split by condition
UMAPPlot(seurat.tcr, 
         pt.size = Condition.clonotype.scale,
         group.by = "seurat_clusters", 
         split.by = "condition",
         cols = clust.cols) 

dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_Ptsize/Clonotype_size_clusters_split_condition.pdf")
dev.off()

# Plot by cluster split by condition - No Legend
UMAPPlot(seurat.tcr, 
         pt.size = Condition.clonotype.scale,
         group.by = "seurat_clusters", 
         split.by = "condition",
         cols = clust.cols) + 
  NoLegend()

dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_Ptsize/Clonotype_size_clusters_split_condition_Nolegend.pdf")
dev.off()



# Plot by modules split by condition
UMAPPlot(seurat.tcr, 
         pt.size = Condition.clonotype.scale,
         group.by = "Module", 
         split.by = "condition",
         cols = module.cols) 

dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_Ptsize/Clonotype_size_modules_split_condition.pdf")
dev.off()

# Plot by modules split by condition - No Legend
UMAPPlot(seurat.tcr, 
         pt.size = Condition.clonotype.scale,
         group.by = "Module", 
         split.by = "condition",
         cols = module.cols) + 
  NoLegend()

dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_Ptsize/Clonotype_size_module_split_condition_Nolegend.pdf")
dev.off()



# Plot grouped by condition
UMAPPlot(seurat.tcr, 
         pt.size = Condition.clonotype.scale,
         group.by = "condition", 
         cols = Condition.cols)

dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_Ptsize/Clonotype_size_grouped_condition.pdf")
dev.off()

# Plot grouped by condition - No Legend
UMAPPlot(seurat.tcr, 
         pt.size = Condition.clonotype.scale,
         group.by = "condition", 
         cols = Condition.cols) + 
  NoLegend()

dev.copy(pdf, "output/figures/TCRseq/Clonotype_size_Ptsize/Clonotype_size_grouped_condition_Nolegend.pdf")
dev.off()


```

### Get clonotypes that occur in a specific cluster/module
```{r Get_clonotypes_function}

get.clonotypes <- function(input.seurat, identity.column, ident.id){
  
  # identitiy column = cluster or module 
  # ident.id = a specific module or cluster ID
  
  # This function identifies all clonotypes in a specified cluster/module subset and then pulls out all occurances of these clonotypes
  
  
  
  # set idents
  Idents(input.seurat) <- input.seurat@meta.data[ , paste0(identity.column)]
  
  # Subset by ident.id
  Ident.specific.seurat <- subset(input.seurat, idents = paste0(ident.id))
  
  # get list of clonotypes in selected cluster/module
  Ident.specific.clones <- sort(table(Ident.specific.seurat@meta.data$CTaa), decreasing = TRUE)
  
  # Find all cells that have these clonotypes
  keep.logic <- input.seurat@meta.data$CTaa %in% names(Ident.specific.clones)
  cells.with.ident.sp.clones <- rownames(input.seurat@meta.data)[keep.logic]
  
  # Subset seurat by these cell IDs
  seurat.ident.specific.clones <- subset(input.seurat, cells = cells.with.ident.sp.clones)
  
  
  return(seurat.ident.specific.clones)
  
}


```


### Module-specific clonotypes
```{r Module_specific_clonotypes}

# Create output directories
if(!dir.exists("output/figures/TCRseq/Modules/UMAP")){
  dir.create("output/figures/TCRseq/Modules/UMAP",
             recursive = T)}


if(!dir.exists("output/figures/TCRseq/Modules/Barplot")){
  dir.create("output/figures/TCRseq/Modules/Barplot",
             recursive = T)}

if(!dir.exists("output/figures/TCRseq/Modules/Clonotype_size_Ptsize")){
  dir.create("output/figures/TCRseq/Modules/Clonotype_size_Ptsize",
             recursive = T)}

# Set Idents to module ID
Idents(seurat.tcr) <- seurat.tcr@meta.data$Module


###################################
# get Module specific clonotypes
###################################

Module.vect <- unique(levels(seurat.tcr@meta.data$Module))

for(i in 1:length(Module.vect)){
  
  print(paste0("Performing analysis for Module = ", Module.vect[i]))
  
  
  # Extract clonotypes found in a specific module
  clonotype.seurat <- get.clonotypes(seurat.tcr, "Module", Module.vect[i])
  
  
  ########################
  # Visualisation 
  ########################
  
  # Overall distribution of clonotypes 
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = 1,
                 group.by = "Module",
                 cols = module.cols) + 
          ggtitle(paste0("Clonotypes found in ", Module.vect[i])))
  
  dev.copy(pdf, 
           paste0("output/figures/TCRseq/Modules/UMAP/UMAP_of_clonotypes_found_in_module_", Module.vect[i], ".pdf"))
  dev.off()
  
  # Split by condition
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = 1,
                 group.by = "Module", 
                 split.by = "condition", 
                 cols = module.cols) + 
          ggtitle(paste0("Clonotypes found in ", Module.vect[i])))
  
  
  dev.copy(pdf, 
           paste0("output/figures/TCRseq/Modules/UMAP/UMAP_of_clonotypes_found_in_module_", Module.vect[i], "_splitby_condition.pdf"))
  dev.off()
  
  
  
  ###############################
  # Point size = clonotype freq
  ###############################

  # Plot clonotype size
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = clonotype.seurat@meta.data$Total_clonotype_n_scaled,
                 group.by = "Module", 
                 cols = module.cols) +
          ggtitle(paste0("Clonotypes found in ", Module.vect[i])))
  
  dev.copy(pdf, 
           paste0("output/figures/TCRseq/Modules/Clonotype_size_Ptsize/UMAP_of_clonotypes_found_in_module_", 
                  Module.vect[i], ".pdf"))
  dev.off()
  
  
  # Split by condition
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = clonotype.seurat@meta.data$Clonotype_freq_per_condition_scaled,
                 group.by = "Module", 
                 split.by = "condition",
                 cols = module.cols) +
          ggtitle(paste0("Clonotypes found in ", Module.vect[i])))
  
  dev.copy(pdf, 
           paste0("output/figures/TCRseq/Modules/Clonotype_size_Ptsize/UMAP_of_clonotypes_found_in_module_", 
                  Module.vect[i], "_splitby_condition.pdf"))
  dev.off()
  
  
  # Barplot of distribution
  x <- table(clonotype.seurat@meta.data$Module)
  
  print(barplot(x, 
                ylim = c(0, 3000),
                main = paste0("# of cells found to have a clonotype present in Module ", Module.vect[i]), 
                cex.names = 0.9, 
                las = 2))   
  
  dev.copy(pdf, paste0("output/figures/TCRseq/Modules/Barplot/Barplot_of_all_clonotypes_found_in_module_", Module.vect[i], ".pdf"))
  dev.off()
  
  
  # Boxplot of distribution as a frequency of cells within each module
  clonetype.specific.cells <- table(clonotype.seurat@meta.data$Module)
  total.cells.module <- table(seurat.tcr@meta.data$Module)
  
  x <- (clonetype.specific.cells/total.cells.module)*100
  
  print(barplot(x, 
                ylim = c(0, 100),
                main = paste0("% of Module found to match a clonotype present in Module ", Module.vect[i]), 
                cex.names = 0.9, 
                las = 2))   
  
  dev.copy(pdf, paste0("output/figures/TCRseq/Modules/Barplot/Barplot_of_freq_cells_with_clonotype_found_in_Module_",
                       Module.vect[i], ".pdf"))
  dev.off()
  
  
  # Remove unneeded variable
  rm(clonotype.seurat)
  
}





#### WORK IN PROGRESS ############################## ############################## ##############################
# RE-write below plot using dplyr formatting 


#############################################
# # of unique clonotypes per each module
#############################################

# Was inside for loop previously 
# calculate the number of unique clones found in the cluster
  
  #unique.clonotypes.n <- length(unique(clonotype.seurat@meta.data$CTaa))
  #print(paste0("# of unique clonotypes in module ", Module.vect[i], " is ", unique.clonotypes.n))
  #assign(paste0("N.unique.clones.", Module.vect[i]), unique.clonotypes.n)



#temp <- c(N.unique.clones.Naive_Stem, 
#          N.unique.clones.Activated, 
#          N.unique.clones.Exhaustion, 
#          N.unique.clones.Innate,
#          N.unique.clones.Cycling)


#names(temp) <- paste0(c("Naive", "Activated", "Exhaustion", "Innate", "Cycling"))

#barplot(temp,
#        main = "# of unique clonotypes per module",
#        ylab = "# unique clonotypes",
#        las = 2)

#dev.copy(pdf, "output/figures/TCRseq/Modules/Barplot/Module_unique_clonotypes.pdf")
#dev.off()


```

### Cluster-specific clonotypes
```{r Cluster_specific_clonotypes}

# Create output directories
if(!dir.exists("output/figures/TCRseq/Clusters/UMAP")){
  dir.create("output/figures/TCRseq/Clusters/UMAP",
             recursive = T)}

if(!dir.exists("output/figures/TCRseq/Clusters/Barplot")){
  dir.create("output/figures/TCRseq/Clusters/Barplot",
             recursive = T)}

if(!dir.exists("output/figures/TCRseq/Clusters/Clonotype_size_Ptsize")){
  dir.create("output/figures/TCRseq/Clusters/Clonotype_size_Ptsize",
             recursive = T)}

# Set Idents to Cluster ID
Idents(seurat.tcr) <- seurat.tcr@meta.data$seurat_clusters


###################################
# get Cluster specific clonotypes
###################################

Cluster.vect <- unique(levels(seurat.tcr@meta.data$seurat_clusters))

for(i in 1:length(Cluster.vect)){
  
  print(paste0("Performing analysis for Cluster = ", Cluster.vect[i]))
  
  
  # Extract clonotypes found in a specific module
  clonotype.seurat <- get.clonotypes(seurat.tcr, "seurat_clusters", Cluster.vect[i])
  
  
  ########################
  # Visualisation 
  ########################
  
  # Overall distribution of clonotypes 
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = 1,
                 group.by = "seurat_clusters",
                 cols = clust.cols) + 
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  dev.copy(pdf, 
           paste0("output/figures/TCRseq/Clusters/UMAP/UMAP_of_clonotypes_found_in_cluster_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  # Split by condition
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = 1,
                 group.by = "seurat_clusters", 
                 split.by = "condition", 
                 cols = clust.cols) + 
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  
  dev.copy(pdf, 
           paste0("output/figures/TCRseq/Clusters/UMAP/UMAP_of_clonotypes_found_in_cluster_", Cluster.vect[i], "_splitby_condition.pdf"))
  dev.off()
  
  ###############################
  # Point size = clonotype freq
  ###############################
  
  # Plot clonotype size
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = clonotype.seurat@meta.data$Total_clonotype_n_scaled,
                 group.by = "seurat_clusters", 
                 cols = clust.cols) +
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  dev.copy(pdf, 
           paste0("output/figures/TCRseq/Clusters/Clonotype_size_Ptsize/UMAP_of_clonotypes_found_in_cluster_", 
                  Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Split by condition
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = clonotype.seurat@meta.data$Clonotype_freq_per_condition_scaled,
                 group.by = "seurat_clusters", 
                 split.by = "condition",
                 cols = clust.cols) +
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  dev.copy(pdf, 
           paste0("output/figures/TCRseq/Clusters/Clonotype_size_Ptsize/UMAP_of_clonotypes_found_in_cluster_", 
                  Cluster.vect[i], "_splitby_condition.pdf"))
  dev.off()
  
  
  # Barplot of distribution / total number of cells 
  clonetype.specific.cells <- table(clonotype.seurat@meta.data$seurat_clusters)
  
  print(barplot(clonetype.specific.cells, 
                ylim = c(0, 1500),
                main = paste0("# of cells found to have a clonotype present in Cluster ", Cluster.vect[i]), 
                cex.names = 0.9, 
                las = 2))   
  
  dev.copy(pdf, 
           paste0("output/figures/TCRseq/Clusters/Barplot/Barplot_of_all_clonotypes_found_in_Cluster_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Boxplot of distribution as a frequency of cells within each cluster
  clonetype.specific.cells <- table(clonotype.seurat@meta.data$seurat_clusters)
  total.cells.cluster <- table(seurat.tcr@meta.data$seurat_clusters)
  
  x <- (clonetype.specific.cells/total.cells.cluster)*100
  
  print(barplot(x, 
                ylim = c(0, 100),
                main = paste0("% of cluster found to match a clonotype present in Cluster ", Cluster.vect[i]), 
                cex.names = 0.9, 
                las = 2))   
  
  dev.copy(pdf, paste0("output/figures/TCRseq/Clusters/Barplot/Barplot_of_freq_cells_with_clonotype_found_in_Cluster_", 
                       Cluster.vect[i], ".pdf"))
  dev.off()
  

  # Remove unneeded variable
  rm(clonotype.seurat)
}


```




## Reduce dataset to unique clonotypes
```{r unique_clones_per_cluster_per_condition}

# Create output directories
if(!dir.exists("output/figures/TCRseq/Unique_clonotypes")){
  dir.create("output/figures/TCRseq/Unique_clonotypes",
             recursive = T)}



######################################################################################
# Keep only one occurrence of a clonotype in each cluster for each condition
######################################################################################

uniq.clonotypes <- seurat.tcr@meta.data %>% 
  dplyr::distinct(seurat_clusters, CTaa, condition) %>%
  rownames()

unique.seurat.tcr <- subset(seurat.tcr, cells = uniq.clonotypes)



# Set Idents
Idents(unique.seurat.tcr) <- unique.seurat.tcr@meta.data$seurat_clusters

# Unique clonotypes per cluster per condition
UMAPPlot(unique.seurat.tcr, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         cols = clust.cols) + 
  ggtitle("Pts = unique clonotypes per cluster per condition")

dev.copy(pdf, "output/figures/TCRseq/Unique_clonotypes/Unique_clonotypes_perclust_percondition.pdf")
dev.off()

# Unique clonotypes per cluster per condition // No legend
UMAPPlot(unique.seurat.tcr, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         label = TRUE,
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("Pts = unique clonotypes per cluster per condition") + 
  NoLegend()

dev.copy(pdf, "output/figures/TCRseq/Unique_clonotypes/Unique_clonotypes_perclust_percondition_NoLegend.pdf")
dev.off()

# Split by condition
UMAPPlot(unique.seurat.tcr, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         cols = clust.cols) + 
  ggtitle("Pts = unique clonotypes per cluster per condition")

dev.copy(pdf, "output/figures/TCRseq/Unique_clonotypes/Unique_clonotypes_perclust_percondition_split_condition.pdf")
dev.off()

# Split by condtion // no legend
UMAPPlot(unique.seurat.tcr, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         label = TRUE, 
         label.size = 4,
         cols = clust.cols) + 
  ggtitle("Pts = unique clonotypes per cluster per condition") + 
  NoLegend()

dev.copy(pdf, "output/figures/TCRseq/Unique_clonotypes/Unique_clonotypes_perclust_percondition_split_condition_NoLegend.pdf")
dev.off()


#############################################
# Plot points scaled by clonotype freq
#############################################


Total.clonotype.scale <- unique.seurat.tcr@meta.data$Total_clonotype_n_scaled 

# Total dataset
UMAPPlot(unique.seurat.tcr, 
         pt.size = Total.clonotype.scale, 
         group.by = "seurat_clusters", 
         cols = clust.cols) + 
    ggtitle("unique clonotypes/clust/condition - scaled by total occurrence")

dev.copy(pdf, "output/figures/TCRseq/Unique_clonotypes/Unique_clonotypes_perclust_percondition_size_scaled.pdf")
dev.off()



# Total dataset // No legend
UMAPPlot(unique.seurat.tcr, 
         pt.size = Total.clonotype.scale, 
         group.by = "seurat_clusters", 
         label = TRUE, 
         label.size = 4,
         cols = clust.cols) + 
      ggtitle("unique clonotypes/clust/condition - scaled by total occurrence") +
  NoLegend()

dev.copy(pdf, "output/figures/TCRseq/Unique_clonotypes/Unique_clonotypes_perclust_percondition_size_scaled_NoLegend.pdf")
dev.off()


########################
# Split by condition
########################

Condition.clonotype.scale <- unique.seurat.tcr@meta.data$Clonotype_freq_per_condition_scaled 

# Split by condition
UMAPPlot(unique.seurat.tcr, 
         pt.size = Condition.clonotype.scale, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         cols = clust.cols) + 
    ggtitle("unique clonotypes/clust/condition - scaled by condition freq")

dev.copy(pdf, "output/figures/TCRseq/Unique_clonotypes/Unique_clonotypes_perclust_percondition_size_scaled_splitcondition.pdf")
dev.off()


# Split by condition // No legend
UMAPPlot(unique.seurat.tcr, 
         pt.size = Condition.clonotype.scale, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         label = TRUE, 
         label.size = 4,
         cols = clust.cols) + 
    ggtitle("unique clonotypes/clust/condition - scaled by condition freq") + 
  NoLegend()

dev.copy(pdf, "output/figures/TCRseq/Unique_clonotypes/Unique_clonotypes_perclust_percondition_size_scaled_splitcondition_NoLegend.pdf")
dev.off()


```
 
 
 
### Cluster-specific clonotypes -- plotting just unique clonotypes
```{r Cluster_specific_clonotypes_unique_clonotypes}

# Create output directories
setwd(working.dir)

if(!dir.exists("output/figures/TCRseq/Clusters/Unique_clonotypes/Clonotype_size_Ptsize")){
  dir.create("output/figures/TCRseq/Clusters/Unique_clonotypes/Clonotype_size_Ptsize",
             recursive = T)}

if(!dir.exists("output/figures/TCRseq/Clusters/Unique_clonotypes/UMAP")){
  dir.create("output/figures/TCRseq/Clusters/Unique_clonotypes/UMAP",
             recursive = T)}

if(!dir.exists("output/figures/TCRseq/Clusters/Unique_clonotypes/Barplot")){
  dir.create("output/figures/TCRseq/Clusters/Unique_clonotypes/Barplot",
             recursive = T)}


output.dir <- "output/figures/TCRseq/Clusters/Unique_clonotypes"
setwd(output.dir)


# Set Idents to Cluster ID
Idents(unique.seurat.tcr) <- unique.seurat.tcr@meta.data$seurat_clusters

###################################
# get Cluster specific clonotypes
###################################

Cluster.vect <- unique(levels(unique.seurat.tcr@meta.data$seurat_clusters))

for(i in 1:length(Cluster.vect)){
  
  print(paste0("Performing analysis for Cluster = ", Cluster.vect[i]))
  
  
  # Extract clonotypes found in a specific module
  clonotype.seurat <- get.clonotypes(unique.seurat.tcr, "seurat_clusters", Cluster.vect[i])
  
  
  ########################
  # Visualisation 
  ########################
  
  # Overall distribution of clonotypes 
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = 1,
                 group.by = "seurat_clusters",
                 cols = clust.cols) + 
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  dev.copy(pdf, 
           paste0("UMAP/UMAP_of_clonotypes_found_in_cluster_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  # Split by condition
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = 1,
                 group.by = "seurat_clusters", 
                 split.by = "condition", 
                 cols = clust.cols) + 
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  
  dev.copy(pdf, 
           paste0("UMAP/UMAP_of_clonotypes_found_in_cluster_", Cluster.vect[i], "_splitby_condition.pdf"))
  dev.off()
  
  ###############################
  # Point size = clonotype freq
  ###############################
  
  # Plot clonotype size
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = clonotype.seurat@meta.data$Total_clonotype_n_scaled,
                 group.by = "seurat_clusters", 
                 cols = clust.cols) +
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  dev.copy(pdf, 
           paste0("Clonotype_size_Ptsize/UMAP_of_clonotypes_found_in_cluster_", 
                  Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Split by condition
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = clonotype.seurat@meta.data$Clonotype_freq_per_condition_scaled,
                 group.by = "seurat_clusters", 
                 split.by = "condition",
                 cols = clust.cols) +
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  dev.copy(pdf, 
           paste0("Clonotype_size_Ptsize/UMAP_of_clonotypes_found_in_cluster_", 
                  Cluster.vect[i], "_splitby_condition.pdf"))
  dev.off()
  
  
  # Barplot of distribution / total number of unique clonotypes 
  n.unique.clonotypes <- table(clonotype.seurat@meta.data$seurat_clusters)
  
  print(barplot(n.unique.clonotypes, 
                ylim = c(0, 1000),
                main = paste0("# unique clonotypes which overlap with those found in Cluster ", Cluster.vect[i]), 
                cex.names = 0.9, 
                las = 2))   
  
  dev.copy(pdf, 
           paste0("Barplot/Barplot_of_clonotypes_found_in_Cluster_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Boxplot of distribution as a frequency of cells within each cluster
  n.unique.clonotypes <- table(clonotype.seurat@meta.data$seurat_clusters)
  total.n.clonotypes <- table(unique.seurat.tcr@meta.data$seurat_clusters)
  
  x <- (n.unique.clonotypes/total.n.clonotypes)*100
  
  print(barplot(x, 
                ylim = c(0, 100),
                main = paste0("% of unique clonotypes which match clonotypes present in Cluster ", Cluster.vect[i]), 
                cex.names = 0.9, 
                las = 2))   
  
  dev.copy(pdf, paste0("Barplot/Barplot_of_freq_of_unique_clonotypes_found_in_Cluster_", 
                       Cluster.vect[i], ".pdf"))
  dev.off()
  

  # Remove unneeded variable
  rm(clonotype.seurat)
}


setwd(working.dir)

```

 ### Cluster-specific & condition-specific clonotypes 
 
 ### Cluster-specific & condition-specific clonotypes -- just unique clonotypes 

 ### Shared clonotypes 
 
 ### Distinct clonotypes 
 
 
 
 
 
 
 
 
 
 #### MAIN TCR WORKING CHUNK !!!
 ### WORK IN PROGRESS --- unique clonotypes - get and plot clonotypes found in clust X across all
```{r}





UMAPPlot(unique.seurat.tcr, 
         pt.size = unique.total.freq.scaled, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         cols = clust.cols)


# Get unique clonotypes specific to a cluster and stim condition

condition.clust.vec <- unique(unique.seurat.tcr@meta.data$condition_clust)



for(i in 1:length(condition.clust.vec)){
  
  print(paste0("Performing analysis for Cluster = ", condition.clust.vec[i]))
  
  
  # Extract clonotypes found in specific cluster - condition combination
  clonotype.seurat <- get.clonotypes(unique.seurat.tcr, "condition_clust", condition.clust.vec[i])
  
  
  ########################
  # Visualisation 
  ########################
  
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = 1,
                 group.by = "seurat_clusters", 
                 split.by = "condition", 
                 cols = clust.cols) + 
          ggtitle(paste0("Clonotypes found in ", condition.clust.vec[i])))
  
  
  dev.copy(pdf, 
           paste0("output/figures/TCRseq/Unique_clonotypes/Distribution_of_unique_clonotypes_found_in_", 
                  condition.clust.vec[i], ".pdf"))
  dev.off()
  
  
  
  ######################################
  # Point size by clonotype frequency 
  ######################################
  
  # Use scale from total dataset so pt sizes are comparable across plots
  logic.vec <- names(unique.total.freq.scaled) %in% rownames(clonotype.seurat@meta.data)
  cluster.freq <- unique.total.freq.scaled[logic.vec]
  
  # need to order freq vector to match new seurat object order
  cluster.freq <- cluster.freq[order(factor(names(cluster.freq), levels = rownames(clonotype.seurat@meta.data)))]
  
  # Plot clonotype size
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = cluster.freq, 
                 group.by = "seurat_clusters", 
                 split.by = "condition",
                 cols = clust.cols) +
          ggtitle(paste0("Clonotypes found in ", condition.clust.vec[i])))
  
  dev.copy(pdf, 
           paste0("output/figures/TCRseq/Unique_clonotypes/Distribution_of_unique_clonotypes_found_in_", 
                  condition.clust.vec[i], "_ptsize_by_clonotypeFreq.pdf"))
  dev.off()
  
  
  # Remove large data object
  rm(clonotype.seurat)
  
}


    
  

# TO DO:
# Colour stim unique clones - which clones are conserved across condition which are unique 
# Which clones are unique to US or Stim 
# Track top US and Top Stim clones
# Get and plot clones found in US samples and see presence in Stim (vice versa) 
# Can freq be compared across US and Stim? if not- normalise freq?? for comparison of expansion/retraction 
# Get and plot clonotypes in a US/stim specific manner. 



####### WORKING AREA ######

colnames(unique.seurat.tcr@meta.data)
  


US.seurat <- get.clonotypes(seurat.tcr, "condition", "US")

US.seurat
freq.val <- US.seurat@meta.data$Frequency
freq.scaled <- scales::rescale(freq.val, to = c(0, 10))



UMAPPlot(US.seurat, 
           pt.size = freq.scaled, 
           group.by = "seurat_clusters", 
           split.by = "condition",
           cols = clust.cols)




head(sort(table(US.seurat$CTaa), decreasing = T))





  
seurat.tcr <- highlightClonotypes(seurat.tcr, cloneCall= "aa", 
                                  sequence = c("CARYNQGGKLIF_CASSLVVGRGNTIYF"))

DimPlot(seurat.tcr, group.by = "highlight", pt.size = 1, split.by = "condition")





Idents(US.seurat) <- US.seurat@meta.data$highlight
temp.seurat <- subset(US.seurat, ident = "Clonotype1")


UMAPPlot(temp.seurat, 
           pt.size = 1, 
           group.by = "seurat_clusters", 
           split.by = "condition",
           cols = clust.cols)



  
  
     # Use scaled.freq value from total seurat.tcr object to ensure scaling is across all cells
  
  logic.vec <- names(total.freq.scaled) %in% rownames(unique.seurat.tcr@meta.data)
  cluster.freq <- total.freq.scaled[logic.vec]
  
  # need to order freq vector to match new seurat object order
  cluster.freq <- cluster.freq[order(factor(names(cluster.freq), levels = rownames(unique.seurat.tcr@meta.data)))]
    
    
    UMAPPlot(unique.seurat.tcr, 
           pt.size = cluster.freq, 
           group.by = "seurat_clusters", 
           split.by = "condition",
           cols = clust.cols)
  
  
  unique.seurat.tcr@meta.data %>% 
  dplyr::distinct(seurat_clusters, CTaa) -> z
  rm(combined.contig, )
  
  
  
  
  
  ################################
  # TO DO 
  #################################
  # Normalise freq by cell number per condition 
  # Calculate total freq (not freq per condition) - change plots to show total freq 
  # Plot pt.size = clonefreq split and together with clusters annotated. 
  # track cytotoxic clonotypes - are they converting 
  # get US specific clones and plot 
  # get Stim specific clones 
  # get US/Stim unique clones 
  # Are clones lost or transition ? 
  # Compare no-TCR cells - are clones lost or down-regulate TCR? 
  # Do type1 or Cyto clusters transition to exhausted
  # exhausted 1 vs exhausted 2
  
  
  
  
  
  table(seurat.tcr@meta.data$CTaa)
  
  colnames(seurat.tcr@meta.data)
  
  
  
  # CALSEFPNDYKLSF_CASSLRAGGTDTQYF = 32
  
  seurat.tcr@meta.data %>% 
    dplyr::filter(CTaa == "CALSEFPNDYKLSF_CASSLRAGGTDTQYF") %>%
    dplyr::select(CTaa, clonotype_id_A, clonotype_id_B, v_gene_A, v_gene_B, cdr3_nt_A, cdr3_nt_B, Frequency, condition, group) -> temp
  
    table(temp$CTaa, temp$condition)

  
  
  FeaturePlot(seurat.tcr, "ENTPD1", pt.size = 1)
  
```



 ## TCR analysis - Unique and shared clonotypes (US vs. Stim) {.tabset}






















### TCR analysis variable set up
```{r TCR_analysis_setup}

# Create output directories
if(!dir.exists("output/figures/TCRseq")){
  dir.create("output/figures/TCRseq",
             recursive = T)}

# Set up ident
Idents(seurat.combined) <- seurat.combined@meta.data$condition_clust

# General stats on dataset

# Note that vars clonotype_id_A and id_B are identical 
NoClone.N <- sum(is.na(seurat.combined@meta.data$clonotype_id_A))
print(paste0(NoClone.N, " cells have no clonotype identified")) # 4,918

Cell.N <- nrow(seurat.combined@meta.data)
print(paste0("This represents ", signif(NoClone.N/Cell.N * 100), " % of the dataset")) # 41.58% of the data has no clonotype info

# therefore number of cells with a combined alpha/beta tcr call is 
Clone.N <- sum(!is.na(seurat.combined@meta.data$clonotype_id_B))
print(paste0(Clone.N, " cells have complete clonotype identified")) # 6,909

print(paste0("This represents ", signif(Clone.N/Cell.N * 100), " % of the dataset")) # 58.41% of the data has an alpha/beta pair



#################################################################################
# Generate a seurat object for just the cells with a called TCR
#################################################################################
Cells.with.TCR <- rownames(seurat.combined@meta.data[!is.na(seurat.combined@meta.data$clonotype_id_A), ])
seurat.tcr <- subset(seurat.combined, cells = Cells.with.TCR)
seurat.tcr

# Extract metadata for analysis
seurat.tcr.metadata <- seurat.tcr@meta.data

# Generate table number of cells for each clonotype - note clonotype_id_A and B are equiv
All.clonotypes <- sort(table(seurat.tcr.metadata$clonotype_id_A), decreasing = TRUE)
head(All.clonotypes, 20)

#############################################
# Filter out low abundance clonotypes
#############################################

# filt out low clonal clonotypes 
# i.e those expressed in fewer than 3 cells in entire dataset 

clonal.min <- 3

logic.vec <- All.clonotypes < clonal.min
low.n <- sum(logic.vec) # 3,519 clones 
total.n <- length(logic.vec) # 3,918 clones in total 

# Filtering stats
# freq of clones found in < clonal.min cells is
print(paste0("Freq of clones that have < ", clonal.min, " cells = ", signif(low.n/total.n*100, 4), "%"))
print(paste0("Number of clones occur in > than ", clonal.min, " cells = ", sum(!logic.vec)))

# Filter data
clonotypes.keep <- names(All.clonotypes)[!logic.vec]

Idents(seurat.tcr) <- seurat.tcr@meta.data$clonotype_id_A
seurat.tcr <- subset(seurat.tcr, idents = clonotypes.keep)

length(levels((Idents(seurat.tcr)))) # should equal number of clonotypes selected for 

# Reset Ident
Idents(seurat.tcr) <- seurat.tcr@meta.data$condition_clust


```


### WORK IN PROGRESS 
```{r}



# Vis clonotype size on UMAP
UMAPPlot(seurat.tcr, 
         group.by = "cloneType", 
         pt.size = 1) +
  scale_color_manual(values = clonetype.col, 
                     na.value="grey")












freq.val <- seurat.tcr@meta.data$umis_B


UMAPPlot(seurat.tcr, 
         pt.size = (freq.val/10),
         group.by = "seurat_clusters", 
         split.by = "condition")  





UMAPPlot(seurat.tcr, 
         pt.size = (freq.val/5) + 0.5,
         group.by = "seurat_clusters", 
         split.by = "cloneType")  


?scale

scale_size_manual(values = as.factor(freq.val), limits = 10)



UMAPPlot(seurat.tcr, 
         pt.size = freq.val,
         group.by = "seurat_clusters", 
         split.by = "condition", 
         cols = clust.cols)  



UMAPPlot(seurat.tcr, 
         pt.size = 1,
         group.by = "seurat_clusters", 
         label= T,
         cols = clust.cols)  


UMAPPlot(seurat.tcr, 
         pt.size = 1,
         group.by = "Module", 
         label = T, 
         cols = module.cols)








14-8

temp <- seurat.tcr@meta.data[1:50, ]


scale_size(range = freq.val) + 
  guides(color= guide_legend(), size=guide_legend())

scale_size_continuous()

head(temp)


?scale_size_continuous

#S1_clonotype4
#CAMREGRINYGQNFVF_CSARDEEGGYTF

seurat.tcr@meta.data %>% 
  dplyr::filter(CTaa == "CAMREGRINYGQNFVF_CSARDEEGGYTF" & condition == "US")-> temp 



dim(temp)


```


### WORK progress
```{r tcr_analysis_work_in_progress}










VlnPlot(seurat.tcr, "Frequency", pt.size = 0.1, group.by = "Module")


UMAPPlot(seurat.tcr, 
         group.by = "cloneType", 
         split.by = "condition", 
         pt.size = 1) +
  scale_color_manual(values = c(rev(colorblind_vector(5))), 
                     na.value="grey")


UMAPPlot(seurat.tcr, 
         group.by = "condition", 
         split.by = "cloneType", 
         pt.size = 1)# +
scale_color_manual(values = c(rev(colorblind_vector(5))), 
                   na.value="grey")




t_col <- function(color, percent = 50, name = NULL) {
  #      color = color name
  #    percent = % transparency
  #       name = an optional name for the color
  
  ## Get RGB values for named color
  rgb.val <- col2rgb(color)
  
  ## Make new color using input color as base and alpha set by transparency
  t.col <- rgb(rgb.val[1], rgb.val[2], rgb.val[3],
               max = 255,
               alpha = (100 - percent) * 255 / 100,
               names = name)
  
  ## Save the color
  invisible(t.col)
}


transparent <- t_col("blue", perc = 100, name = "transparent.blue")





p1 <- UMAPPlot(seurat.tcr, 
               label = TRUE,
               group.by = "seurat_clusters") + NoLegend()

p2 <- UMAPPlot(seurat.tcr, 
               label = TRUE, 
               group.by = "Module") + NoLegend()



p1




seurat.tcr@meta.data




table <- table(seurat.tcr$condition, seurat.tcr$seurat_clusters)
table[1,] <- table[1,]/sum(table[1,]) # Scaling by the total number of US
table[2,] <- table[2,]/sum(table[2,]) # Scaling by the total number of Stim
table <- as.data.frame(table)
table$Var2 <- factor(table$Var2)

ggplot(table, aes(x=Var2, y=Freq, fill=Var1)) + 
  geom_bar(stat="identity", position="fill", color="black", lwd=0.25) + 
  theme(axis.title.x = element_blank()) + 
  scale_fill_manual(values = c("#FF4B20","#0348A6")) + 
  theme_classic() + 
  theme(axis.title = element_blank(), axis.text.x = element_text(angle = 90))



colorblind_vector <- colorRampPalette(c("#FF4B20", "#FFB433", "#C6FDEC", "#7AC5FF", "#0348A6"))

slot(seurat.tcr, "meta.data")$cloneType <- factor(slot(seurat.tcr, "meta.data")$cloneType, 
                                                  levels = c("Hyperexpanded (100 < X <= 500)", "Large (20 < X <= 100)", 
                                                             "Medium (5 < X <= 20)", "Small (1 < X <= 5)", 
                                                             "Single (0 < X <= 1)", NA))

p3 <- UMAPPlot(seurat.tcr, 
               group.by = "cloneType", 
               split.by = "condition", 
               pt.size = 1) +
  scale_color_manual(values = c(rev(colorblind_vector(5))), 
                     na.value="grey")



cloneType.col <- c(rev(colorblind_vector(5)))

Idents(seurat.tcr) <- seurat.tcr@meta.data$seurat_clusters

temp.seurat <- subset(seurat.tcr, idents = "TRM") 


p3 <- UMAPPlot(seurat.tcr, 
               group.by = "seurat_clusters",
               split.by = "cloneType",
               label = FALSE,
               #cols = cloneType.col,
               pt.size = 1) + NoLegend()


p4 <- UMAPPlot(seurat.tcr, 
               group.by = "Module",
               split.by = "cloneType",
               label = FALSE,
               #cols = cloneType.col,
               pt.size = 1) + NoLegend()


p5 <- UMAPPlot(seurat.tcr, 
               group.by = "cloneType",
               label = FALSE,
               cols = cloneType.col,
               pt.size = 1) + NoLegend()

p6 <- UMAPPlot(seurat.tcr, 
               group.by = "seurat_clusters",
               split.by = "condition",
               label = FALSE,
               #cols = cloneType.col,
               pt.size = 1) + NoLegend()


(p1+p6)/p3



#+
#   scale_color_manual(values = c(rev(colorblind_vector(5))), 
#                     na.value="grey")




p1/p3
seurat.tcr@meta.data



Idents(seurat.tcr) <- seurat.tcr@meta.data$seurat_clusters

meta <- data.frame(seurat.tcr[[]], Idents(seurat.tcr)) 
ggplot(meta, aes(x=Idents.seurat.tcr., y=Frequency)) + 
  geom_boxplot(outlier.alpha = 0.5, aes(fill=Idents.seurat.tcr.)) + 
  guides(fill=FALSE) + 
  theme_classic() + 
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 90))


head(unique(seurat.tcr@meta.data$CTaa[order(seurat.tcr@meta.data$Frequency, decreasing = T)]))

seurat.tcr <- highlightClonotypes(seurat.tcr, cloneCall= "aa", 
                                  sequence = c("CAMFTGNQFYF_CASREGNSPLHF", "CAVRDLAGNMLTF_CASSLSPGQGHYEQYF", "CVVTSPMDSNYQLIW_CASSSRPTGTGELFF"))
DimPlot(seurat.tcr, group.by = "highlight", pt.size = 1, split.by = "condition")







alluvialClonotypes(seurat.tcr, cloneCall = "aa", 
                   y.axes = c("group", "seurat_clusters", "condition"), 
                   color = c("CAVRDLAGNMLTF_CASSLSPGQGHYEQYF", "CVVTSPMDSNYQLIW_CASSSRPTGTGELFF")) + 
  scale_fill_manual(values = c("grey", colorblind_vector(1)))

head(unique(seurat.tcr@meta.data$CTaa[order(seurat.tcr@meta.data$Frequency, decreasing = T)]))


alluvialClonotypes(seurat.tcr, 
                   cloneCall = "aa", 
                   y.axes = c("group", "seurat_clusters", "condition"), 
                   color = "condition") 






```













### Expression of TCR genes
```{r TCR_gene_expression}

# Create output directories
if(!dir.exists("output/figures/TCR_gene_expression")){
  dir.create("output/figures/TCR_gene_expression",
             recursive = T)}



Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
DefaultAssay(seurat.combined) <- "RNA"

genes <- rownames(seurat.combined)

TRG.genes <- grep("TRG", genes, value = T)
TRD.genes <- grep("TRD", genes, value = T)

TRAV.genes <- grep("TRAV", genes, value = T)
TRBV.genes <- grep("TRBV", genes, value = T)

TRBC.genes <- grep("TRBC", genes, value = T)
TRAC.genes <- grep("TRAC", genes, value = T)

TCR.genes <- unique(c(TRG.genes, TRD.genes, TRAV.genes, TRBV.genes, TRBC.genes, TRAC.genes))



for(i in 1:length(TCR.genes)){
  print(paste0("Plotting ", TCR.genes[i]))
  
  skip.iteration <- FALSE
  tryCatch(print(VlnPlot(seurat.combined, 
                         paste0(TCR.genes[i]),
                         log = T,
                         group.by = "seurat_clusters",
                         pt.size = 0)),
           error = function(e){skip.iteration <- TRUE})
  if(skip.iteration){next}
  
  
  dev.copy(pdf, paste0("output/figures/TCR_gene_expression/VlnPlot_", TCR.genes[i], ".pdf"))
  dev.off()
  
}




############################################
# Plot heatmap of TCR G/D gene expression
############################################

DefaultAssay(seurat.combined) <- "RNA"

Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Subset data for innate module 
Innate.seurat <- subset(seurat.combined, idents = "Innate")

Idents(Innate.seurat) <- Innate.seurat@meta.data$seurat_clusters

# Get average expression
Innate.seurat <- AverageExpression(Innate.seurat,
                                   assay = "RNA",
                                   slot = "data",
                                   verbose = TRUE,
                                   return.seurat = TRUE)

GD.TCR.genes <- sort(unique(c(TRG.genes, TRD.genes)), decreasing = FALSE)

DoHeatmap(Innate.seurat, 
          features = GD.TCR.genes,
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "output/figures/TCR_gene_expression/Heatmap_TCRgd_Gene_expression_.pdf")
dev.off()

rm(Innate.seurat)


```


### Expression of TCR genes - Imputed
```{r TCR_gene_expression_imputed}

# Create output directories
if(!dir.exists("output/figures/TCR_gene_expression_imputed")){
  dir.create("output/figures/TCR_gene_expression_imputed",
             recursive = T)}


DefaultAssay(seurat.combined) <- "alra"


genes <- rownames(seurat.combined)

TRG.genes <- grep("TRG", genes, value = T)
TRD.genes <- grep("TRD", genes, value = T)

TRAV.genes <- grep("TRAV", genes, value = T)
TRBV.genes <- grep("TRBV", genes, value = T)

TRBC.genes <- grep("TRBC", genes, value = T)
TRAC.genes <- grep("TRAC", genes, value = T)

TCR.genes <- unique(c(TRG.genes, TRD.genes, TRAV.genes, TRBV.genes, TRBC.genes, TRAC.genes))


for(i in 1:length(TCR.genes)){
  print(paste0("Plotting ", TCR.genes[i]))
  
  skip.iteration <- FALSE
  tryCatch(print(VlnPlot(seurat.combined, 
                         paste0(TCR.genes[i]),
                         log = T,
                         group.by = "seurat_clusters",
                         pt.size = 0)),
           error = function(e){skip.iteration <- TRUE})
  if(skip.iteration){next}
  
  
  dev.copy(pdf, paste0("output/figures/TCR_gene_expression_imputed/VlnPlot_", TCR.genes[i], ".pdf"))
  dev.off()
  
}



```






```{r asd}



seurat.tcr




top.clonotypes <- sort(table(seurat.tcr@meta.data$CTaa), decreasing = T)


```










### Immunarch analysis
```{r immunarch}

# Single cell functions are currently only in development version of data
#devtools::install_github("immunomind/immunarch", ref="dev")

library("immunarch")

file_path = "Input_data/VDJ_data/"


immdata_10x <- repLoad(file_path, .mode = "paired")






?repLoad



# Barcodes have appended sample ID to them // this needs to be removed for matching 


Idents(seurat.combined) <- "group"
temp.seurat <- subset(seurat.combined, idents = "S1")

Idents(temp.seurat) <- "Module"

barcodes.vect <- Idents(temp.seurat)
names(barcodes.vect) <- gsub("*._", "",  names(barcodes.vect))
barcodes.vect



immdata_10x$meta$Sample[1] <- barcodes.vect



temp <- select_clusters(.data = immdata_10x, .clusters = barcodes.vect)




head(immdata_10x$data$Sample1_filtered_contig_annotations$Barcode)











repOverlap(immdata_10x$data) %>% vis()
repDiversity(immdata_10x$data) %>% vis()

immdata_10x$data$Sample1_filtered_contig_annotations$Barcode

repOverlapAnalysis(immdata_10x$data, "mds") %>% vis()
imm_raref <- repDiversity(immdata_10x$data, "raref", .verbose = F)

p1 <- vis(imm_raref)
p2 <- vis(imm_raref, .by = "Status", .meta = immdata$meta)

p1 + p2




dim(temp)


data(scdata)
scdata$data[[1]]
scdata$bc_patient
scdata$data$flu$
  scdata$bc_cluster



```











## CHUNK NEEDS TO BE EDITED 
### Investigate cluster-specific clonotypes // IN PROGRESS
```{r cluster_specific_clonotypes}


# Create output directories
if(!dir.exists("output/figures/TCRseq")){
  dir.create("output/figures/TCRseq",
             recursive = T)}

if(!dir.exists("output/figures/TCRseq/Clusters")){
  dir.create("output/figures/TCRseq/Clusters",
             recursive = T)}

clust.vect <- unique(levels(seurat.tcr$seurat_clusters))


for(i in 1:length(clust.vect)){
  
  print(paste0("Performing analysis for cluster = ", clust.vect[i]))
  
  # set idents to clusters
  Idents(seurat.tcr) <- seurat.tcr$seurat_clusters
  
  # Subset by cluster
  clust.specific.seurat <- subset(seurat.tcr, idents = clust.vect[i])
  
  # get list of clonotypes in selected cluster
  clust.specific.clones <- sort(table(clust.specific.seurat@meta.data$clonotype_id_A), decreasing = TRUE)
  
  # Find all cells that have these clonotypes
  keep.logic <- seurat.tcr@meta.data$clonotype_id_A %in% names(clust.specific.clones)
  cells.with.clust.sp.clones <- rownames(seurat.tcr@meta.data)[keep.logic]
  
  # Subset seurat by these cell IDs
  seurat.clust.specific.clones <- subset(seurat.tcr, cells = cells.with.clust.sp.clones)
  
  
  ################################
  # Visualisation and output
  ################################
  
  # UMAP visualisation 
  print(UMAPPlot(seurat.clust.specific.clones, 
                 group.by = "seurat_clusters"))
  
  dev.copy(pdf, paste0("output/figures/TCRseq/Clusters/UMAP_of_distribution_of_all_clonotypes_found_in_clust_", clust.vect[i], ".pdf"))
  dev.off()
  
  # Barplot of distribution
  x <- table(seurat.clust.specific.clones@meta.data$seurat_clusters)
  
  print(barplot(x, 
                main = paste0("# of cells found to have a clonotype present in clust ", clust.vect[i]), 
                cex.names = 0.9, 
                las = 2))   
  
  dev.copy(pdf, paste0("output/figures/TCRseq/Clusters/Barplot_of_distribution_of_all_clonotypes_found_in_clust_", clust.vect[i], ".pdf"))
  dev.off()
  
  
  
  # calculate the number of unique clones found in the cluster
  unique.clonotypes <- unique(names(clust.specific.clones))
  unique.clonotypes.n <- length(unique.clonotypes)
  
  print(paste0("# of unique clonotypes in cluster ", clust.vect[i], " is ", unique.clonotypes.n))
  
  assign(paste0("N.unique.clones.", clust.vect[i]), unique.clonotypes.n)
  
}




temp <- c(N.unique.clones.0, 
          N.unique.clones.1, 
          N.unique.clones.2, 
          N.unique.clones.3,
          N.unique.clones.4,
          N.unique.clones.5,
          N.unique.clones.6,
          N.unique.clones.7,
          N.unique.clones.8,
          N.unique.clones.9,
          N.unique.clones.10,
          N.unique.clones.11,
          N.unique.clones.12,
          N.unique.clones.13,
          N.unique.clones.14,
          N.unique.clones.15,
          N.unique.clones.16)
names(temp) <- paste0(c(0:16))

barplot(temp, main = "# of unique clonotypes per cluster")


UMAPPlot(seurat.combined, 
         group.by = "seurat_clusters",
         split.by = "group",
         pt.size = 1, 
         label = TRUE,
         label.size = 7) + 
  NoLegend()

seurat.tcr@meta.data$seurat_clusters
#

UMAPPlot(seurat.tcr, 
         group.by = "clonotype_id_A", 
         pt.size = 1) + 
  NoLegend()




# number of cells in each cluster with a cluster specific clone set 
# number of unique clonotypes in each cluster 
# dont forget to perhaps filter out clonotypes with < 3 cells or something of the sort 













#colvals <- c("Activated", "Naive/memory", "Unclear-1",
#        "Exhausted", "Stem-like", "IFN-driven/Helper",
#           "GammaDelta", "Tissue-Resident", "MAIT")



colvals <- c(rep(US))

output.df <- matrix(data = NA, nrow = length(top.clones), ncol = length(colvals))
colnames(output.df) <- colvals
rownames(output.df) <- rep("NA", length(top.clones))

for(i in 1:length(top.clones)){
  logic.vec <- clones.seurat@meta.data$clonotype_id == names(top.clones)[i]
  
  output.df[i,] <- table(clones.seurat@meta.data$condition_clust[logic.vec])
  rownames(output.df)[i] <- names(top.clones)[i]
}

output.df


# breaks.seq <- seq(from = -0.5, to = 0.5, length.out = 101)
# 
# breaks.seq

heatmap.2(as.matrix(output.df),
          col = colorRampPalette(c("blue", "white", "red"))(100), #bluered,
          scale = c("row"),
          na.rm = TRUE, 
          trace = "none",
          Rowv = TRUE,
          Colv = FALSE,  
          hclustfun = function(x) hclust(x,method = 'ward.D2'),
          distfun = function(x) dist(x,method = 'manhattan'),
          dendrogram = "both",
          margins = c(10, 7),
          cexCol = 0.8,
          cexRow = 0.6,
          main = paste0("US clones >= ", clone.min, " clone size"),
          key = TRUE,
          keysize = 1.3, 
          notecol = "cyan",
          na.color = "black",
          #breaks = breaks.seq,
          srtCol = 90)





# Reorder output.df 

reordered.df <- output.df[ , c(1, 3, 4, 8, 2, 5, 6, 7, 9)]


heatmap.2(as.matrix(reordered.df),
          col = colorRampPalette(c("blue", "white", "red"))(100), #bluered,
          scale = c("row"),
          na.rm = TRUE, 
          trace = "none",
          Rowv = TRUE,
          Colv = FALSE,  
          hclustfun = function(x) hclust(x,method = 'ward.D2'),
          distfun = function(x) dist(x,method = 'manhattan'),
          dendrogram = "both",
          margins = c(10, 7),
          cexCol = 0.8,
          cexRow = 0.6,
          main = paste0("US clones >= ", clone.min, " clone size"),
          key = TRUE,
          keysize = 1.3, 
          notecol = "cyan",
          na.color = "black",
          #breaks = breaks.seq,
          srtCol = 90)



#


















########################################
# Investigating MAIT clonotypes
########################################

seurat.tcr.mait <- subset(seurat.tcr, ident = "MAIT")


Idents(seurat.tcr)







############################################













# VDJ data 
S1.TCR.df <- read.csv("VDJ_data/Sample1_filtered_contig_annotations.csv")
S2.TCR.df <- read.csv("VDJ_data/Sample2_filtered_contig_annotations.csv")
S3.TCR.df <- read.csv("VDJ_data/Sample3_filtered_contig_annotations.csv")
S4.TCR.df <- read.csv("VDJ_data/Sample4_filtered_contig_annotations.csv")

# Clonotype info
S1.Clonotype.df <- read.csv("VDJ_data/Sample1_clonotypes.csv")
S2.Clonotype.df <- read.csv("VDJ_data/Sample2_clonotypes.csv")
S3.Clonotype.df <- read.csv("VDJ_data/Sample3_clonotypes.csv")
S4.Clonotype.df <- read.csv("VDJ_data/Sample4_clonotypes.csv")






```




### Broad TCR visualisation // IN PROGRESS
```{r vis_of_TCR_data}


# TO Do 
# split umap tcr plots by condition 
# calculate and plot number of unique tcrs 
# calculate % of population that has a a/b tcr pair identified and plot 
# can constraing umap plots to same axes for looped analysis? 
# add labels to umap plots as colour changes 


# Non-tcr specific, # of cells per clust pre and post stim 
# % pre and post stim



# note exp info matthias and tobias have said 
# i.e CD3+ CD8+ and CD4- sort 
# stim length? 
# 4 patients per Sample 
# S1 - S3 and S2 - S4




# Output directory 
if(!dir.exists("output/figures/TCRseq/Broad_Vis")){
  dir.create("output/figures/TCRseq/Broad_Vis",
             recursive = T)}


# Set assay and idents 
DefaultAssay(seurat.tcr) <- "RNA"
Idents(seurat.tcr) <- seurat.tcr@meta.data$seurat_clusters


# Distribution of filtered TCR data

# Overall
UMAPPlot(seurat.tcr, 
         group.by = "seurat_clusters",
         pt.size = 1, 
         label = TRUE,
         label.size = 5) + 
  NoLegend()

dev.copy(pdf, "output/figures/TCRseq/Broad_Vis/UMAP_distribution_of_cells_with_paired_TCR_per_cluster.pdf")
dev.off()


# by sample id and grouped by cluster id
UMAPPlot(seurat.tcr, 
         group.by = "seurat_clusters",
         split.by = "group",
         pt.size = 1, 
         label = FALSE,
         label.size = 5)

dev.copy(pdf, "output/figures/TCRseq/Broad_Vis/UMAP_distribution_of_cells_with_paired_TCR_across_samples_per_cluster.pdf")
dev.off()

# By condition
UMAPPlot(seurat.tcr, 
         group.by = "seurat_clusters",
         split.by = "condition",
         pt.size = 1, 
         label = FALSE)

dev.copy(pdf, "output/figures/TCRseq/Broad_Vis/UMAP_distribution_of_cells_with_paired_TCR_per_condition.pdf")
dev.off()

```

### Code chunk needs to be rewritten to work with the filtered alpha/beta paired only data that everything else uses 
### Broad overview analysis // IN PROGRESS
```{r TCR_analysis}

# Installation for scRepertoire requires many dependents  
# See https://github.com/ncborcherding/scRepertoire for info


############################
# Install packages
############################

pkgs <- c("gsl", "Biostrings", 
          "ComplexHeatmap", "powerTCR", 
          "multtest")


for(i in 1:length(pkgs)){
  if(!require(pkgs[i], character.only = T)){
    BiocManager::install(pkgs[i])
    require(pkgs[i], character.only = T)
  }else{
    require(pkgs[i], character.only = T)
  }
}

# Install github packages
#devtools::install_github("Japrin/STARTRAC")
#devtools::install_github("ncborcherding/scRepertoire")

# Load library
library(scRepertoire)

# Create output directories
if(!dir.exists("output/figures/TCRseq")){
  dir.create("output/figures/TCRseq",
             recursive = T)}

############################
# Read in TCR data
############################

S1.TCR.df <- read.csv("Input_data/VDJ_data/Sample1_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S2.TCR.df <- read.csv("Input_data/VDJ_data/Sample2_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S3.TCR.df <- read.csv("Input_data/VDJ_data/Sample3_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S4.TCR.df <- read.csv("Input_data/VDJ_data/Sample4_filtered_contig_annotations.csv", stringsAsFactors = FALSE)

# Remove -1 suffix
S1.TCR.df$barcode <- gsub("-1", "", S1.TCR.df$barcode)
S2.TCR.df$barcode <- gsub("-1", "", S2.TCR.df$barcode)
S3.TCR.df$barcode <- gsub("-1", "", S3.TCR.df$barcode)
S4.TCR.df$barcode <- gsub("-1", "", S4.TCR.df$barcode)

# Combine data
contig.list <- list(S1.TCR.df, S2.TCR.df, S3.TCR.df, S4.TCR.df)


combined.data <- combineTCR(contig.list,
                            samples = c("S1", "S2", "S3", "S4"),
                            ID = c("US", "US", "Stim", "Stim"),
                            cells ="T-AB",
                            filterNA = TRUE, 
                            filterMulti = FALSE)  # error thrown when using filter withMUTLI - need to fix this

# filterNA
# if true will remove cells with a single missing chain, if false will allow those with a single missing chain to remain

View(head(combined.data[[1]]))





################
# Visualisation
################


# Frequency of unique clonotypes per treatment
quantContig(combined.data,
            cloneCall = "aa",
            column = "ID",
            scale = TRUE,
            exportTable = TRUE)

dev.copy(pdf, "output/figures/TCRseq/Freq_unique_clonotypes_aa.pdf")
dev.off()

write.csv(quantContig_output, "output/tables/TCR_quantContig.csv")


# Clonal abundance 
abundanceContig(combined.data,
                cloneCall = "aa",
                scale = F)

dev.copy(pdf, "output/figures/TCRseq/Clone_abundance_aa.pdf")
dev.off()


# Contig length

# AA
lengthContig(combined.data,
             cloneCall = "aa",
             chains = "single", # "combined" or "single"
             column = "ID", 
             scale = FALSE, 
             exportTable = TRUE) 

dev.copy(pdf, "output/figures/TCRseq/Contig_length_aa.pdf")
dev.off()

write.csv(lengthContig_output, "output/tables/TCR_Contig_length_aa.csv")

# NT
lengthContig(combined.data,
             cloneCall = "nt",
             chains = "single", 
             column = "ID", 
             scale = FALSE, 
             exportTable = TRUE) 

dev.copy(pdf, "output/figures/TCRseq/Contig_length_nt.pdf")
dev.off()

write.csv(lengthContig_output, "output/tables/TCR_Contig_length_nt.csv")



# Clonal Homeostasis
clonalHomeostasis(combined.data, 
                  cloneTypes = c(Rare = 1e-04, 
                                 Small = 0.001, 
                                 Medium = 0.01, 
                                 Large = 0.1, 
                                 Hyperexpanded = 1),
                  cloneCall = "aa",
                  exportTable = TRUE)

dev.copy(pdf, "output/figures/TCRseq/clonalHomeostasis_aa.pdf")
dev.off()

write.csv(clonalProportion_output, "output/tables/TCR_clonalHomeostasis_aa.csv")


# clonal proportion

clonalProportion(combined.data,
                 split = c(10, 100, 1000, 10000, 30000, 1e+05), 
                 cloneCall = "aa", 
                 exportTable = TRUE) 

dev.copy(pdf, "output/figures/TCRseq/clonalProportion_aa.pdf")
dev.off()

write.csv(clonalProportion_output, "output/tables/TCR_clonalproportion_aa.csv")

# Clonal overlap between samples
clonalOverlap(combined.data, 
              cloneCall = "aa", 
              method = "overlap", 
              exportTable = TRUE)

dev.copy(pdf, "output/figures/TCRseq/clonaloverlap_aa.pdf")
dev.off()

write.csv(clonalProportion_output, "output/tables/TCR_clonaloverlap_aa.csv")





# compare clonotypes
compareClonotypes(combined.data,
                  numbers = 10, 
                  samples = c("S1_US", "S3_Stim"), 
                  cloneCall = "aa", 
                  graph = "alluvial") # alluvial or area

dev.copy(pdf, "output/figures/TCRseq/clonaloverlap_alluvial_top_10_S1vsS3.pdf")
dev.off()

compareClonotypes(combined.data,
                  numbers = 10, 
                  samples = c("S2_US", "S4_Stim"), 
                  cloneCall = "aa", 
                  graph = "alluvial") 

dev.copy(pdf, "output/figures/TCRseq/clonaloverlap_alluvial_top_10_S2vsS4.pdf")
dev.off()

compareClonotypes(combined.data,
                  numbers = 10, 
                  samples = c("S1_US", "S2_US"), 
                  cloneCall = "aa", 
                  graph = "alluvial") 

dev.copy(pdf, "output/figures/TCRseq/clonaloverlap_alluvial_top_10_S1vsS2.pdf")
dev.off()

compareClonotypes(combined.data,
                  numbers = 10, 
                  samples = c("S3_Stim", "S4_Stim"), 
                  cloneCall = "aa", 
                  graph = "alluvial") 

dev.copy(pdf, "output/figures/TCRseq/clonaloverlap_alluvial_top_10_S3vsS4.pdf")
dev.off()


# dendrogram of Jensen-shannon distance 
clonesizeDistribution(combined.data,
                      cloneCall = "aa",
                      method="ward.D2")

dev.copy(pdf, "output/figures/TCRseq/Dendrogram_Jensen_shannon_distance.pdf")
dev.off()




# Clonal diversity metrics

clonalDiversity(combined.data,
                cloneCall = "aa",
                colorBy = "ID")

dev.copy(pdf, "output/figures/TCRseq/Clonal_diversity_metrics.pdf")
dev.off()

```







## Misc analysis {.tabset}

### Analysis with Augur 
```{r Augur_Analysis, echo = TRUE, eval = FALSE}

if(long.compute){
  
  # Install packages required
  
  #devtools::install_github("const-ae/sparseMatrixStats")
  #devtools::install_github("neurorestore/Augur")
  #install.packages("glmnet")
  
  
  ####################################  
  # Run Augur analysis on clusters
  ####################################  
  
  # Metadata info 
  metadata.df <- seurat.combined@meta.data
  
  # see which cols to keep
  colnames(metadata.df)
  
  # Select just cluster and condition cols 
  metadata.df <- metadata.df %>%
    dplyr::select(seurat_clusters, condition)
  
  # Name cols for input into augur function
  colnames(metadata.df) <- c("cell_type", "label")
  
  # output expression dataset
  normed.df <- seurat.combined@assays$RNA@data
  
  # Run Augur analysis // ~45 min compute time
  augur.out <- Augur::calculate_auc(normed.df,
                                    metadata.df, 
                                    n_threads = 8)
  
  # Output is stored in AUC slot 
  augur.out$AUC
  
  # Save RDS file
  saveRDS(augur.out, "Exported_RDS_files/Augur_output_clusters.rds")
  rm(augur.out)
  
  
  
  ###################################
  # Run Augur analysis on modules
  ###################################
  
  # Metadata info 
  metadata.df <- seurat.combined@meta.data
  
  # see which cols to keep
  colnames(metadata.df)
  
  # Select just cluster and condition cols 
  metadata.df <- metadata.df %>%
    dplyr::select(Module, condition)
  
  # Name cols for input into augur function
  colnames(metadata.df) <- c("cell_type", "label")
  
  
  # output expression dataset
  normed.df <- seurat.combined@assays$RNA@data
  
  # Run Augur analysis // ~10 min compute time
  augur.out <- Augur::calculate_auc(normed.df,
                                    metadata.df, 
                                    n_threads = 8)
  
  # Output is stored in AUC slot 
  augur.out$AUC
  
  # Save RDS file
  saveRDS(augur.out, "Exported_RDS_files/Augur_output_module.rds")
  rm(augur.out)
  
}

```









## SCENIC TF analysis {.tabset}

### SCENIC transcription factor analysis 

```{r SCENIC_analysis}

# SCENIC analysis performed using python script as this is considerably faster then R based analysis

# Analysis performed as outlined in Sande et al., 2020 Nature Protocols manuscript

# Input into SCENIC analysis is a .loom file 

# Export seurat object as Loom file

# Generate loom file for SCENIC analysis 

#devtools::install_github(repo = "hhoeflin/hdf5r", force = TRUE)
#devtools::install_github(repo = "mojaveazure/loomR", ref = "develop")

library(loomR)



Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

DefaultAssay(seurat.combined) <- "RNA"


as.loom(seurat.combined, 
        assay = "RNA",
        filename = "seurat_combined.loom",
        overwrite = FALSE,
        verbose = TRUE)

dim(seurat.combined@assays$RNA)


lfile <- connect(filename = "seurat_combined.loom", mode = "r+")

lfile[["matrix"]]

lfile$close_all()




```













### Monocle
```{r Monocle_trajectory}




R.version


```








## Export large data {.tabset}

### Export seurat object
```{r export_RDS}
if(!quick.load){
  saveRDS(seurat.combined, file = "Exported_RDS_files/seurat_combined.rds")
  saveRDS(seurat.tcr, file = "Exported_RDS_files/seurat_tcr.rds")
}

```

### Save large data tables
```{r write_data, eval = FALSE}

if(long.compute){
  
  save.data.frame.function <- function(df, title){
    
    x <- as.data.frame(as.matrix(df))
    
    write.table(x, 
                paste0("output/tables/", title, ".txt"),
                sep = "\t",
                quote = FALSE)
  }
  
  # Raw data
  save.data.frame.function(seurat.combined@assays$RNA@counts, "Raw_dataframe")
  
  # Normed data
  save.data.frame.function(seurat.combined@assays$RNA@data, "filtered_dataframe")
  
  # Scaled data
  save.data.frame.function(seurat.combined@assays$RNA@scale.data, "scaled_dataframe")
  
  # PCA embeddings
  save.data.frame.function(seurat.combined@reductions$pca@cell.embeddings, "RNA_PCA")
  
  # UMAP embeddings
  save.data.frame.function(seurat.combined@reductions$umap@cell.embeddings, "RNA_UMAP")
  
  # Metadata
  save.data.frame.function(seurat.combined@meta.data, "Meta_data_dataframe")
  
  # Imputed values
  save.data.frame.function(seurat.combined@assays$alra@counts, "Imputed_counts_dataframe")
  
  # Integrated normed values
  save.data.frame.function(seurat.combined@assays$integrated@data, "filtered_integrated_dataframe")
  
  # Integrated scaled data
  save.data.frame.function(seurat.combined@assays$integrated@scale.data, "scaled_integrated_dataframe")
  
}

```







## Analysis optimisation code {.tabset}

### Optimise UMAP variables 
```{r Optimise_UMAP_vis, eval = FALSE}


if(long.compute){
  
  #########
  # UMAP
  #########
  # determine best min distance & neighbour val for UMAP
  
  DefaultAssay(seurat.combined) <- "integrated"
  
  # Set Idents
  Idents(seurat.combined) <- seurat.combined@meta.data$Module
  
  
  
  #############
  if (!dir.exists("output/Optimising_UMAP")) {
    dir.create("output/Optimising_UMAP", recursive = T)
  }
  
  min.dist.val <- 0.001
  
  # UMAP loop
  while (min.dist.val < 1) {
    n.neigh.val <- 5
    while (n.neigh.val <= 50) {
      temp <- RunUMAP(object = seurat.combined,
                      reduction = "pca",
                      dims = 1:20,
                      umap.method = "uwot",
                      n.neighbors = n.neigh.val, # 5 to 50
                      min.dist = min.dist.val, # Sensible values are in the range 0.001 to 0.5
                      seed.use = 42)
      
      # Larger values = global structure
      # small value = local structure
      
      print(UMAPPlot(object = temp,
                     group.by = "Module",
                     label = TRUE, 
                     label.size = 4) + ggtitle(paste0("UMAP Min dist = ", min.dist.val, "n.val = ", n.neigh.val)))
      
      dev.copy(pdf, paste0("output/Optimising_UMAP/UMAP_Min_dist_", min.dist.val, "_neighval_", n.neigh.val, ".pdf"))
      dev.off()
      
      n.neigh.val <- n.neigh.val + 20
      print(paste0(n.neigh.val))
    }
    
    min.dist.val <- min.dist.val * 10
    print(paste0(min.dist.val))
  }
}

# Default of n.neighbor = 30 and min.dist = 0.3 work well

```

### Altering the cluster calling resolution
```{r Differing_clust_resolution, eval = FALSE, echo = FALSE}

if(long.compute){
  
  if (!dir.exists("output/figures/Differing_clust_resolution")) {
    dir.create("output/figures/Differing_clust_resolution", recursive = T)
  }
  
  
  DefaultAssay(seurat.combined) <- "integrated"
  
  
  res.val <- 0.1
  
  while(res.val < 5){
    
    print(paste0("calculating clusters for res.val = ", res.val))
    
    # Find clusters
    seurat.combined <- FindClusters(seurat.combined, 
                                    resolution = res.val)
    
    
    # set ident 
    Idents(seurat.combined) <- seurat.combined@meta.data[, paste0("integrated_snn_res.", res.val)]
    
    
    print(UMAPPlot(object = seurat.combined,
                   label = TRUE, 
                   label.size = 6) + 
            ggtitle(paste0("clusters based on res.val = ", res.val)))
    
    dev.copy(pdf, paste0("output/figures/Differing_clust_resolution/UMAP_clust_res_", res.val, ".pdf"))
    dev.off()
    
    res.val <- res.val*2
    
  }
  
  
  
  # Original res val plot put into same folder 
  res.val <- 0.5
  
  # set ident 
  Idents(seurat.combined) <- seurat.combined@meta.data[, paste0("integrated_snn_res.", res.val)]
  
  
  print(UMAPPlot(object = seurat.combined,
                 label = TRUE, 
                 label.size = 6) + 
          ggtitle(paste0("clusters based on res.val = ", res.val)))
  
  dev.copy(pdf, paste0("output/figures/Differing_clust_resolution/UMAP_clust_res_", res.val, ".pdf"))
  dev.off()
}

```





























### DEG between conditions 
### vis degs between conditions 
### gd tcr break down 
## expression level 
# types and number of tcrs 
##









## TCR analysis {.tabset}




```{r gd_TCR}


gd.nong9d2.clonotype.seuart <- get.unique.clonotypes(seurat.tcr, "seurat_clusters", "gd_T_non_g9d2")
gd.g9d2.clonotype.seuart <- get.unique.clonotypes(seurat.tcr, "seurat_clusters", "gd_T_g9d2")




UMAPPlot(gd.nong9d2.clonotype.seuart, 
         group.by = "seurat_clusters",
         split.by = "condition")



UMAPPlot(gd.g9d2.clonotype.seuart, 
         group.by = "seurat_clusters",
         split.by = "condition")



unique(gd.g9d2.clonotype.seuart@meta.data$clonotype_id_A)
unique(gd.nong9d2.clonotype.seuart@meta.data$clonotype_id_A)


gd.g9d2.clonotype.seuart@meta.data$umis_A

VlnPlot(gd.nong9d2.clonotype.seuart, 
        "umis_A")


VlnPlot(gd.nong9d2.clonotype.seuart, 
        "reads_A")



VlnPlot(seurat.tcr, 
        "reads_A",
        log = T,
        group.by = "seurat_clusters",
        pt.size = 0)

VlnPlot(seurat.tcr, 
        "reads_B",
        log = T,
        group.by = "seurat_clusters",
        pt.size = 0)

VlnPlot(seurat.tcr, 
        "umis_A",
        log = T,
        group.by = "seurat_clusters",
        pt.size = 0)

VlnPlot(seurat.tcr, 
        "umis_B",
        log = T,
        group.by = "seurat_clusters",
        pt.size = 0)





VlnPlot(seurat.tcr, 
        "TRGV9",
        group.by = "seurat_clusters")


VlnPlot(seurat.tcr, 
        "TRDV2",
        group.by = "seurat_clusters")






VlnPlot(seurat.tcr, 
        "TRDC",
        group.by = "seurat_clusters")



VlnPlot(seurat.tcr, 
        "TRGV10",
        group.by = "seurat_clusters")



VlnPlot(seurat.tcr, 
        "TRGV2",
        group.by = "seurat_clusters")



VlnPlot(seurat.tcr, 
        "TRDV1",
        group.by = "seurat_clusters")






VlnPlot(seurat.tcr, 
        "TRDV2",
        group.by = "seurat_clusters")

VlnPlot(seurat.tcr, 
        "TRGV9",
        group.by = "seurat_clusters")


VlnPlot(seurat.tcr, 
        "TRBC1",
        group.by = "seurat_clusters")



sum(table(gd.g9d2.clonotype.seuart@meta.data$clonotype_id_A))


Clust.vect <- levels(seurat.combined@meta.data$seurat_clusters)

table.plot <- data.frame(matrix(nrow = length(Clust.vect), ncol = 2))

colnames(table.plot) <- c("Detected", "Not_detected")


# What freq of X cluster have a detected pair TCR 


for(i in 1:length(Clust.vect)){
  metadata.table <- seurat.combined@meta.data
  logic.vec <- metadata.table$seurat_clusters == paste0(Clust.vect[i])
  
  metadata.filt <- metadata.table[logic.vec, ]
  
  
  not.detected <-sum(is.na(metadata.filt$clonotype_id_A))
  detected <-sum(!is.na(metadata.filt$clonotype_id_A))
  total.cells <- length(metadata.filt$clonotype_id_A)
  
  
  freq.notdetected <- not.detected/total.cells*100 # = freq NA of population 
  freq.detected <- detected/total.cells*100
  
  
  rownames(table.plot)[i] <- paste0(Clust.vect[i])
  table.plot[i, 1] <- freq.detected
  table.plot[i, 2] <- freq.notdetected
  
}




barplot(t(table.plot),
        cex.names = 0.5,
        #col = c("green", "red"),
        las = 2,
        ylim = c(0, 100),
        legend = TRUE)















```




































### Compare imputation
```{r imputed_visualisation}

# Create Directories
if(!dir.exists("output/figures/imputed")){dir.create("output/figures/imputed", recursive = T)}
if(!dir.exists("output/figures/imputed/comparison")){dir.create("output/figures/imputed/comparison", recursive = T)}


# Plot and compare imputed and original values function
plot.imputed <- function(seurat.object, sample.id, goi){
  
  # Ensure seurat object idents are named cluster idents
  Idents(seurat.object) <- seurat.object@meta.data$Module
  
  # Set default to RNA for original values
  DefaultAssay(seurat.object) <- "RNA"
  original.seurat <- seurat.object
  
  # Create and set assay for imputed seurat object
  imputed.seurat <- seurat.object
  DefaultAssay(imputed.seurat) <- "alra"
  
  for(i in 1:length(goi)){
    
    #############
    # VlnPlots
    #############
    
    # Original vs. Imputed
    plot.1 <- VlnPlot(original.seurat, 
                      goi[i],
                      pt.size = 0) +
      ggtitle(paste0("Original  ", goi[i], " ", sample.id)) +
      theme(
        axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
      NoLegend()
    
    plot.2 <- VlnPlot(imputed.seurat, 
                      goi[i],
                      pt.size = 0) +
      ggtitle(paste0("Imputed ", goi[i], " ", sample.id)) +
      theme(
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
      NoLegend()
    
    print(grid.arrange(plot.1, plot.2, ncol=2))
    
    dev.copy(pdf, paste0("output/figures/imputed/comparison/VlnPlot_", goi[i], "_", sample.id, ".pdf"))
    dev.off()
    
    # Imputed only
    print(VlnPlot(imputed.seurat, 
                  goi[i], 
                  split.by = "condition",
                  pt.size = 0) +
            ggtitle(paste0("Imputed ", goi[i], " ", sample.id)) +
            theme(
              axis.title.x = element_blank(),
              axis.text.x = element_text(angle = 90, hjust = 1)))
    
    dev.copy(pdf, paste0("output/figures/imputed/VlnPlot_", goi[i], "_", sample.id, ".pdf"))
    dev.off()
    
    #############
    # RidgePlot
    #############
    
    # Original vs. Imputed
    plot.1 <- RidgePlot(object = original.seurat, 
                        features = goi[i],
                        log = TRUE) +
      ggtitle(paste0("Original ", goi[i], " ", sample.id)) +
      theme(
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
      NoLegend()
    
    plot.2 <- RidgePlot(object = imputed.seurat, 
                        features = goi[i],
                        log = TRUE) +
      ggtitle(paste0("Imputed ", goi[i], " ", sample.id)) +
      theme(
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(angle = 90, hjust = 1)) +
      NoLegend()
    
    print(grid.arrange(plot.1, plot.2, ncol=2))
    
    dev.copy(pdf, paste0("output/figures/imputed/comparison/RidgePlot_", goi[i], "_", sample.id, ".pdf"))
    dev.off()
    
    # Imputed only
    print(RidgePlot(object = imputed.seurat, 
                    features = goi[i],
                    log = TRUE) +
            ggtitle(paste0("Imputed ", goi[i], " ", sample.id)) +
            theme(
              axis.title.y = element_blank(),
              axis.text.x = element_text(angle = 90, hjust = 1)) +
            NoLegend())
    
    dev.copy(pdf, paste0("output/figures/imputed/RidgePlot_", goi[i], "_", sample.id, ".pdf"))
    dev.off()
    
    #############
    # Feature plots
    #############
    
    # Original vs. Imputed
    plot.1 <- FeaturePlot(original.seurat, 
                          features = goi[i], 
                          reduction = "umap", 
                          cols = c("lightgray", "orange", "red"),
                          pt.size = 1,
                          order = TRUE) + 
      #DarkTheme() +
      ggtitle(paste0("Original ", goi[i], " ", sample.id))
    
    plot.2 <- FeaturePlot(imputed.seurat, 
                          features = goi[i], 
                          reduction = "umap", 
                          cols = c("lightgray", "orange", "red"),
                          pt.size = 1,
                          order = TRUE) + 
      #DarkTheme() +
      ggtitle(paste0("Imputed ", goi[i], " ", sample.id))
    
    print(grid.arrange(plot.1, plot.2, ncol=2))
    
    dev.copy(pdf, paste0("output/figures/imputed/comparison/FeaturePlot_", goi[i], "_", sample.id, ".pdf"))
    dev.off()
    
    # Imputed only
    print(FeaturePlot(imputed.seurat, 
                      features = goi[i], 
                      reduction = "umap", 
                      cols = c("lightgray", "orange", "red"),
                      pt.size = 1,
                      order = TRUE) + 
            #DarkTheme() +
            ggtitle(paste0("Imputed ", goi[i], " ", sample.id)))
    
    dev.copy(pdf, paste0("output/figures/imputed/FeaturePlot_", goi[i], "_", sample.id, ".pdf"))
    dev.off()
    
  }
}


# Set up GOI vector
goi <- unique(c("CD226", "GZMA", "EOMES", "TOX",
                "LAG3", "HAVCR2", "PDCD1", "ENTPD1",
                "MKI67", "IFNG", "TNF", "KLRB1", "TCF7",
                "GZMB", "PRF1", "SELL", "CCR7"))

plot.imputed(seurat.combined, 
             sample.id = "Combined",
             goi = goi)



##################################
# Plot Scatter plots of interest
##################################

# Set Idents
Idents(US.seurat.filt) <- US.seurat.filt@meta.data$RNA_named_clusts
Idents(Stim.seurat.filt) <- Stim.seurat.filt@meta.data$RNA_named_clusts

# Set default assay to imputed values
DefaultAssay(US.seurat.filt) <- "alra"
DefaultAssay(Stim.seurat.filt) <- "alra"

# Create output directory
if(!dir.exists("output/figures/imputed_scatter")){dir.create("output/figures/imputed_scatter", recursive = T)}


##################
# Plot scatters
##################

GOI.1 <- c("IFNG", "IFNG", "TOX", "TCF7", "NKG7", "EOMES", "NKG7")
GOI.2 <- c("GZMA", "PDCD1", "PDCD1", "PDCD1", "PDCD1", "CD226", "CTSW")


for(i in 1:length(GOI.1)){
  print(FeatureScatter(US.seurat.filt, feature1 = GOI.1[i], feature2 = GOI.2[i]))
  dev.copy(pdf, paste0("output/figures/imputed_scatter/ScatterPlot_US_", GOI.1[i], "_vs_", GOI.2[i], ".pdf"))
  dev.off()
  
  print(FeatureScatter(Stim.seurat.filt, feature1 = GOI.1[i], feature2 = GOI.2[i]))
  dev.copy(pdf, paste0("output/figures/imputed_scatter/ScatterPlot_Stim_", GOI.1[i], "_vs_", GOI.2[i], ".pdf"))
  dev.off()
}


```








## Investigating clusters // analysis in progress section {.tabset}

#### current code chunk for playing 
### Working code for identifying clusters // IN PROGRESS
```{r Identifying_clusters}


if(!dir.exists("output/figures/Identifying_clusters")){
  dir.create("output/figures/Identifying_clusters", 
             recursive = T)
}



UMAPPlot(object = seurat.combined,
         label = T)



# From above analysis the following clusters have unique signatures 
# 2, 4, 7, 9, 10, 11, 13, 15, 16

# Cluster 8 = Naive?
# Cluster 2 = IFN
# Cluster 1/7/10 = exhausted cells
# Clust 11 = MAIT
# Clust 13 = yd t cells
# Cluster 15 = cycling - MKI67 CDK???


# Cluster 12 - is this TRM
# Clust 5 lots of overlap with 7
# Clust 14 = noise?

# Is cluster 9 also Gamma delta
# is cluster 3 or 4 - stem cell like



# TCR in 15/16 - 
# check papers for cycling cells 
# 14 






# Exhausted signature // 1/7/10
goi <- c("CD226", "LAG3", "TIGIT", 
         "HAVCR2", "TCF7", "TOX",
         "PDCD1", "IFNG", "GZMA",
         "ENTPD1", "ICOS", "NKG7", 
         "GZMB", "PRF1", "CTLA4", "GNLY")

DotPlot(seurat.combined, 
        features = goi, 
        dot.scale = 8) + 
  RotatedAxis() +
  theme(text = element_text(size = 4)) + 
  NoLegend()                

dev.copy(pdf, "output/figures/Identifying_clusters/Exhaustion_markers.pdf")
dev.off()

# Naive signature - Cluster 8
goi <- c("CCR7", "SELL", "IL7R", "LTB", "LEF1", "TCF7")


DotPlot(seurat.combined, 
        features = goi, 
        dot.scale = 8) + 
  RotatedAxis() +
  theme(text = element_text(size = 4)) + 
  NoLegend()         

dev.copy(pdf, "output/figures/Identifying_clusters/Naive_markers.pdf")
dev.off()




# IFN -- Cluster 2
goi <- c("IFIT1", "IFIT3", "IFI6", "OAS1", "ISG15", "IFITM1", "LY6E", 
         "ISG20", "IFIT2", "OAS3", "XAF1",
         "IRF7", "STAT1", "IFI35", "OAS2", "LAMP3", "IFIT5", "NFATC2", "CD164", 
         "CD47", "CXCR3", "CD68", "CASP1", "STAT2")


DotPlot(seurat.combined, 
        features = goi, 
        dot.scale = 8) + 
  RotatedAxis() +
  theme(text = element_text(size = 4)) + 
  NoLegend()        

dev.copy(pdf, "output/figures/Identifying_clusters/IFN_markers.pdf")
dev.off()







# TRM sig # is this cluster 12?
goi <- c("ZNF683", "GZMH", "GZMB", "GNLY", "CCL5", "NKG7", "KLRD1", "HOPX", "KLRC1", "CD244", "HLA-DQA1", "HLA-DQB1", "IL32")


DotPlot(seurat.combined, 
        features = goi, 
        dot.scale = 8) + 
  RotatedAxis() +
  theme(text = element_text(size = 4)) + 
  NoLegend()      

dev.copy(pdf, "output/figures/Identifying_clusters/TRM_markers.pdf")
dev.off()




# Effector - Cluster 5
goi <- c("NKG7", "TNF", "IL2", "IFNG", "GZMA",
         "LAMP1", "PRF1", "GZMB", "TNFRSF9", "GZMK", "CD5", "GZMM", "FAS",
         "CD27", "CD28", "CD226", "CD69", "IL2RA", "PDCD1", "TIGIT", "HAVCR2")


DotPlot(seurat.combined, 
        features = goi, 
        dot.scale = 8) + 
  RotatedAxis() +
  theme(text = element_text(size = 4)) + 
  NoLegend()      

dev.copy(pdf, "output/figures/Identifying_clusters/Effector_markers.pdf")
dev.off()



















# From above analysis the following clusters have unique signatures 
# 2, 4, 7, 9, 10, 11, 13, 15, 16

# Cluster 8 = Naive?
# Cluster 2 = IFN
# Cluster 1/7/10 = exhausted cells
# Clust 11 = MAIT
# Clust 13 = yd t cells
# Cluster 15 = cycling - MKI67 CDK???



# Clust 5 lots of overlap with 7
# Clust 14 = noise?


goi <- c("CXCR6", "ITGA1", "CCL5", "GZMB", "GZMK", "IFNG", "CCL4", "CCL3", "LGALS1")

goi <- c("HOPX")

#cd68, il8, il1b - myeloid cell 


goi <- c("CD8A", "CD3E", "CD68", "IL1B", "LCK")


seurat.combined@active.assay <- "RNA"
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


goi <- c("SLAMF6", "TCF7", "PDCD1", "TOX", "KLRG1", "EOMES", "TBX21", "MYB")



DotPlot(seurat.combined, 
        features = goi, 
        dot.scale = 8) + RotatedAxis()    


DotPlot(seurat.combined, 
        features = c(Cluster_5$gene, "CXCR1", "PRF1"),
        dot.scale = 8) + RotatedAxis()    




# Is cluster 9 also Gamma delta
# is cluster 3 or 4 - stem cell like


# Are any alpha beta TCRs in gamma delta ? clusters??




# Stem-like 
goi <- c("FOSB", "PPP1R15A", "KLF6", "JUNB", "NFKBIA", "TCF7", "RELB", "CCR7", "CRTAM")


DotPlot(seurat.combined, 
        features = goi, 
        dot.scale = 8) + 
  RotatedAxis() +
  theme(text = element_text(size = 4)) + 
  NoLegend()         




#




UMAPPlot(object = seurat.combined,
         label = T)



y






Cluster_10
Cluster_7


DotPlot(seurat.combined, 
        features = Cluster_0$gene, 
        dot.scale = 8) + RotatedAxis()




















MAIT.sig <- c("SLCA4A10", "SCART1", "WNT11", "LTK", "FLT4", "LEF1", "KLRC4", "TBC1D4", "LAIR2", "KLRB1", "ZFP36L2", "DUSP2", "ARL4C", "SNORA70", "LDHB", "ITK", "FYB", "MIAT", "TMEM173")

DotPlot(seurat.combined, 
        features = MAIT.sig, 
        dot.scale = 8) + RotatedAxis()

#dev.copy(pdf, "output/figures/Identifying_clusters/MAIT_markers.pdf")
#dev.off()







```

### GammaDelta T cells // IN PROGRESS
```{r GammaDelta_cells}

###########################
# Gamma delta T cells
###########################

# Looking at top Markers for each cluster - it looks like cluster 13 = Gamma/Delta T cells

# Cross reference with Pizzolatto gamma delta signature - numerous genes are found in top DEGs of cluster 13

# Using Pizzolatto signature I picked the genes that showed unique expression patterns in this dataset, below is the resulting gd signature


# Pizzolatto et al., Gamma delta signature - Gamma/Delta relative to Alpha/beta T cells
#Pizzolatto.GD.sig <- as.data.frame(read_excel("Input_data/Downloaded_Gene_signatures/Pizzolatto_GammaDelta.xlsx"))

# GammaDelta Signature
#Pizzolatto.GD.sig <- Pizzolatto.GD.sig$Genes


gd.sig.1 <- c("TRDC", "TRGC1", "TRGC2",
              "TRDV1", "TRDV2", "TRGV2",
              "TRGV3", "TRGV4", "TRGV7", 
              "TRGV8", "TRGV9", "TRGV10") 

gd.sig.2 <- c("CCR7", "SELL", "ITGAL", 
              "CD27", "GZMM", "FGFBP2")

gd.sig.3 <- c("CD300A", "FCGR3A", "ADGRG1", 
              "C1orf21", "EFHD2", "GZMH",
              "GZMA", "KLRG1", "KLRC1", 
              "KLRB1", "MATK", "PLEK",
              "XCL2", "TYROBP")

gd.sig <- unique(c(gd.sig.1, gd.sig.2, gd.sig.3))


DotPlot(seurat.combined, 
        features = gd.sig, 
        dot.scale = 8) + 
  RotatedAxis() +
  theme(text = element_text(size = 4)) + 
  NoLegend()   

dev.copy(pdf, "output/figures/Identifying_clusters/gammadelta_markers.pdf")
dev.off()


seurat.combined <- AddModuleScore(object = seurat.combined,
                                  features = list(unique(gd.sig)),
                                  name = "GammaDelta")


VlnPlot(seurat.combined, 
        "GammaDelta1", 
        pt.size = 0)

dev.copy(pdf, "output/figures/Identifying_clusters/gammadelta_module_score.pdf")
dev.off()


```

### MAIT cells // IN PROGRESS
```{r MAIT_cells}





UMAPPlot(object = seurat.combined,
         label = T)





# From above analysis the following clusters have unique signatures 
# 2, 4, 7, 9, 10, 11, 13, 15, 16

# Clust 11 = MAIT?
# Clust 13 = yd t cells
# Cluster 15 = cycling - MKI67 CDK???

# Clust 5 lots of overlap with 7
# Clust 14 = noise?



goi <- c("CD226", "LAG3", "TIGIT", 
         "HAVCR2", "TCF7", "TOX",
         "PDCD1", "IFNG", "GZMA",
         "ENTPD1", "EOMES", "TBX21", "PRDM1", "ICOS", "NKG7", "GZMB", "PRF1", "GZMM", "RORA")



Cluster_10
Cluster_7


DotPlot(seurat.combined, 
        features = Cluster_11$gene, 
        dot.scale = 8) + RotatedAxis()



MAIT.sig <- c("SLCA4A10", "SCART1", "WNT11", "LTK", "FLT4", "LEF1", "KLRC4", "TBC1D4", "LAIR2", "KLRB1", "ZFP36L2", "DUSP2", "ARL4C", "SNORA70", "LDHB", "ITK", "FYB", "MIAT", "TMEM173")

DotPlot(seurat.combined, 
        features = MAIT.sig, 
        dot.scale = 8) + RotatedAxis()










########################################################

















DotPlot(seurat.combined, 
        features = Cluster_7$gene, 
        split.by = "condition",
        dot.scale = 8) + RotatedAxis()


#





Cluster_0$gene


dim(x)

goi <- x$gene

goi <- c("CD3D", "SELL", "EOMES", "CD8A",
         "CD4", "GNLY", "CCR7", "NKG7",
         "IFNG", "GZMA", "TBX21", "KLRB1",
         "TRAV1-2", "CD226", "LAG3", "TIGIT", 
         "HAVCR2", "CD96", "TCF7", "TOX", "MKI67")





# Plot of clusters called for reference
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         group.by = "seurat_clusters")







DotPlot(seurat.combined, 
        features = Cluster_15$gene, 
        dot.scale = 8) + RotatedAxis()

























# GAMMA DELTA T CELLS



Cluster_13































############
#
##################################
# Signatures



#install.packages("readxl")
#library("readxl")





# Tissue-resident cell signature (Mackay = mouse & Kumar = human)
Mackay.TRM.sig <- as.data.frame(read_excel("Input_data/Downloaded_Gene_signatures/Mackay_2016_mouse CD8 TRM signature.xlsx"))
Kumar.TRM.sig <- as.data.frame(read_excel("Input_data/Downloaded_Gene_signatures/Kumar_2017_TRM signature.xlsx"))


# Mackay TRM Signature
UP.logic <- Mackay.TRM.sig$Direction == "UP"
DN.logic <- Mackay.TRM.sig$Direction == "DN"

UP.Mackay.TRM.sig <- Mackay.TRM.sig[UP.logic, "gene"]
DN.Mackay.TRM.sig <- Mackay.TRM.sig[DN.logic, "gene"]

UP.Mackay.TRM.sig <- toupper(UP.Mackay.TRM.sig)
DN.Mackay.TRM.sig <- toupper(DN.Mackay.TRM.sig)

# Kumar TRM Signature
UP.logic <- Kumar.TRM.sig$Direction == "UP"
DN.logic <- Kumar.TRM.sig$Direction == "DN"

UP.Kumar.TRM.sig <- Kumar.TRM.sig[UP.logic, "gene"]
DN.Kumar.TRM.sig <- Kumar.TRM.sig[DN.logic, "gene"]






DotPlot(seurat.combined, 
        features = DN.Kumar.TRM.sig, 
        dot.scale = 8) + RotatedAxis()








#











































DotPlot(seurat.combined, 
        features = Pizzolatto.GammaDelta.sig, 
        cols = c("blue", "red"), 
        dot.scale = 8, 
        split.by = "condition") + RotatedAxis()





VlnPlot(seurat.combined, 
        features = c("KLRB1", "CCR6", "TRAV1-2", "TRBV6-4", "IL7R", "TRBV6-1", "TRBV20-1"),
        group.by = "seurat_clusters", 
        pt.size = 0,
        ncol = 2,
        combine = T)

?VlnPlot

Cluster_11


plots <- VlnPlot(seurat.combined, 
                 features = c("CD8A", "TOX", "LAG3"),
                 split.by = "condition", 
                 split.plot = FALSE,
                 group.by = "seurat_clusters", 
                 pt.size = 0,
                 combine = FALSE)

wrap_plots(plots = plots, ncol = 1)









brewer.pal(17, "Dark2")
RColorBrewer::display.brewer.all()




conserve.markers <- FindConservedMarkers(seurat.combined, ident.1 = 0, grouping.var = "condition", verbose = TRUE)

?FindConservedMarkers

head(conserve.markers)



goi <- c("CD3D", "SELL", "EOMES", "CD8A",
         "CD4", "GNLY", "CCR7", "NKG7",
         "IFNG", "GZMA", "TBX21", "KLRB1",
         "TRAV1-2", "CD226", "LAG3", "TIGIT", 
         "HAVCR2", "CD96", "TCF7", "TOX")

FeaturePlot(seurat.combined, features = goi, min.cutoff = "q9")

FeaturePlot(seurat.combined, features = c("KLRG1", "TRAV1-2"), min.cutoff = "q9")




RNA.markers <- FindAllMarkers(seurat.combined,
                              assay = "RNA",
                              only.pos = TRUE,
                              min.diff.pct = 0.1,
                              return.thresh = 0.05)










# Stimulated
seurat.combined.small <- subset(seurat.combined, downsample = 300)


##################
# Plot Heatmaps
##################

###############
# Unstimulated
###############

length(unique(RNA.markers$gene))
sum(RNA.markers$p_val_adj < 0.00001) # 1408 genes 

# get sig genes
sig.genes <- RNA.markers[RNA.markers$p_val_adj < 0.05, ] 

# Order genes by abs(avg_logFC)
ordered.index <- order(abs(sig.genes$avg_logFC), decreasing = TRUE) 
ordered.genes <- sig.genes[ordered.index, ]

# Get top 500 genes
top.genes <- ordered.genes[1:500, ]

# Group genes by cluster
ordered.index <- order(top.genes$cluster, decreasing = FALSE)
top.genes <- top.genes$gene[ordered.index]

# Plot heatmap
DoHeatmap(seurat.combined.small, 
          features = unique(top.genes), 
          assay = "integrated", 
          angle = 90) + NoLegend()















VlnPlot(immune.combined, features = c("CD8A", "TOX", "IFNG"), split.by = "comdition", 
        pt.size = 0, combine = FALSE)









```


## Differential gene expression analysis {.tabset}

### DEGs by condition
```{r Identify_DEGs_accross_condtion}

library(ggplot2)
library(cowplot)
theme_set(theme_cowplot())


# Output directories
if(!dir.exists("output/tables/DEG_across_condition")){
  dir.create("output/tables/DEG_across_condition")
}

if(!dir.exists("output/figures/DEG_across_condition")){
  dir.create("output/figures/DEG_across_condition")
}


clust.var <- seurat.combined@meta.data$seurat_clusters
clust.var <- levels(clust.var)

for(i in 1:length(clust.var)){
  
  # Set idents to the condition_cluster
  Idents(seurat.combined) <- seurat.combined@meta.data$condition_clust
  
  # Calculating DEGs for each cluster across condition
  DEG.var <- FindMarkers(seurat.combined,
                         ident.1 = paste0("Stim_", clust.var[i]), 
                         ident.2 = paste0("US_", clust.var[i]),
                         test.use = "wilcox",
                         logfc.threshold = 0.25,
                         min.pct = 0.1,
                         only.pos = FALSE,
                         verbose = FALSE)
  
  # create column for gene ID
  DEG.var$gene <- rownames(DEG.var)
  
  
  write.csv(DEG.var, paste0("output/tables/DEG_across_condition/Stim_vs_US_DEG_clust_", clust.var[i], ".csv"))
  
  
  print(paste0("Analysis for cluster ", clust.var[i]))
  
  head(DEG.var, n = 15)
  
  
  
  ############################################
  # plotting DEG per cluster across condition
  ############################################
  
  # Set idents to cluster ID
  Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
  
  # Subset for cluster ID
  subset.seurat <- subset(seurat.combined, idents = paste0(clust.var[i]))
  
  # Set idents to condition var
  Idents(subset.seurat) <- subset.seurat@meta.data$condition
  
  
  # Get top 10 genes
  # up-regulated genes
  genes.to.label.1 <- top_n(DEG.var, 10, avg_logFC)$gene
  
  # Down-regulated genes
  genes.to.label.2 <- top_n(DEG.var, -10, avg_logFC)$gene
  
  # Create vector of genes
  genes.to.label <- unique(c(genes.to.label.1, genes.to.label.2))
  
  # Average expression
  avg.subset.seurat <- log1p(AverageExpression(subset.seurat, verbose = FALSE)$RNA)
  
  # Create column with gene id 
  avg.subset.seurat$gene <- rownames(avg.subset.seurat)
  
  # Generate plot
  p1 <- ggplot(avg.subset.seurat, aes(US, Stim)) + 
    geom_point() + 
    ggtitle(paste0("Cluster ", clust.var[i]))
  
  
  
  p1 <-  LabelPoints(plot = p1,
                     points = genes.to.label,
                     repel = TRUE)
  
  print(plot(p1))
  dev.copy(pdf, paste0("output/figures/DEG_across_condition/ScatterPlot_Stim_vs_US_cluster_", clust.var[i], ".pdf"))
  dev.off()
  
  # Remove large variable
  rm(subset.seurat)
  
}



# Add heatmap vis and featureplot vis 

#DoHeatmap(subset.seurat, features = genes.to.label)


#FeaturePlot(subset.seurat, features = c("CCL4", "GZMB", "TNF"), split.by = "condition", max.cutoff = 3, 
#    cols = c("grey", "red"))




#FeaturePlot(seurat.combined, features = c("CCL4", "GZMB", "TNF"), split.by = "condition", max.cutoff = 3, 
#    cols = c("grey", "red"))



#



```

























### NOt cleaned below code






## Trajectory analysis {.tabset}


### Destiny pseudotime analysis
```{r destiny_pseudotime}

#BiocManager::install("destiny")


```




## Need to amend root node settings etc 

### Preparing data for trajectory analysis
```{r Trajectory_data_prep, eval = TRUE}

library(dyno)
library(dynplot)
library(dynmethods)
library(dynutils)
library(dynwrap)
library(tidyverse)
dynwrap::test_docker_installation(detailed = TRUE)

############################
# Read in and prepare data
############################

# Read in dataframes
raw.data <- as.data.frame(seurat.combined@assays$RNA@counts)
normed.data <- as.data.frame(seurat.combined@assays$RNA@data)


# data is organized cols = cells and rows = genes
head(raw.data[1:10, 1:10])
head(normed.data[1:10, 1:10])

# Need to inverse data for input into dyno package
raw.data <- t(raw.data)
head(raw.data[1:10, 1:10])

normed.data <- t(normed.data)
head(normed.data[1:10, 1:10])

# Check data structure
dim(raw.data) # 11,658 cells and 16,295 genes
dim(normed.data) # 11,658 cells and 16,295 genes


if(long.compute){  
  ##########################################
  # Creating Dyno formatted data structure
  ##########################################
  
  Dyno.data <- wrap_expression(counts = raw.data,
                               expression = normed.data)
  
  # Add grouping info
  metadata.df <- seurat.combined@meta.data
  
  group.vect <- metadata.df$seurat_clusters
  names(group.vect) <- rownames(metadata.df)
  
  Dyno.data <- add_grouping(Dyno.data,
                            grouping = group.vect)
  
  
  # Add dim reduction
  logic.vect <- grepl("*UMAP", colnames(metadata.df))
  
  UMAP.dims <- metadata.df[ , logic.vect]
  UMAP.dims <- as.matrix(UMAP.dims)
  
  Dyno.data <- add_dimred(Dyno.data,
                          dimred = UMAP.dims)
  
  
  
}else{
  
  
  
  # Create vectors and matrix needed for visualisation of pre-calculated trajectories
  
  # Create grouping vector
  metadata.df <- seurat.combined@meta.data
  
  group.vect <- metadata.df$seurat_clusters
  names(group.vect) <- rownames(metadata.df)
  
  # Create dim reduction matrix
  logic.vect <- grepl("*UMAP", colnames(metadata.df))
  
  UMAP.dims <- metadata.df[ , logic.vect]
  UMAP.dims <- as.matrix(UMAP.dims)
  
  
}




```

### Running trajectory analysis
```{r trajectory_analysis, eval = FALSE}

if(long.compute){
  
  
  
  ################################################
  # selecting best trajectory method for dataset
  ################################################
  # Using shiny app to get guidelines
  # guidelines <- guidelines_shiny(Dyno.total.data)
  
  
  answers <- dynguidelines::answer_questions(multiple_disconnected = NULL, 
                                             expect_topology = NULL, 
                                             expected_topology = NULL, 
                                             n_cells = 11658, 
                                             n_features = 16295, 
                                             memory = "16GB", 
                                             prior_information = NULL, 
                                             docker = TRUE)
  
  guidelines.vals <- dynguidelines::guidelines(answers = answers) 
  
  methods.selected <- guidelines.vals$methods_selected
  
  print(methods.selected)
  
  
  #####################
  # Infer Trajectory
  #####################
  
  ##############
  # Slingshot
  ##############
  
  slingshot <- infer_trajectory(Dyno.data, 
                                method = "dynverse/ti_slingshot:v0.9.9.01", 
                                parameters = NULL, 
                                give_priors = NULL, 
                                seed = set.seed(42),
                                verbose = TRUE)
  
  saveRDS(slingshot, file = "Exported_RDS_files/combined_slingshot.rds")
  rm(slingshot)
  
  
  ##############
  # Scorpius
  ##############
  
  scorpius <- infer_trajectory(Dyno.data, 
                               method = ti_scorpius(), 
                               parameters = NULL, 
                               give_priors = NULL, 
                               seed = set.seed(42),
                               verbose = TRUE)
  
  saveRDS(scorpius, file = "Exported_RDS_files/combined_scorpius.rds")
  rm(scorpius)
  
  
  ##############
  # Angle
  ##############
  
  angle <- infer_trajectory(Dyno.data, 
                            method = ti_angle(), 
                            parameters = NULL, 
                            give_priors = NULL, 
                            seed = set.seed(42),
                            verbose = TRUE)
  
  saveRDS(angle, file = "Exported_RDS_files/combined_angle.rds")
  rm(angle)
  
}


```

### Visualisation trajectory analysis
```{r Visualisation_trajectory, eval = TRUE}

####################################
# Visualise exported trajectories 
####################################


# Create output directory
if(!dir.exists("output/figures/Trajectories")){
  dir.create("output/figures/Trajectories",
             recursive = T)}



###############
# Slingshot
###############

# Create output directory
if(!dir.exists("output/figures/Trajectories/Slingshot")){
  dir.create("output/figures/Trajectories/Slingshot",
             recursive = T)}


# Read data
slingshot <- readRDS("Exported_RDS_files/combined_slingshot.rds")

# Modify variables

# Set root milestone
#slingshot <- add_root(trajectory = slingshot, 
#                        root_milestone_id = "4")

dynplot::plot_dimred(slingshot, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     label_milestones = TRUE,
                     color_cells = "pseudotime")

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_plot_pseudotime.pdf")
dev.off()


dynplot::plot_dimred(slingshot, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     grouping = group.vect,
                     label_milestones = TRUE,
                     color_cells = "grouping")

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_plot_clusters.pdf")
dev.off()


# Rename milestone labels
#milestone.labels <- c("Naive_memory", "Exhausted", "Activated", "Stem-like")
#names(milestone.labels) <- c(1, 2, 3, 4)

#slingshot <- label_milestones(slingshot, 
#                                 labelling = milestone.labels)

dynplot::plot_dimred(slingshot, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     grouping = group.vect,
                     label_milestones = TRUE,
                     color_cells = "grouping")


# Cacluate trajectory feature importance

overall_feature_importances <- dynfeature::calculate_overall_feature_importance(slingshot, 
                                                                                expression_source = normed.data)

top.features <- overall_feature_importances %>% 
  top_n(50, importance) %>% 
  pull(feature_id)


plot_heatmap(slingshot, 
             expression_source = normed.data, 
             features_oi = top.features)

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_heatmap_top50_important_features.pdf")
dev.off()


# Calculate milestone importance
for(i in 1:length(slingshot$milestone_ids)){
  
  # Because milestone ids are not in order get the corresponding ID name for each milestone #
  logic.var <- names(slingshot$milestone_labelling) == i
  milestone.name <- paste0(slingshot$milestone_labelling[logic.var])
  
  
  milestone.feature.importance <- calculate_milestone_feature_importance(slingshot,
                                                                         expression_source = normed.data, 
                                                                         milestones_oi = i, 
                                                                         verbose = TRUE)
  
  
  top.features <- milestone.feature.importance %>% 
    top_n(25, importance) %>% 
    pull(feature_id)
  
  print(plot_heatmap(slingshot, 
                     expression_source = normed.data, 
                     features_oi = top.features))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Slingshot/Combined_heatmap_top25_milestone_", milestone.name, "_important_features.pdf"))
  dev.off()
  
  
}



################################################
# Base plots of other trajectories calculated
################################################


# Generate list of exported trajectories 
trajectories_master <- list.files("Exported_RDS_files/", ".rds")

print(trajectories_master)

for(i in 1:length(trajectories_master)){
  
  print(paste0("Plotting ", trajectories_master[i]))
  
  trajectory.val <- readRDS(paste0("Exported_RDS_files/", trajectories_master[i]))
  trajectory.name <- gsub(".rds", "", trajectories_master[i])
  
  
  #####################
  # Plot trajectory
  #####################
  
  # Vis pseudotime
  print(dynplot::plot_dimred(trajectory.val, 
                             dimred = UMAP.dims,
                             hex_cells = TRUE, 
                             label_milestones = TRUE,
                             color_cells = "pseudotime"))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Pseudotime_", trajectory.name, ".pdf"))
  dev.off()
  
  # Overlay clusters
  print(dynplot::plot_dimred(trajectory.val, 
                             dimred = UMAP.dims,
                             hex_cells = TRUE, 
                             grouping = group.vect,
                             label_milestones = TRUE,
                             color_cells = "grouping"))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Clusters_", trajectory.name, ".pdf"))
  dev.off()
  
  # Group clusters
  print(dynplot::plot_dimred(trajectory.val, 
                             color_cells = "grouping",
                             color_density = "grouping",
                             dimred = UMAP.dims,
                             hex_cells = TRUE,
                             grouping = group.vect))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Clusters_grouped_", trajectory.name, ".pdf"))
  dev.off()
  
}


rm(trajectory.val)




```



## Script info {.tabset}

### Run time
```{r code_runtime, eval = TRUE}

# calculate compute time for compiling code so far
compute.time <- Sys.time()
print(compute.time-start.time)


```

```{r remedy001}






```

