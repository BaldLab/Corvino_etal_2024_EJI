---
title: "HNSCC_scRNAseq_analysis"
author: "Dillon Corvino"
date: "03/02/2020"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: united
    highlight: tango
    df_print: paged
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

Built with R version `r getRversion()`

## Setup {.tabset}

### Dataset information
```{r Dataset_Info}

# HNSCC scRNAseq/scTCRseq dataset
# Cells are HNSCC TILs sorted on Lymphocytes/Live/CD3+/CD4-/CD8+
# Human samples
# Each sample is a pool of 4 patients
# samples 1 and 2 are unstimulated 
# samples 3 and 4 are stimulated 
# Patients in sample 1 match patients in sample 3 and sample 2 pairs with 4
# Data acquired was transcript expression, ADT (antibody expression), and TCRA & B sequences
# This analysis uses just Transcript and TCR data


# General information
# CellRanger was used for sequence alignment/QC/counts/TCR calls - performed by Ross (QIMR, Brisbane, Aus)
# DC was provided the output from CellRanger (counts matrix) and used this as input for analysis within this script

```

### Environment
**Note: Wheneve possible using seq_along() or seq_len() instead of 1:length for your loops - they are more robust to error** 
```{r Environment_setup, message = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,  
  eval = TRUE, 
  tidy = TRUE
)

# Environment Set up
rm(list = ls()) #Clean workspace
cat("\014")     #Clean Console
gc() # Free memory

# pipeline variables
start.time <- Sys.time()
quick.load <- TRUE
long.compute <- FALSE

###################
# Install packages
###################

# CITEseq requires latest version of Seurat i.e at least V3
# To install the development version of seurat
# devtools::install_github(repo = 'satijalab/seurat', ref = 'develop')

pkgs <- c("remedy", "Seurat", "dplyr", "rstudioapi",
          "cowplot", "ggplot2", "grid", "gridExtra",
          "styler", "stringr", "inlmisc", "RColorBrewer",
          "readxl", "devtools", "tidyverse", "hdf5r", "scales", "useful")

for(i in 1:length(pkgs)){
  if(!require(pkgs[i], character.only = T)){
    install.packages(pkgs[i])
    require(pkgs[i], character.only = T)
  }else{
    require(pkgs[i], character.only = T)
  }
}

pkgs <- c("gplots", "fgsea", "biomaRt", "clusterProfiler", 
          "GSEABase", "org.Hs.eg.db", "pcaMethods",
          "SingleCellExperiment", "batchelor", "DelayedArray", "DelayedMatrixStats",
          "limma", "SummarizedExperiment")

for(i in 1:length(pkgs)){
  if(!require(pkgs[i], character.only = T)){
    BiocManager::install(pkgs[i])
    require(pkgs[i], character.only = T)
  }else{
    require(pkgs[i], character.only = T)
  }
}


#####################
# Github packages
#####################

# Installed packages 

# library("devtools")

# usethis::browse_github_pat()
# usethis::edit_r_environ()
# GITHUB_PAT = "d8207153aef7b295cdf66eb1e1b2a2ed38b0ca18"
# R_MAX_VSIZE = 30Gb

# celltalker
#devtools::install_github("arc85/celltalker")

# Scillus 
#devtools::install_github("xmc811/Scillus", ref = "development")


#devtools::install_github("velocyto-team/velocyto.R")

#devtools::install_github("dynverse/dyno")

#devtools::install_github('cole-trapnell-lab/leidenbase')
#devtools::install_github('cole-trapnell-lab/monocle3')

#devtools::install_github("immunomind/immunarch")
#devtools::install_github("Coolgenome/iTALK", build_vignettes = TRUE)


#devtools::install_github('satijalab/seurat-data')
#devtools::install_github('satijalab/seurat-wrappers')
#library("SeuratWrappers")


#devtools::install_github("ncborcherding/scRepertoire")
#library(scRepertoire)

#.rs.restartR()

#########################
# Failed installations
#########################

# Failed
#remotes::install_git("https://gitlab.unil.ch/carmona/ProjecTILs.git", ref = "v0.4.1")

# TILPRED install works, but only currently for mouse datasets
#remotes::install_github("carmonalab/TILPRED")

# If a package is not installing properly, can use this trick to get the package functions available. just download the package repo from github and then use: 
#devtools::load_all("~/Documents/Work/Sciebo/Scripts/Packages/scRepertoire/")

####################
# Colour scheme
####################

Condition.cols <- c("turquoise", "red")

clust.cols <- c("#E41A1C", # Naive_like_1_CM
                "#A6761D", # Naive_like_2_SC
                "#8DA0CB", # Naive_like_3
                "#666666", # Cytotoxic
                "#A6D854", # Type_I_IFN
                "#984EA3", # Stimulated_1
                "#1B9E77", # Stimulated_exhausted
                "#D95F02", # Exhausted_1
                "#7570B3", # Exhausted_2
                "#E7298A", # TRM
                "#E6AB02", # gd_T_g9d2
                "#8DD3C7", # gd_T_non_g9d2
                "#FF7F00", # MAIT 
                "#E78AC3") # Proliferative

module.cols <- c("#E41A1C", # Naive_Stem
                 "#1B9E77", # Activated
                 "#7570B3", # Exhaustion
                 "#FF7F00", # Innate
                 "#E78AC3") # Cycling

# Set working directory to source file location
setwd(dirname(getActiveDocumentContext()$path))
working.dir <- getwd()

# since moving script from local to github - I want to adjust work dir to be main github dir - therefore 
setwd("..")

# create output directories
if(!dir.exists("Exported_RDS_files")){dir.create("Exported_RDS_files", recursive = T)}
if(!dir.exists("output")){dir.create("output", recursive = T)}
if(!dir.exists("output/figures")){dir.create("output/figures", recursive = T)}
if(!dir.exists("output/tables")){dir.create("output/tables", recursive = T)}
if(!dir.exists("output/QC")){dir.create("output/QC", recursive = T)}


# load saved seurat object with cluster annotations and imputation performed
if(quick.load){
  seurat.combined <- readRDS("Exported_RDS_files/seurat_combined.rds")
}

```

### Reading data
```{r reading_data}

# Load dataset from output generated by Ross, file is annotated as filtered_feature_bc_matrix

Sample1.data <- Read10X(data.dir = "Data/10X_GEX_data/Sample1_US/")
Sample2.data <- Read10X(data.dir = "Data/10X_GEX_data/Sample2_US/")
Sample3.data <- Read10X(data.dir = "Data/10X_GEX_data/Sample3_Stim/")
Sample4.data <- Read10X(data.dir = "Data/10X_GEX_data/Sample4_Stim/")


Sample1.seurat <- CreateSeuratObject(counts = Sample1.data,
                                     min.cells = 3,
                                     min.features = 200)

Sample2.seurat <- CreateSeuratObject(counts = Sample2.data,
                                     min.cells = 3,
                                     min.features = 200)

Sample3.seurat <- CreateSeuratObject(counts = Sample3.data,
                                     min.cells = 3,
                                     min.features = 200)

Sample4.seurat <- CreateSeuratObject(counts = Sample4.data,
                                     min.cells = 3,
                                     min.features = 200)

# Add metadata 
Sample1.seurat@meta.data$group <- "S1"
Sample2.seurat@meta.data$group <- "S2"
Sample3.seurat@meta.data$group <- "S3"
Sample4.seurat@meta.data$group <- "S4"

```

### Merge Seurat objects
```{r merge_seurat}


######################
# Merge samples
######################

# Unstimulated samples 1 & 2
US.seurat <- merge(x = Sample1.seurat, 
                   y = Sample2.seurat,
                   add.cell.ids = c("S1", "S2"), 
                   merge.data = FALSE, # Should normed data be merged as well or just raw data slot
                   project = "Unstimulated")

x <- ncol(Sample1.seurat) + ncol(Sample2.seurat)
paste0("expected number of cells after merge is ", ncol(US.seurat) == x)

Sample1.seurat # 14,695 genes and 3,042 cells
Sample2.seurat # 14,706 genes and 3,536 cells
US.seurat # 15,428 genes and 6,578 cells

head(US.seurat@meta.data)


# Stimulated samples 3 & 4
Stim.seurat <- merge(x = Sample3.seurat, 
                     y = Sample4.seurat,
                     add.cell.ids = c("S3", "S4"), 
                     merge.data = FALSE, # Should normed data be merged as well or just raw data slot
                     project = "Stimulated")

x <- ncol(Sample3.seurat) + ncol(Sample4.seurat)
paste0("expected number of cells after merge is ", ncol(Stim.seurat) == x)

Sample3.seurat # 14,740 genes and 3,885 cells
Sample4.seurat # 14,926 genes and 3,279 cells
Stim.seurat # 15,619 genes and 7,164 cells

head(Stim.seurat@meta.data)

# Add a condition metadata column
US.seurat@meta.data$condition <- "US"
Stim.seurat@meta.data$condition <- "Stim"


```

### Remove large variables that are no longer needed
```{r Remove_unneeded_variables}

rm(Sample1.data, 
   Sample2.data, 
   Sample3.data, 
   Sample4.data,
   Sample1.seurat, 
   Sample2.seurat,
   Sample3.seurat,
   Sample4.seurat)


```

## QC and Normalisation {.tabset}

### QC & Normalisation

```{r QC_and_normalisation}

################################################
#  Get percentage Mitochondria gene expression
################################################

# Unstimulated
US.seurat[["percent.mito"]] <- PercentageFeatureSet(US.seurat, pattern = "^MT-")

# Stimulated
Stim.seurat[["percent.mito"]] <- PercentageFeatureSet(Stim.seurat, pattern = "^MT-")

##################################
# Plot mitochondria percentage
##################################

# nFeature & nCount & Mito (US)
VlnPlot(object = US.seurat, 
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), 
        pt.size = 0)

dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_US.pdf")
dev.off()

# Mito (US)
VlnPlot(US.seurat, 
        features = "percent.mito", 
        y.max = 20)

dev.copy(pdf, "output/QC/QC_RNA_percentMito_US.pdf")
dev.off()

# nFeature & nCount & Mito (Stim)
VlnPlot(object = Stim.seurat, 
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), 
        pt.size = 0)

dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Stim.pdf")
dev.off()

# Mito (Stim)
VlnPlot(Stim.seurat, 
        features = "percent.mito",
        y.max = 20)

dev.copy(pdf, "output/QC/QC_RNA_percentMito_Stim.pdf")
dev.off()



########################################
# Count vs Mito & Count vs Feature
########################################

# Unstimulated
plot1 <- FeatureScatter(US.seurat, feature1 = "nCount_RNA", feature2 = "percent.mito")
plot2 <- FeatureScatter(US.seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(plot1, plot2))
dev.copy(pdf, "output/QC/QC_RNA_percentMito_nCount_nFeature_corr_US.pdf")
dev.off()

# Stimulated
plot1 <- FeatureScatter(Stim.seurat, feature1 = "nCount_RNA", feature2 = "percent.mito")
plot2 <- FeatureScatter(Stim.seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(plot1, plot2))
dev.copy(pdf, "output/QC/QC_RNA_percentMito_nCount_nFeature_corr_Stim.pdf")
dev.off()


############################
# Structure and metadata 
############################

# Unstimulated
head(US.seurat@meta.data)
str(US.seurat@meta.data)

# Stimulated
head(Stim.seurat@meta.data)
str(Stim.seurat@meta.data)

###################
#  Filter cells
###################

# Seurat recommends removing cells with <200 or >2,500 genes or >10% mito genes

# Unstimulated
US.seurat.filt <- subset(US.seurat,
                         subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mito < 10)


# Post-filtering metrics

US.seurat # 15,429 genes across 6,584 cells
US.seurat.filt # 15,429 genes across 5,785 cells

# Therefore
6584 - 5785
# 799 cells were deleted

# Stimulated
Stim.seurat.filt <- subset(Stim.seurat,
                           subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mito < 10)

# Post-filtering metrics

Stim.seurat # 15,618 genes across 7,167 cells
Stim.seurat.filt # 15,618 genes across 6,042 cells

# Therefore
7167 - 6042
# 1125 cells were deleted


##########################################
# Visualise QC metrics after filtering
##########################################

# Unstimulated

# Before Filtering
VlnPlot(object = US.seurat, 
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))

# After filtering
VlnPlot(object = US.seurat.filt, 
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))

dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Post_filtering_US.pdf")
dev.off()

# Stimulated

# Before Filtering
VlnPlot(object = Stim.seurat, 
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))

# After filtering
VlnPlot(object = Stim.seurat.filt, 
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"))

dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Post_filtering_Stim.pdf")
dev.off()



################################################
# Normalise, scale & find variable genes 
################################################

#################
# Unstimulated
#################

# Normalise
US.seurat.filt <- NormalizeData(object = US.seurat.filt,
  assay = "RNA",
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  verbose = TRUE)

# Find variable genes
US.seurat.filt <- FindVariableFeatures(object = US.seurat.filt,
  verbose = TRUE)

# Scale data
US.seurat.filt <- ScaleData(object = US.seurat.filt,
  assay = "RNA",
  vars.to.regress = c("nCount_RNA", "percent.mito"),
  model.use = "linear",
  do.scale = TRUE,
  do.center = TRUE,
  verbose = TRUE)

#################
# Stimulated
#################

# Normalise
Stim.seurat.filt <- NormalizeData(object = Stim.seurat.filt,
  assay = "RNA",
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  verbose = TRUE)

# Find variable genes
Stim.seurat.filt <- FindVariableFeatures(object = Stim.seurat.filt,
  verbose = TRUE)

# Scale data
Stim.seurat.filt <- ScaleData(object = Stim.seurat.filt,
  assay = "RNA",
  vars.to.regress = c("nCount_RNA", "percent.mito"),
  model.use = "linear",
  do.scale = TRUE,
  do.center = TRUE,
  verbose = TRUE)


###############################
# Remove unneeded variables
###############################

rm(US.seurat, Stim.seurat)

```

## Combine treatment conditions {.tabset}

### Integrate data
```{r Integrate_across_conditions}

# Set activate assay to RNA
DefaultAssay(US.seurat.filt) <- "RNA"
DefaultAssay(Stim.seurat.filt) <- "RNA"

# Create list of seurat objects
seurat.list <- list(US = US.seurat.filt, Stim = Stim.seurat.filt)

# Find Integration Anchors
immune.anchors <- FindIntegrationAnchors(object.list = seurat.list, 
                                         anchor.features = 2000, 
                                         scale = TRUE, 
                                         normalization.method = "LogNormalize", 
                                         reduction = "cca", 
                                         l2.norm = TRUE,
                                         dims = 1:30,
                                         k.anchor = 5,
                                         k.filter = 200,
                                         k.score = 30,
                                         max.features = 200,
                                         nn.method = "rann",
                                         eps = 0,
                                         verbose = TRUE)

# Integrate dataset
seurat.combined <- IntegrateData(anchorset = immune.anchors,
                                 new.assay.name = "integrated",
                                 normalization.method = "LogNormalize",
                                 dims = 1:30,
                                 k.weight = 100,
                                 sd.weight = 1,
                                 verbose = TRUE)


# Basic overview of data
seurat.combined # 11,827 cells and 18,295 genes 

US.seurat.filt # 5,785 cells
Stim.seurat.filt # 6,042 cells


# Save files 
saveRDS(US.seurat.filt, file = "Exported_RDS_files/US_seurat_filt.rds")
saveRDS(Stim.seurat.filt, file = "Exported_RDS_files/Stim_seurat_filt.rds")

# Remove unnecessary data
rm(US.seurat.filt)
rm(Stim.seurat.filt)


# Format metadata in integrated seurat object
seurat.combined@meta.data$condition <- factor(seurat.combined@meta.data$condition, levels = c("US", "Stim"))



```

## Clustering and dim reduction {.tabset}

### PCA and cluster identificaton
```{r Cluster_data}

DefaultAssay(seurat.combined) <- "integrated"

# Scale data
seurat.combined <- ScaleData(seurat.combined, 
                             verbose = TRUE)

# Run PCA
seurat.combined <- RunPCA(seurat.combined, 
                          npcs = 30, 
                          verbose = TRUE)

# Find Neighbors
seurat.combined <- FindNeighbors(seurat.combined, 
                                 reduction = "pca", 
                                 k.param = 20,
                                 dims = 1:20)

# Find clusters
seurat.combined <- FindClusters(seurat.combined, 
                                random.seed = 42,
                                resolution = 0.4) # 0.4 is cluster resolution decided upon


```

### Run UMAP
```{r UMAP}

# Create output directory
if(!dir.exists("output/figures/UMAP_no_clusts_removed")){
  dir.create("output/figures/UMAP_no_clusts_removed", 
             recursive = T)
}


# Run UMAP
seurat.combined <- RunUMAP(object = seurat.combined,
                           reduction = "pca",
                           dims = 1:20,
                           umap.method = "uwot",
                           n.neighbors = 30, # 5 to 50
                           min.dist = 0.3, # Sensible values are in the range 0.001 to 0.5
                           seed.use = 42)


# Plot UMAP projection
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + ggtitle("Integrated (n.neigh = 30 & min.dist = 0.3)")

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_clusts_clust.pdf")
dev.off()



# UMAP projection grouped by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         cols = Condition.cols,
         group.by = "condition") + ggtitle("UMAP vis by Condition") 

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_condition.pdf")
dev.off()



p1 <- DimPlot(seurat.combined, 
              reduction = "umap", 
              cols = Condition.cols,
              group.by = "condition")

p2 <- DimPlot(seurat.combined, 
              reduction = "umap", 
              label = TRUE)

p1|p2

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_clusters_conditions_sidebyside.pdf")
dev.off()


```

## Remove uninformative clusters {.tabset}

### Visualise and justify removing clusters 
```{r Justify_clusts_to_remove}

# Based on resolution of 0.4 for cluster identification 
# Cluster #15 and 13 are to be removed 
# 15 = Myeloid population 
# 13 = ?? 


# Create output directory
if(!dir.exists("output/figures/Cluster_removal_validation")){
  dir.create("output/figures/Cluster_removal_validation", 
             recursive = T)
}


# Show overall number and frequency of clusters

x <- table(seurat.combined@meta.data$seurat_clusters)
y <- prop.table(table(seurat.combined@meta.data$seurat_clusters))*100

barplot(x, 
        main = "# of cells per cluster", 
        xlab = "Cluster #", 
        ylab = "# of cells",
        cex.names = 0.8, 
        ylim = c(0, 2000))

dev.copy(pdf, "output/figures/Cluster_removal_validation/Number_cells_per_cluster.pdf")
dev.off()

barplot(y,
        main = "% of cells per cluster",
        xlab = "Cluster #",
        ylab = "% of cells",
        cex.names = 0.8, 
        ylim = c(0, 20))

dev.copy(pdf, "output/figures/Cluster_removal_validation/Percent_cells_per_cluster.pdf")
dev.off()


##########################################################################################
# Get differentially expressed genes for clusters to be removed and show heatmaps
##########################################################################################

# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

################
# Positive only
################

# Find markers for clust 13
Clust.13.Markers <- FindMarkers(seurat.combined,
                                assay = "RNA",
                                ident.1 = "13",
                                only.pos = TRUE,
                                min.diff.pct = 0.1,
                                return.thresh = 0.05)


# Find markers for clust 15
Clust.15.Markers <- FindMarkers(seurat.combined,
                                assay = "RNA",
                                ident.1 = "15",
                                only.pos = TRUE,
                                min.diff.pct = 0.1,
                                return.thresh = 0.05)

###################
# Heatmap vis
###################

# Downsample for heatmap vis
seurat.combined.small <- subset(seurat.combined, downsample = 300)

# Heatmap of Clust 13 markers
sig.genes <- Clust.13.Markers[Clust.13.Markers$p_val_adj < 0.1, ]




# Heatmap of Clust 15 markers
sig.genes <- Clust.15.Markers[Clust.15.Markers$p_val_adj < 0.1, ]








# Plot DEGs as heatmap for vis justification for removal


```

### Use Clustifyr to call cluster identities
**Note: What is up with the mouse.ref here?**
```{r Clustifyr_cell_ID}

# Create output directories
if(!dir.exists("output/figures/Cell_type_annotation/Clustifyr")){
  dir.create("output/figures/Cell_type_annotation/Clustifyr", 
             recursive = T)
}


#devtools::install_github("rnabioco/clustifyr")
library(clustifyr)

mouse.ref <- cbmc_ref
rownames(mouse.ref) <- str_to_title(rownames(mouse.ref))


res <- clustify(input = seurat.combined,
                cluster_col = "seurat_clusters",
                ref_mat = cbmc_ref,
                seurat_out = FALSE,
                query_genes = seurat.combined@assays$integrated@var.features)


res2 <- cor_to_call(cor_mat = res,                  # matrix correlation coefficients
                    cluster_col = "seurat_clusters") # name of column in meta.data containing cell clusters



print(plot_cor_heatmap(cor_mat = res))
dev.copy(pdf, "output/figures/Cell_type_annotation/Clustifyr/Heatmap_cluster_annotations.pdf")
dev.off()


```

### Use various SingleR databases to call cluster identities
```{r SingleR_cell_clasification}

# Create output directory
if(!dir.exists("output/figures/Cell_type_annotation/SingleR")){
  dir.create("output/figures/Cell_type_annotation/SingleR", 
             recursive = T)
}

# Load package
#BiocManager::install("SingleR")
library(SingleR)

################################################################
# Use a couple databased to get broad overview of clusters 
################################################################

##################################
# Use HumanPrimaryCellAtlasData
##################################
# Info: Human, Microarray, 713 samples, 37 main labels, 157 fine lables, Non-specific focus

HumanPrimaryCellAtlasData.data <- HumanPrimaryCellAtlasData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = HumanPrimaryCellAtlasData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = HumanPrimaryCellAtlasData.data$label.fine)

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_HumanPrimaryCellAtlasData_db.pdf")
dev.off()

##########################
# Use BlueprintEncodeData
##########################
# Info: Human, RNAseq, 259 samples, 24 main labels, 43 fine lables, Non-specific focus

BlueprintEncodeData.data <- BlueprintEncodeData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = BlueprintEncodeData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = BlueprintEncodeData.data$label.fine)

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_BlueprintEncodeData_db.pdf")
dev.off()

##########################################
# Use NovershternHematopoieticData
##########################################
# Info: Human, Microarray, 211 samples, 17 main labels, 38 fine lables, Hematopoietic & Immune focus

NovershternHematopoieticData.data <- NovershternHematopoieticData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = NovershternHematopoieticData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = NovershternHematopoieticData.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_NovershternHematopoietic_db.pdf")
dev.off()

#####################
# Use ImmGenData
#####################
# Info: Mouse, Microarray, 830 samples, 20 main labels, 253 fine lables, Hematopoietic & Immune focus

ImmGen.data <- ImmGenData()

# Convert GeneID to match human
ImmGen.data.counts <- ImmGen.data@assays@data$logcounts
rownames(ImmGen.data.counts) <- toupper(rownames(ImmGen.data.counts))


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = ImmGen.data.counts, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = ImmGen.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_ImmGen_db.pdf")
dev.off()




################################################################
# Most useful database is probably the MonacoImmuneData
################################################################

#########################
# Use MonacoImmuneData
#########################
# Info: Human, RNAseq, 114 samples, 11 main labels, 29 fine lables, Immune cell focus
Immune.data <- MonacoImmuneData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = Immune.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = Immune.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_Monaco_db.pdf")
dev.off()


# Restrict labels to biologicaly relevant 
Immune.data.counts <- Immune.data@assays@data$logcounts

pattern <- c("CD8", "MAIT", "gd", "Intermediate")

labels.keep <- grepl(paste0(pattern, collapse = "|"), Immune.data$label.fine)

Immune.data.counts <- Immune.data.counts[,labels.keep]

SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = Immune.data.counts, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = Immune.data$label.fine[labels.keep])

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_limited_labels_Monaco_db.pdf")
dev.off()


```

### Myeloid and Mitochondrial populations
```{r Remove_clusters}

# Remove cluster 13 and 15
seurat.combined <- subset(seurat.combined, idents = c(0:12, 14))

# Check clusters are removed
levels(seurat.combined@meta.data$seurat_clusters)

# Save old cluster IDs
seurat.combined@meta.data$seurat_clusters_old <- seurat.combined@meta.data$seurat_clusters


```

## Recalculate UMAP and Visualise {.tabset}

### Recalculate UMAP
```{r Recalculate_UMAP}

###########################
# Recalculate UMAP
###########################

DefaultAssay(seurat.combined) <- "integrated"

# Scale data
seurat.combined <- ScaleData(seurat.combined, 
                             verbose = TRUE)

# Run PCA
seurat.combined <- RunPCA(seurat.combined, 
                          npcs = 30, 
                          verbose = TRUE)

# Find Neighbors
seurat.combined <- FindNeighbors(seurat.combined, 
                                 reduction = "pca", 
                                 k.param = 20,
                                 dims = 1:20)

# Find clusters
seurat.combined <- FindClusters(seurat.combined, 
                                random.seed = 42,
                                resolution = 0.4)


# Run UMAP
seurat.combined <- RunUMAP(object = seurat.combined,
                           reduction = "pca",
                           dims = 1:20,
                           umap.method = "uwot",
                           n.neighbors = 30, # 5 to 50
                           min.dist = 0.3, # Sensible values are in the range 0.001 to 0.5
                           seed.use = 42)

```

### Vis new UMAP
```{r Visualise_new_UMAP_projection}

# Create output directory
if(!dir.exists("output/figures/UMAP")){
  dir.create("output/figures/UMAP", 
             recursive = T)
}


Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters_new

# Plot UMAP projection
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + 
  ggtitle("UMAP new projection and clust IDs")

dev.copy(pdf, "output/figures/UMAP/UMAP_new_clust_IDs_numbered.pdf")
dev.off()

# Plot UMAP projection with old clust IDs
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters_old

UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + 
  ggtitle("UMAP new projection - original clust IDs")

dev.copy(pdf, "output/figures/UMAP/UMAP_original_clust_IDs_numbered.pdf")
dev.off()

```

### Rename clusters
```{r rename_clusters}

# Name clusters

# Save cluster IDs - new ids = those after removal of clusters
seurat.combined@meta.data$seurat_clusters_new <- seurat.combined@meta.data$seurat_clusters

# Set Idents to cluster IDs following cluster removal 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Rename classes.
seurat.combined <- RenameIdents(object = seurat.combined,
                                `0` = "Cytotoxic",
                                `1` = "Naive_like_3",
                                `2` = "Exhausted_1", 
                                `3` = "Type_I_IFN",
                                `4` = "Naive_like_1_CM", # Central memory?
                                `5` = "Naive_like_2_SC", # Stem-cell-like
                                `6` = "Stimulated_1", # Derived from cytotoxic ?
                                `7` = "Stimulated_exhausted",
                                `8` = "gd_T_non_g9d2", 
                                `9` = "Exhausted_2",
                                `10` = "MAIT", 
                                `11` = "TRM", 
                                `12` = "gd_T_g9d2", 
                                `13` = "Proliferative")


# Relevel idents variable to group clusters into order of future modules 

# Module: Naive / Stem-like 
# Naïve_like_1_CM
# Naïve_like_2_SC
# Naïve_like_3

# Module: Activated
# Cytotoxic
# Type_I_IFN
# Stimulated_1

# Module: Exhaustion
# Stimulated_exhausted
# Exhausted_1, 
# Exhausted_2
# TRM

# Module: Innate
# gd_T_g9d2
# gd_T_non_g9d2 
# MAIT 

# Module: Cycling
# Proliferative


# reset levels of factor variable 
seurat.combined@active.ident <- factor(seurat.combined@active.ident, 
                                       levels = c("Naive_like_1_CM",
                                                  "Naive_like_2_SC", 
                                                  "Naive_like_3", 
                                                  "Cytotoxic",
                                                  "Type_I_IFN",
                                                  "Stimulated_1",
                                                  "Stimulated_exhausted",
                                                  "Exhausted_1",
                                                  "Exhausted_2", 
                                                  "TRM", 
                                                  "gd_T_g9d2", 
                                                  "gd_T_non_g9d2", 
                                                  "MAIT",
                                                  "Proliferative"))



# Change "seurat_clusters" metadata label to new ident names as this slot is used in downstream plotting
seurat.combined@meta.data$seurat_clusters <- Idents(seurat.combined)

```

### UMAP with Named clusters
```{r Vis_Named_Clusters_UMAP}

# Create output directory
if(!dir.exists("output/figures/UMAP")){
  dir.create("output/figures/UMAP", 
             recursive = T)
}


##########################################
# Plot UMAPs with cluster names
##########################################


Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# UMAP named clusters
UMAPPlot(object = seurat.combined,
         pt.size = 1,
         label = FALSE, 
         cols = clust.cols) + 
  ggtitle("UMAP named clusters")

dev.copy(pdf, "output/figures/UMAP/UMAP_clusters.pdf")
dev.off()

# UMAP named clusters - labeled 
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         pt.size = 1,
         label.size = 6,
         cols = clust.cols) + 
  NoLegend() +
  ggtitle("UMAP named clusters")

dev.copy(pdf, "output/figures/UMAP/UMAP_clusters_labeled.pdf")
dev.off()


#############
# Condition
#############

# Split by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "condition",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by condition")

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_conditions.pdf")
dev.off()

# Split by condition // No legend
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "condition",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by condition") + 
  NoLegend()

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_conditions_Nolegend.pdf")
dev.off()

# Group by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         group.by = "condition",
         cols = Condition.cols,
         label.size = 6) + 
  ggtitle("UMAP group by condition")

dev.copy(pdf, "output/figures/UMAP/UMAP_groupby_conditions.pdf")
dev.off()


#############
# Sample
#############

# Split by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "group",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by Sample")

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_sample.pdf")
dev.off()


# Group by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         group.by = "group",
         pt.size = 1,
         label.size = 6) + 
  ggtitle("UMAP group by Sample")

dev.copy(pdf, "output/figures/UMAP/UMAP_groupby_sample.pdf")
dev.off()







```

### Saving dim reduction Embeddings to metadata
```{r Save_dimreduction_embeddings}

# UMAP embeddings
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$umap@cell.embeddings[,1], "UMAP_1")
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$umap@cell.embeddings[,2], "UMAP_2")

# Save PCA (Dim 1 and 2) embeddings
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$pca@cell.embeddings[,1], "PCA_1")
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$pca@cell.embeddings[,2], "PCA_2")

head(seurat.combined@meta.data)

```

## Group clusters into modules {.tabset}

### Create Modules
```{r Create_modules}

# Create output directory
if(!dir.exists("output/figures/Modules")){
  dir.create("output/figures/Modules", 
             recursive = T)
}


# Group clusters together into functional modules 
# Module aggregation based on visualisation and analysis of DEGs in each cluster 


# Use numeric cluster IDs followin myeloid and mitochondrial cluster removal 
# use numeric ids as allows easy changing of cluster names without impacting module creation

# Exhaustion module
# 2, 7, 9, 11 (NB 11 is likely Tissue_resident)

# Activated
# 0, 3, 6

# Innate
# 8, 10, 12

# Naive / Stem-like 
# 1, 4, 5

# Cycling
# 13


# Get cluster IDs
Module.groups <- seurat.combined@meta.data$seurat_clusters_new
Module.groups <- as.numeric(as.character(Module.groups)) # need to remove factorisation

#######################################################
# Assign cluster IDs to module groups // use ^ and $ start and end anchors to create exact match, exclude selecting 11 for grep("1") etc
#######################################################

# Exhaustion Module \\ 2, 7, 9, 11
logic.vec <- grepl(paste0(c("^2$", "^7$", "^9$", "^11$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Exhaustion"

# Activated Module \\ 0, 3, 6
logic.vec <- grepl(paste0(c("^0$", "^3$", "^6$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Activated"

# Innate Module \\ 8, 10, 12
logic.vec <- grepl(paste0(c("^8$", "^10$", "^12$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Innate"

# Naive/Stem-like Module \\ 1, 4, 5
logic.vec <- grepl(paste0(c("^1$", "^4$", "^5$"), collapse = "|"), Module.groups)
Module.groups[logic.vec] <- "Naive_Stem"

# Cycling Module \\ 13
logic.vec <- grepl("^13$", Module.groups)
Module.groups[logic.vec] <- "Cycling"


# Assign Module groups to metadata
seurat.combined@meta.data$Module <- factor(Module.groups,
                                           levels = c("Naive_Stem",
                                                      "Activated", 
                                                      "Exhaustion", 
                                                      "Innate", 
                                                      "Cycling"))


##############################
# UMAP vis of module grouping
##############################

# Plot clusters
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

p1 <- UMAPPlot(object = seurat.combined,
               label = TRUE, 
               pt.size = 1,
               label.size = 6) + 
  NoLegend() +
  ggtitle("Clusters")


# Plot modules
Idents(seurat.combined) <- seurat.combined@meta.data$Module

p2 <- UMAPPlot(object = seurat.combined,
               label = FALSE, 
               pt.size = 1,
               label.size = 6) + 
  ggtitle("Modules")


# Plot side by side
p1|p2


dev.copy(pdf, "output/figures/Modules/UMAP_Clusts_to_Modules.pdf")
dev.off()

UMAPPlot(seurat.combined, 
         group.by = "group")

table(seurat.combined@meta.data$group, seurat.combined@meta.data$seurat_clusters)



```

### Create Cluster/Module by condition metadata
```{r Generate_metadata_for_Cluster_Module_by_Condition}

######################################################
# Create additional Metadata for downstream analysis
######################################################
# Now that clusters are cleaned and renamed 
# Generate a joint cluster/Module & condition_ID variable

# Using named clusters
seurat.combined@meta.data$condition_clust <- paste(seurat.combined@meta.data$condition, 
                                                   seurat.combined@meta.data$seurat_clusters, sep = "_")

# Using numeric cluster IDs
seurat.combined@meta.data$condition_clust_numeric <- paste(seurat.combined@meta.data$condition, 
                                                           seurat.combined@meta.data$seurat_clusters_new, sep = "_")

# Condition & Module variable
seurat.combined@meta.data$condition_module <- paste(seurat.combined@meta.data$condition, 
                                                    seurat.combined@meta.data$Module, sep = "_")


```

### Vis overview of Modules
```{r Visualise_modules}

# Create output directory
if(!dir.exists("output/figures/Modules")){
  dir.create("output/figures/Modules", 
             recursive = T)
}

#########################################
# Vis distribution of modules in UMAPs
#########################################

Idents(seurat.combined) <- seurat.combined@meta.data$Module


# Modules
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         label.size = 6, 
         cols = module.cols) + 
  ggtitle("Modules")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules.pdf")
dev.off()

# Modules No legend
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         pt.size = 1,
         label.size = 6,
         cols = module.cols) + 
  NoLegend() +
  ggtitle("Modules")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_labelled.pdf")
dev.off()

##########
# Sample
##########

# Split by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "group",
         label.size = 6,
         cols = module.cols) + 
  ggtitle("UMAP Modules split by sample")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_splitby_sample.pdf")
dev.off()


# Grouped by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         group.by = "group",
         label.size = 6) + 
  ggtitle("UMAP Modules group by sample")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_groupby_sample.pdf")
dev.off()

##############
# Condition
##############

# Split by Condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "condition",
         label.size = 6,
         cols = module.cols) + 
  ggtitle("UMAP Modules split by Condition")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_splitby_condition.pdf")
dev.off()

# group by Condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         group.by = "condition",
         cols = Condition.cols,
         label.size = 6) + 
  ggtitle("UMAP Modules group by Condition")

dev.copy(pdf, "output/figures/Modules/UMAP_Modules_groupby_condition.pdf")
dev.off()

```


## Export large data {.tabset}

### Export seurat object
```{r export_RDS}
if(!quick.load){
  saveRDS(seurat.combined, file = "Exported_RDS_files/seurat_combined_no_imputation.rds")
}

```

### Save large data tables
```{r write_data, eval = FALSE}

if(long.compute){
  
  
  # Create output directory
  if(!dir.exists("output/tables/Large_dataframes")){
    dir.create("output/tables/Large_dataframes", 
               recursive = T)
  }
  
  
  save.data.frame.function <- function(df, title){
    
    x <- as.data.frame(as.matrix(df))
    
    write.table(x, 
                paste0("output/tables/Large_dataframes/", title, ".txt"),
                sep = "\t",
                quote = FALSE)
  }
  
  # Raw data
  save.data.frame.function(seurat.combined@assays$RNA@counts, "Raw_dataframe")
  
  # Normed data
  save.data.frame.function(seurat.combined@assays$RNA@data, "filtered_dataframe")
  
  # Scaled data
  save.data.frame.function(seurat.combined@assays$RNA@scale.data, "scaled_dataframe")
  
  # PCA embeddings
  save.data.frame.function(seurat.combined@reductions$pca@cell.embeddings, "RNA_PCA")
  
  # UMAP embeddings
  save.data.frame.function(seurat.combined@reductions$umap@cell.embeddings, "RNA_UMAP")
  
  # Metadata
  save.data.frame.function(seurat.combined@meta.data, "Meta_data_dataframe")
  
  # Integrated normed values
  save.data.frame.function(seurat.combined@assays$integrated@data, "filtered_integrated_dataframe")
  
  # Integrated scaled data
  save.data.frame.function(seurat.combined@assays$integrated@scale.data, "scaled_integrated_dataframe")
  
}

```


## Imputation {.tabset}

### Imputation calculation
```{r seurat_imputation}


######################
# Impute values 
######################
if(long.compute){
  seurat.combined <- RunALRA(seurat.combined, 
                             genes.use = rownames(seurat.combined))
}

# 8.37% of the values became negative in the scaling process and were set to zero
# The matrix went from 29.63% nonzero to 38.95% nonzero


####################
# Calculate k value
####################
if(long.compute){
  
  Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
  seurat.combined.small <- subset(seurat.combined, downsample = 100)
  
  ALRA.out <- RunALRA(seurat.combined.small,
                      k.only = TRUE)
  
  ggouts <- ALRAChooseKPlot(ALRA.out)
  
  ggouts
  dev.copy(pdf, "output/QC/Imputation_K_plot.pdf")
  dev.off()
}


# set default assay back to RNA
DefaultAssay(seurat.combined) <- "RNA"
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

```


## Export large data after imputation {.tabset}

### Export seurat object with imputation
```{r export_RDS}
if(!quick.load){
  saveRDS(seurat.combined, file = "Exported_RDS_files/seurat_combined.rds")
}

if(long.compute){
  
  
  # Create output directory
  if(!dir.exists("output/tables/Large_dataframes")){
    dir.create("output/tables/Large_dataframes", 
               recursive = T)
  }
  
  
  save.data.frame.function <- function(df, title){
    
    x <- as.data.frame(as.matrix(df))
    
    write.table(x, 
                paste0("output/tables/Large_dataframes/", title, ".txt"),
                sep = "\t",
                quote = FALSE)
  }
  
  # Imputed values
  save.data.frame.function(seurat.combined@assays$alra@counts, "Imputed_counts_dataframe")
  
}


```



## Visualise distribution of cells across clusters/condition/modules {.tabset}

### Plot distribution of cells per each cluster 
```{r Distribution_cells_per_cluster}

# Create output directory
if(!dir.exists("output/figures/Clust_and_Module_distribution")){
  dir.create("output/figures/Clust_and_Module_distribution", 
             recursive = T)
}

################################
# Plot cluster wise distribution
################################
default.mar <- par()$mar

par(mar = c(10.1, 5.1, 4.1, 2.1))


# Number of cells 
x <- table(seurat.combined@meta.data$seurat_clusters)

barplot(t(x), 
        main = "Number of cells per clust",
        ylab = "Number of cells",
        cex.names = 1,
        las = 2,
        ylim = c(0, 2500),
        legend = TRUE, 
        beside = TRUE)


dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Number_cells_per_clust.pdf")
dev.off()

# Frequency 
x <- prop.table(table(seurat.combined@meta.data$seurat_clusters)) * 100

barplot(t(x), 
        main = "Freq of cells per clust",
        ylab = "% of total",
        cex.names = 1, 
        las = 2,
        ylim = c(0, 20),
        legend = TRUE, 
        beside = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Freq_cells_per_clust.pdf")
dev.off()



###################################################
# Plot Freq per cluster per condition 
###################################################

# Be aware, US and Stim have diff total number of cells and therefore should be represented as a % normalised to total condition cell #

condition.cell.n <- table(seurat.combined@meta.data$condition)
US.cell.n <- condition.cell.n[1]
Stim.cell.n <- condition.cell.n[2]

Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
Cluster.cell.n <- table(Idents(seurat.combined), seurat.combined@meta.data$condition)

Cluster.cell.n[,1] <- Cluster.cell.n[,1]/US.cell.n*100
Cluster.cell.n[,2] <- Cluster.cell.n[,2]/Stim.cell.n*100

colSums(Cluster.cell.n) # sanity check, both should = 100%

barplot(t(Cluster.cell.n),
        main = "% of cells per cluster per condition",
        ylab = "% of cells",
        col = Condition.cols,
        cex.names = 1, 
        las = 2,
        ylim = c(0, 30), 
        beside = TRUE, 
        legend = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_cluster_per_condition.pdf")
dev.off()


# reset margin to default 
par(mar = c(default.mar))


#########################################
# Plot Module wise distribution
#########################################

# Plot total cell # per module 

Module.cell.n <- table(seurat.combined@meta.data$Module)

barplot(Module.cell.n, 
        main = "# of cells per Module", 
        xlab = "Module", 
        ylab = "# of cells",
        cex.names = 0.8, 
        ylim = c(0, 5000))

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Number_cells_per_Module.pdf")
dev.off()


# Plot freq of total per module
Module.freq <- prop.table(table(seurat.combined@meta.data$Module))*100

barplot(Module.freq,
        main = "% of cells per Module",
        xlab = "Module",
        ylab = "% of cells",
        cex.names = 0.8, 
        ylim = c(0, 40))

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_Module.pdf")
dev.off()


###################################################
# Plot Freq per module per condition 
###################################################

# Be aware, US and Stim have diff total number of cells and therefore should be represented as a % normalised to total condition cell #

condition.cell.n <- table(seurat.combined@meta.data$condition)
US.cell.n <- condition.cell.n[1]
Stim.cell.n <- condition.cell.n[2]

Idents(seurat.combined) <- seurat.combined@meta.data$Module
Module.cell.n <- table(Idents(seurat.combined), seurat.combined@meta.data$condition)

Module.cell.n[,1] <- Module.cell.n[,1]/US.cell.n*100
Module.cell.n[,2] <- Module.cell.n[,2]/Stim.cell.n*100

colSums(Module.cell.n) # sanity check, both should = 100%


barplot(t(Module.cell.n),
        main = "% of cells per Module per condition",
        xlab = "Module",
        ylab = "% of cells",
        col = Condition.cols,
        cex.names = 0.8, 
        ylim = c(0, 50), 
        beside = TRUE, 
        legend = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_Module_per_condition.pdf")
dev.off()



```


## DEG analysis {.tabset}

### DEG between modules
```{r DEG_between_modules}

# Create output directory
if(!dir.exists("output/tables/DEG_Modules")){
  dir.create("output/tables/DEG_Modules", 
             recursive = T)
}

# Set Idents
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

################
# Pos DEGs
################

# Find markers
Module.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA",
                                 only.pos = TRUE,
                                 min.diff.pct = 0.1,
                                 return.thresh = 0.05)

# Write data to file
write.csv(Module.markers, "output/tables/DEG_Modules/Module_markers_unfiltered_pos.csv")

# Filter by sig Padj val
sum(Module.markers$p_val_adj < 0.05) # 772 genes 

write.csv(Module.markers[Module.markers$p_val_adj < 0.05, ], "output/tables/DEG_Modules/Module_markers_sig_only_pos.csv")


################
# Pos and Neg
################

# Find markers
Module.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA",
                                 only.pos = FALSE,
                                 min.diff.pct = 0.1,
                                 return.thresh = 0.05)

# Write data to file
write.csv(Module.markers, "output/tables/DEG_Modules/Module_markers_unfiltered.csv")

# Filter by sig Padj val
sum(Module.markers$p_val_adj < 0.05) 

write.csv(Module.markers[Module.markers$p_val_adj < 0.05, ], "output/tables/DEG_Modules/Module_markers_sig_only.csv")


################################################
# Extract the top markers for each module
################################################

# Get top markers for each module - use Positive markers only
sig.markers <- Module.markers[Module.markers$p_val_adj < 0.05, ]

Module.vect <- unique(Module.markers$cluster)

for(i in 1:length(Module.vect)){
  
  print(paste0("Getting markers for Module ", Module.vect[i]))
  
  input.df <- sig.markers[sig.markers$cluster == Module.vect[i], ]
  
  assign(paste0("Module_", Module.vect[i]), top_n(input.df, 40,  avg_logFC))
  
  x <- eval(parse(text = paste0("Module_", Module.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Modules/Top_40_markers_for_Module_", Module.vect[i], ".csv"))
  
}


```

### DEGs of modules between conditions
```{r DEGs_of_modules_between_conditions}


# Create output directories
if(!dir.exists("output/tables/DEG_Modules_btn_conditions")){
  dir.create("output/tables/DEG_Modules_btn_conditions", 
             recursive = T)
}


if(!dir.exists("output/figures/DEG_Modules_btn_conditions")){
  dir.create("output/figures/DEG_Modules_btn_conditions", 
             recursive = T)
}


# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

# Get vector of clusters
Module.vect <- seurat.combined@meta.data$Module
Module.vect <- levels(Module.vect)

for(i in 1:length(Module.vect)){
  
  print(paste0("Analysis for Module ", Module.vect[i]))
  
  # Set idents to the condition_cluster
  Idents(seurat.combined) <- seurat.combined@meta.data$condition_module
  
  # Calculating DEGs for each cluster across condition
  DEG.var <- FindMarkers(seurat.combined,
                         ident.1 = paste0("Stim_", Module.vect[i]), 
                         ident.2 = paste0("US_", Module.vect[i]),
                         test.use = "wilcox",
                         logfc.threshold = 0.25,
                         min.pct = 0.1,
                         only.pos = FALSE,
                         verbose = FALSE)
  
  # create column for gene ID
  DEG.var$gene <- rownames(DEG.var)
  
  # Write data to file
  write.csv(DEG.var, paste0("output/tables/DEG_Modules_btn_conditions/Stim_vs_US_DEG_module_", Module.vect[i], ".csv"))
  
  #########################################
  # Get top DEGs for clusters Stim vs. US
  #########################################
  
  print(paste0("Getting top markers for module ", Module.vect[i], " Stim vs. US"))
  
  sig.markers <- DEG.var[DEG.var$p_val_adj < 0.05, ]
  
  assign(paste0("Condition_Module_DEGs_", Module.vect[i]), top_n(sig.markers, 40,  avg_logFC))
  
  x <- eval(parse(text = paste0("Condition_Module_DEGs_", Module.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Modules_btn_conditions/Top_40_markers_for_Stim_vs_US_Module_", Module.vect[i], ".csv"))
  
  ############################################
  # plotting DEG per module across condition
  ############################################
  
  # Set idents to Module ID
  Idents(seurat.combined) <- seurat.combined@meta.data$Module
  
  # Subset for Module ID
  subset.seurat <- subset(seurat.combined, idents = paste0(Module.vect[i]))
  
  # Set idents to condition var
  Idents(subset.seurat) <- subset.seurat@meta.data$condition
  
  # Get top 10 genes
  # up-regulated genes
  genes.to.label.1 <- top_n(DEG.var, 10, avg_logFC)$gene
  
  # Down-regulated genes
  genes.to.label.2 <- top_n(DEG.var, -10, avg_logFC)$gene
  
  # Create vector of genes
  genes.to.label <- unique(c(genes.to.label.1, genes.to.label.2))
  
  # Average expression
  avg.subset.seurat <- log1p(AverageExpression(subset.seurat, verbose = FALSE)$RNA)
  
  # Create column with gene id 
  avg.subset.seurat$gene <- rownames(avg.subset.seurat)
  
  # Generate plot
  p1 <- ggplot(avg.subset.seurat, 
               aes(US, Stim)) + 
    geom_point() + 
    ggtitle(paste0("Module ", Module.vect[i]))
  
  p1 <-  LabelPoints(plot = p1,
                     points = genes.to.label,
                     repel = TRUE)
  
  print(plot(p1))
  dev.copy(pdf, paste0("output/figures/DEG_Modules_btn_conditions/ScatterPlot_Stim_vs_US_Module_", Module.vect[i], ".pdf"))
  dev.off()
  
  # Remove large variable
  rm(subset.seurat)
  rm(DEG.var)
  
}



```

### DEGs between clusters 
```{r DEGs_between_clusters}

# Create output directory
if(!dir.exists("output/tables/DEG_Clusters")){
  dir.create("output/tables/DEG_Clusters", 
             recursive = T)
}

# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

################
# Positive only
################

# Find markers
Cluster.markers.pos <- FindAllMarkers(seurat.combined,
                                      assay = "RNA",
                                      only.pos = TRUE,
                                      min.diff.pct = 0.1,
                                      return.thresh = 0.05)

# Write data to file
write.csv(Cluster.markers.pos, "output/tables/DEG_Clusters/Cluster_markers_unfiltered_pos.csv")

# Filter by sig Padj val
sum(Cluster.markers.pos$p_val_adj < 0.05) # 2,919 genes 

write.csv(Cluster.markers.pos[Cluster.markers.pos$p_val_adj < 0.05, ], "output/tables/DEG_Clusters/Cluster_markers_sig_only_pos.csv")


################
# Pos and Neg
################

# Find markers
Cluster.markers <- FindAllMarkers(seurat.combined,
                                  assay = "RNA",
                                  only.pos = FALSE,
                                  min.diff.pct = 0.1,
                                  return.thresh = 0.05)

# Write data to file
write.csv(Cluster.markers, "output/tables/DEG_Clusters/Cluster_markers_unfiltered.csv")

# Filter by sig Padj val
sum(Cluster.markers$p_val_adj < 0.05) # 4,890 genes 

write.csv(Cluster.markers[Cluster.markers$p_val_adj < 0.05, ], "output/tables/DEG_Clusters/Cluster_markers_sig_only.csv")


########################
# Get top markers
########################

# Get top markers for each cluster - use Positive markers only
sig.markers <- Cluster.markers.pos[Cluster.markers.pos$p_val_adj < 0.05, ]

Cluster.vect <- unique(sig.markers$cluster)

for(i in 1:length(Cluster.vect)){
  
  
  print(paste0("Getting markers for cluster ", Cluster.vect[i]))
  
  input.df <- sig.markers[sig.markers$cluster == Cluster.vect[i], ]
  
  assign(paste0("Cluster_", Cluster.vect[i]), top_n(input.df, 40,  avg_logFC))
  
  
  x <- eval(parse(text = paste0("Cluster_", Cluster.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Clusters/Top_40_markers_for_cluster_", Cluster.vect[i], ".csv"))
  
}


```

### DEGs of clusters between conditions
```{r DEGs_of_clusts_between_conditions}

# Create output directories
if(!dir.exists("output/tables/DEG_Clusters_btn_conditions")){
  dir.create("output/tables/DEG_Clusters_btn_conditions", 
             recursive = T)
}


if(!dir.exists("output/figures/DEG_Clusters_btn_conditions")){
  dir.create("output/figures/DEG_Clusters_btn_conditions", 
             recursive = T)
}


# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

# Get vector of clusters
clust.var <- seurat.combined@meta.data$seurat_clusters
clust.var <- levels(clust.var)

for(i in 1:length(clust.var)){
  
  print(paste0("Analysis for cluster ", clust.var[i]))
  
  # Set idents to the condition_cluster
  Idents(seurat.combined) <- seurat.combined@meta.data$condition_clust
  
  # Calculating DEGs for each cluster across condition
  DEG.var <- FindMarkers(seurat.combined,
                         ident.1 = paste0("Stim_", clust.var[i]), 
                         ident.2 = paste0("US_", clust.var[i]),
                         test.use = "wilcox",
                         logfc.threshold = 0.25,
                         min.pct = 0.1,
                         only.pos = FALSE,
                         verbose = FALSE)
  
  # create column for gene ID
  DEG.var$gene <- rownames(DEG.var)
  
  # Write data to file
  write.csv(DEG.var, paste0("output/tables/DEG_Clusters_btn_conditions/Stim_vs_US_DEG_clust_", clust.var[i], ".csv"))
  
  #########################################
  # Get top DEGs for clusters Stim vs. US
  #########################################
  
  print(paste0("Getting top markers for cluster ", Cluster.vect[i], " Stim vs. US"))
  
  sig.markers <- DEG.var[DEG.var$p_val_adj < 0.05, ]
  
  assign(paste0("Condition_Cluster_DEGs_", Cluster.vect[i]), top_n(sig.markers, 40,  avg_logFC))
  
  x <- eval(parse(text = paste0("Condition_Cluster_DEGs_", Cluster.vect[i])))
  write.csv(x, paste0("output/tables/DEG_Clusters_btn_conditions/Top_40_markers_for_Stim_vs_US_cluster_", Cluster.vect[i], ".csv"))
  
  ############################################
  # plotting DEG per cluster across condition
  ############################################
  
  # Set idents to cluster ID
  Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
  
  # Subset for cluster ID
  subset.seurat <- subset(seurat.combined, idents = paste0(clust.var[i]))
  
  # Set idents to condition var
  Idents(subset.seurat) <- subset.seurat@meta.data$condition
  
  # Get top 10 genes
  # up-regulated genes
  genes.to.label.1 <- top_n(DEG.var, 10, avg_logFC)$gene
  
  # Down-regulated genes
  genes.to.label.2 <- top_n(DEG.var, -10, avg_logFC)$gene
  
  # Create vector of genes
  genes.to.label <- unique(c(genes.to.label.1, genes.to.label.2))
  
  # Average expression
  avg.subset.seurat <- log1p(AverageExpression(subset.seurat, verbose = FALSE)$RNA)
  
  # Create column with gene id 
  avg.subset.seurat$gene <- rownames(avg.subset.seurat)
  
  # Generate plot
  p1 <- ggplot(avg.subset.seurat, 
               aes(US, Stim)) + 
    geom_point() + 
    ggtitle(paste0("Cluster ", clust.var[i]))
  
  p1 <-  LabelPoints(plot = p1,
                     points = genes.to.label,
                     repel = TRUE)
  
  print(plot(p1))
  dev.copy(pdf, paste0("output/figures/DEG_Clusters_btn_conditions/ScatterPlot_Stim_vs_US_cluster_", clust.var[i], ".pdf"))
  dev.off()
  
  # Remove large variable
  rm(subset.seurat)
  rm(DEG.var)
  
}


```


### singleCellHaystack DEG
```{r singleCellHaystack}

if(long.compute){
  
  # Create output directory
  if(!dir.exists("output/figures/singleCellHaystack")){
    dir.create("output/figures/singleCellHaystack")
  }
  
  # Install package
  #remotes::install_github("alexisvdb/singleCellHaystack")
  
  # Load package
  library(singleCellHaystack)
  
  # Set seed for reproducibility 
  set.seed(42)
  
  ##############################
  # Set up input variables
  ##############################
  
  # Get UMAP dims
  umap.dims <- seurat.combined@reductions$umap@cell.embeddings
  umap.dims <- as.data.frame(umap.dims)
  
  # Get expression data
  exp.data <- seurat.combined@assays$integrated@data
  exp.data <- as.matrix(exp.data)
  
  summary(rowSums(exp.data))
  
  # Determine gene detection
  
  # Above count 1
  detected.genes <- exp.data > 1
  
  # Number of detected genes after thresholding
  general.detection = apply(detected.genes, 2, sum)
  ggplot(umap.dims, aes(x = UMAP_1, y = UMAP_2, colour = general.detection)) + labs(x = "UMAP1", y = "UMAP2") +
    geom_point(size=2) + scale_color_gradient(low="white", high="red") + labs(color = "Det. genes")
  
  
  # Run haystack DEG calculation
  res.umap <- haystack(umap.dims, 
                       detection = detected.genes, 
                       method = "2D")
  
  class(res.umap)
  
  # top 10 DEGs
  show_result_haystack(res.haystack = res.umap,
                       n = 10)
  
  
  # visualize genes of interest
  plot_gene_haystack(umap.dims,
                     expression = exp.data,
                     gene = "CCL4",
                     detection = detected.genes,
                     high.resolution = TRUE,
                     point.size = 1)
  
  
  # set seurat params
  DefaultAssay(seurat.combined) <- "integrated"
  Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
  
  # vis with featureplot
  FeaturePlot(seurat.combined, 
              feature = "HAVCR2", 
              order = TRUE,
              pt.size = 1)
  
  # Vis with Vln
  VlnPlot(seurat.combined, 
          assay = "RNA",
          feature = "PDCD1", 
          pt.size = 0)
  
  
  # get the top most significant genes, and cluster them by their distribution pattern in the 2D plot
  sorted.table <- show_result_haystack(res.haystack = res.umap,
                                       p.value.threshold = 1e-10)
  
  gene.subset <- row.names(sorted.table)
  length(gene.subset) # 1,353
  
  
  # Export data
  write.table(sorted.table, 
              "output/tables/DEG_singleCellHaystack.txt", 
              sep = "\t",
              quote = FALSE)
  
  
  # Use k-means clustering to group DEGs
  km <- kmeans_haystack(umap.dims, 
                        detection = detected.genes,
                        genes = gene.subset,
                        k = 10)
  
  km.clusters <- km$cluster
  
  
  ###################
  # Visualise DEGs
  ###################
  
  goi <- show_result_haystack(res.haystack = res.umap,
                              p.value.threshold = 1e-10, 
                              n = 20)
  goi <- rownames(goi)
  
  for(i in seq_along(goi)){
    
    # Featureplot
    print(FeaturePlot(seurat.combined, 
                      feature = goi[i], 
                      reduction = "umap",
                      order = TRUE,
                      pt.size = 1))
    
    dev.copy(pdf, paste0("output/figures/singleCellHaystack/FeaturePlot_", goi[i], ".pdf"))
    dev.off()
    
    # Vlnplot 
    print(VlnPlot(seurat.combined, 
                  assay = "RNA",
                  feature = goi[i], 
                  pt.size = 0))
    
    dev.copy(pdf, paste0("output/figures/singleCellHaystack/VlnPlot_", goi[i], ".pdf"))
    dev.off()
    
    
  }
  
  
  
  # Vis DEG clusters
  
  seurat.combined.small <- subset(seurat.combined, downsample = 300)
  
  
  for(i in seq_len(max(km.clusters))){
    goi <- names(km.clusters[km.clusters == i])
    
    print(DoHeatmap(seurat.combined.small, 
                    features = goi) + NoLegend())
    
    dev.copy(pdf, paste0("output/figures/singleCellHaystack/DEG_heatmap_cluster_", i, ".pdf"))
    dev.off()
    
  }
  
  
  # Remove un-needed objects
  rm(res.umap, 
     sorted.table, 
     umap.dims, 
     general.detection, 
     km.clusters, 
     detected.genes, 
     exp.data, 
     km)
  
}
```
 

## Visualise DEGs {.tabset}

### Heatmaps and dotplots of Module DEGs
```{r Heatmaps_and_dotplots_of_Module_DEGs}

# Output directory
# Heatmaps
if(!dir.exists("output/figures/Module_DEG_Heatmaps")){
  dir.create("output/figures/Module_DEG_Heatmaps", 
             recursive = T)
}

# Dotplots
if(!dir.exists("output/figures/Module_DEG_dotplots")){
  dir.create("output/figures/Module_DEG_dotplots", 
             recursive = T)
}



# Set assay to integrated
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)


# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)


################################################
# Visualise top markers for each Module
################################################
# as single cell heatmap, averaged heatmap, and dotplot


# get vector of Modules to iterate over
Module.vect <- unique(seurat.combined@meta.data$Module)


for(i in 1:length(Module.vect)){
  
  print(paste0("Evaluating Module = ", Module.vect[i]))
  
  x <- eval(parse(text = paste0("Module_", Module.vect[i])))
  
  # Single cell heatmap
  print(DoHeatmap(seurat.combined.small, 
                  features = x$gene, 
                  size = 4, 
                  angle = 0, 
                  hjust = 0.5,
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Module_DEG_Heatmaps/Heatmap_topDEGs_Module_", Module.vect[i], ".pdf"))
  dev.off()
  
  
  # Average expression heatmap
  print(DoHeatmap(average.seurat, 
                  features = x$gene, 
                  size = 4, 
                  angle = 0, 
                  draw.lines = FALSE,
                  hjust = 0.1,
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Module_DEG_Heatmaps/Heatmap_topDEGs_Module_", Module.vect[i], "_average.pdf"))
  dev.off()
  
  
  print(DotPlot(seurat.combined, 
                assay = "RNA",
                features = x$gene, 
                dot.scale = 8) + 
          RotatedAxis() +  
          theme(text = element_text(size = 4)) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Module_DEG_dotplots/DotPlot_TopDEGs_Module_", Module.vect[i], ".pdf"))
  dev.off()
  
  
}



```

### Curated Module heatmaps
```{r Curated_Module_heatmaps}

# Curated Module Heatmaps
if(!dir.exists("output/figures/Modules/Curated_Heatmaps")){
  dir.create("output/figures/Modules/Curated_Heatmaps", 
             recursive = T)
}

# Set assay to RNA
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)

#################################################
# Plot single cell heatmaps for curated goi
#################################################

# Exhaustion
Exhaustion.sig <- c("CD226", "LAG3", "TIGIT", 
                    "HAVCR2", "TCF7", "TOX",
                    "PDCD1", "IFNG", "GZMA",
                    "ENTPD1", "ICOS", "NKG7", 
                    "GZMB", "PRF1", "CTLA4",
                    "GNLY", "LAYN")

DoHeatmap(seurat.combined.small, 
          features = Exhaustion.sig, 
          size = 4, 
          angle = 0, 
          hjust = 0.5,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_Exhaustion_sig.pdf")
dev.off()


# Naive
Naive.sig <- c("CCR7", "SELL", "IL7R",
               "LTB", "LEF1", "TCF7")

# Stem-like 
Stem.sig <- c("FOSB", "PPP1R15A", "KLF6",
              "JUNB", "NFKBIA", "TCF7",
              "RELB", "CCR7", "CRTAM")

Naive.stem.sig <-unique(c(Naive.sig, Stem.sig))


DoHeatmap(seurat.combined.small, 
          features = Naive.stem.sig, 
          size = 4, 
          angle = 0, 
          hjust = 0.5,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_NaiveStem_sig.pdf")
dev.off()



########################
# Curated heatmaps 
########################

# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)


# Exhaustion
DoHeatmap(average.seurat, 
          features = Exhaustion.sig, 
          size = 4, 
          angle = 0, 
          draw.lines = FALSE,
          hjust = 0.1,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_Exhaustion_sig_Averaged.pdf")
dev.off()

# NaiveStem
DoHeatmap(average.seurat, 
          features = Naive.stem.sig, 
          size = 4, 
          angle = 0, 
          draw.lines = FALSE,
          hjust = 0.1,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Modules/Curated_Heatmaps/Heatmap_curated_NaiveStem_sig_Averaged.pdf")
dev.off()


```

### Heatmaps and dotplots of Cluster DEGs
```{r Heatmaps_and_dotplots_of_Cluster_DEGs}

# Output directory
# Heatmaps
if(!dir.exists("output/figures/Cluster_DEG_Heatmaps")){
  dir.create("output/figures/Cluster_DEG_Heatmaps", 
             recursive = T)
}

# Dotplots
if(!dir.exists("output/figures/Cluster_DEG_dotplots")){
  dir.create("output/figures/Cluster_DEG_dotplots", 
             recursive = T)
}



# Set assay to RNA
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)


# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)


################################################
# Visualise top markers for each Cluster
################################################
# as single cell heatmap, averaged heatmap, and dotplot


# get vector of clusters to iterate over
Cluster.vect <- unique(seurat.combined.small@meta.data$seurat_clusters)


for(i in 1:length(Cluster.vect)){
  
  print(paste0("Evaluating cluster = ", Cluster.vect[i]))
  
  x <- eval(parse(text = paste0("Cluster_", Cluster.vect[i])))
  
  # Single cell heatmap
  print(DoHeatmap(seurat.combined.small, 
                  features = x$gene, 
                  size = 4, 
                  angle = 90, 
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Cluster_DEG_Heatmaps/Heatmap_topDEGs_clust_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Average expression heatmap
  print(DoHeatmap(average.seurat, 
                  features = x$gene, 
                  size = 4, 
                  angle = 90, 
                  draw.lines = FALSE,
                  raster = FALSE) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Cluster_DEG_Heatmaps/Heatmap_topDEGs_clust_", Cluster.vect[i], "_average.pdf"))
  dev.off()
  
  
  print(DotPlot(seurat.combined, 
                assay = "RNA",
                features = x$gene, 
                dot.scale = 8) + 
          RotatedAxis() +  
          theme(text = element_text(size = 4)) + 
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output/figures/Cluster_DEG_dotplots/DotPlot_TopDEGs_clust_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
}


```


### Large heatmaps of top DEGs by foldchange // Average and single cell
```{r Large_Heatmaps_of_top_DEGs}

# Output directory
if(!dir.exists("output/figures/Large_Summary_heatmaps")){
  dir.create("output/figures/Large_Summary_heatmaps", 
             recursive = T)
}


# Set assay to integrated
DefaultAssay(seurat.combined) <- "integrated"

# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)

# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)



###########################
# Get top overall DEGs
###########################

# Get top Module markers
sig.genes <- Module.markers[Module.markers$p_val_adj < 0.05, ]

clusts <- unique(sig.genes$cluster)
output.vect <- NA
top.n <- 100

for(i in 1:length(clusts)){
  
  temp.gene <- sig.genes[sig.genes$cluster == paste0(clusts[i]), ]
  temp.top <- top_n(temp.gene, top.n, avg_logFC)$gene
  
  output.vect <- c(output.vect, temp.top)
  output.vect <- unique(output.vect)
  
}


DoHeatmap(average.seurat, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_byModule_Averaged.pdf")
dev.off()

DoHeatmap(seurat.combined.small, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = TRUE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_byModule.pdf")
dev.off()




# Set Idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# Downsample 
seurat.combined.small <- subset(seurat.combined, downsample = 300)

# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)



# Get top cluster markers
sig.genes <- Cluster.markers[Cluster.markers$p_val_adj < 0.05, ]

clusts <- unique(sig.genes$cluster)
output.vect <- NA
top.n <- 40

for(i in 1:length(clusts)){
  
  temp.gene <- sig.genes[sig.genes$cluster == paste0(clusts[i]), ]
  temp.top <- top_n(temp.gene, top.n, avg_logFC)$gene
  
  output.vect <- c(output.vect, temp.top)
  output.vect <- unique(output.vect)
}





DoHeatmap(average.seurat, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_bycluster_Averaged.pdf")
dev.off()

DoHeatmap(seurat.combined.small, 
          features = output.vect, 
          size = 4, 
          angle = 90, 
          draw.lines = TRUE,
          raster = FALSE) + 
  NoLegend()

dev.copy(pdf, "output/figures/Large_Summary_heatmaps/Heatmap_top_up_genes_bycluster.pdf")
dev.off()




```

### DEGs and selected genes Vlnplots || Modules & Clusters
```{r Vln_feature_plots}

# Create output directories
if(!dir.exists("output/figures/Top_DEG_plots/Modules")){
  dir.create("output/figures/Top_DEG_plots/Modules", 
             recursive = T)
}

if(!dir.exists("output/figures/Top_DEG_plots/Clusters")){
  dir.create("output/figures/Top_DEG_plots/Clusters", 
             recursive = T)
}



# Set assay
DefaultAssay(seurat.combined) <- "RNA"



# Custom list of genes to plot


goi <- c("IFNG", "TNF", "ENTPD1",
         "PDCD1", "TIGIT", "LAYN", 
         "EOMES", "GZMA", "GZMB", 
         "GZMK", "CXCR3", "TOX",
         "CASZ1", "CD226", "CXCL13",
         "CD160", "TBX21",
         "TRBC1", "CD8A", "CD8B", 
         "CD4",
         "FOXP3", "IL2RA", "CTLA4", 
         "CD14", "LYZ", 
         "PRF1", "NKG7", "GNLY", 
         "FCGR3A",
         "KLRB1", "KLRC1", 
         "MKI67", 
         "KIT", 
         "HAVCR2", "LAG3", "TCF7",
         "ICOS", 
         "CCR7", "IL7R", "CD7", "CD69",  
         "ITGAX", "ITGAM", "IL3RA",
         "CD86", "CD83", "IL4I1")



################################################################
# Plot Feature plot and VlnPlot for top DEGs for modules
################################################################

# Generate vector of genes to plot
Top.module.genes <- unique(c(Module_Naive_Stem$gene,
                             Module_Activated$gene,
                             Module_Cycling$gene,
                             Module_Exhaustion$gene,
                             Module_Innate$gene))

# Add custom genes 
Top.module.genes <- unique(c(Top.module.genes, goi))

# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module


for(i in 1:length(Top.module.genes)){
  
  print(paste0("Plotting ", Top.module.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.module.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots/Modules/VlnPlot_", Top.module.genes[i], ".pdf"))
  dev.off()
  
  # Plot feature plot on UMAP projection
  print(FeaturePlot(seurat.combined,
                    features = Top.module.genes[i],
                    reduction = "umap") + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots/FeaturePlot_", Top.module.genes[i], ".pdf"))
  dev.off()
  
}


################################################################
# Plot Feature plot and VlnPlot for top DEGs for Clusters
################################################################


# Generate vector of genes to plot
Top.cluster.genes <- unique(c(Cluster_Cytotoxic$gene,
                              Cluster_Exhausted_1$gene,
                              Cluster_Exhausted_2$gene,
                              Cluster_gd_T_g9d2$gene,
                              Cluster_gd_T_non_g9d2$gene,
                              Cluster_MAIT$gene,
                              Cluster_Naïve_like_1_CM$gene,
                              Cluster_Naïve_like_2_SC$gene,
                              Cluster_Naïve_like_3$gene,
                              Cluster_Proliferative$gene,
                              Cluster_Stimulated_1$gene,
                              Cluster_Stimulated_exhausted$gene,
                              Cluster_TRM$gene,
                              Cluster_Type_I_IFN$gene))



# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Add custom genes 
Top.cluster.genes <- unique(c(Top.cluster.genes, goi))

for(i in 1:length(Top.cluster.genes)){
  
  print(paste0("Plotting ", Top.cluster.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.cluster.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots/Clusters/VlnPlot_", Top.cluster.genes[i], ".pdf"))
  dev.off()
  
  # If gene is already in top.module.gene list this will have already been plotted
  if(Top.cluster.genes[i] %in% Top.module.genes){
    next()
  }else{
    # Plot feature plot on UMAP projection
    print(FeaturePlot(seurat.combined,
                      features = Top.cluster.genes[i],
                      reduction = "umap") + 
            NoLegend())
    
    dev.copy(pdf, paste0("output/figures/Top_DEG_plots/FeaturePlot_", Top.cluster.genes[i], ".pdf"))
    dev.off()
  }
  
}




```

### DEGs and selected genes Vlnplots || Modules & Clusters || Imputed
```{r Vln_feature_plots}

# Create output directories
if(!dir.exists("output/figures/Top_DEG_plots_Imputed/Modules")){
  dir.create("output/figures/Top_DEG_plots_Imputed/Modules", 
             recursive = T)
}

if(!dir.exists("output/figures/Top_DEG_plots_Imputed/Clusters")){
  dir.create("output/figures/Top_DEG_plots_Imputed/Clusters", 
             recursive = T)
}



# Set assay
DefaultAssay(seurat.combined) <- "alra"



# Custom list of genes to plot


goi <- c("IFNG", "TNF", "ENTPD1",
         "PDCD1", "TIGIT", "LAYN", 
         "EOMES", "GZMA", "GZMB", 
         "GZMK", "CXCR3", "TOX",
         "CASZ1", "CD226", "CXCL13",
         "CD160", "TBX21",
         "TRBC1", "CD8A", "CD8B", 
         "CD4",
         "FOXP3", "IL2RA", "CTLA4", 
         "CD14", "LYZ", 
         "PRF1", "NKG7", "GNLY", 
         "FCGR3A",
         "KLRB1", "KLRC1", 
         "MKI67", 
         "KIT", 
         "HAVCR2", "LAG3", "TCF7",
         "ICOS", 
         "CCR7", "IL7R", "CD7", "CD69",  
         "ITGAX", "ITGAM", "IL3RA",
         "CD86", "CD83", "IL4I1")



################################################################
# Plot Feature plot and VlnPlot for top DEGs for modules
################################################################

# Generate vector of genes to plot
Top.module.genes <- unique(c(Module_Naive_Stem$gene,
                             Module_Activated$gene,
                             Module_Exhaustion$gene,
                             Module_Innate$gene,
                             Module_Cycling$gene))

# Add custom genes 
Top.module.genes <- unique(c(Top.module.genes, goi))

# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$Module


for(i in 1:length(Top.module.genes)){
  
  print(paste0("Plotting ", Top.module.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.module.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/Modules/VlnPlot_", Top.module.genes[i], "_imputed.pdf"))
  dev.off()
  
  # Plot feature plot on UMAP projection
  print(FeaturePlot(seurat.combined,
                    features = Top.module.genes[i],
                    reduction = "umap") + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/FeaturePlot_", Top.module.genes[i], "_imputed.pdf"))
  dev.off()
  
}


################################################################
# Plot Feature plot and VlnPlot for top DEGs for Clusters
################################################################


# Generate vector of genes to plot
Top.cluster.genes <- unique(c(Cluster_Naïve_like_1_CM$gene,
                              Cluster_Naïve_like_2_SC$gene,
                              Cluster_Naïve_like_3$gene,
                              Cluster_Cytotoxic$gene,
                              Cluster_Type_I_IFN$gene,
                              Cluster_Stimulated_1$gene,
                              Cluster_Stimulated_exhausted$gene,
                              Cluster_Exhausted_1$gene,
                              Cluster_Exhausted_2$gene,
                              Cluster_TRM$gene,
                              Cluster_gd_T_g9d2$gene,
                              Cluster_gd_T_non_g9d2$gene,
                              Cluster_MAIT$gene,
                              Cluster_Proliferative$gene))




# set idents 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Add custom genes 
Top.cluster.genes <- unique(c(Top.cluster.genes, goi))

for(i in 1:length(Top.cluster.genes)){
  
  print(paste0("Plotting ", Top.cluster.genes[i]))
  
  # Plot VlnPlot
  print(VlnPlot(seurat.combined, 
                features = Top.cluster.genes[i], 
                log = TRUE,
                pt.size = 0) + 
          NoLegend())
  
  dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/Clusters/VlnPlot_", Top.cluster.genes[i], "_imputed.pdf"))
  dev.off()
  
  # If gene is already in top.module.gene list this will have already been plotted
  if(Top.cluster.genes[i] %in% Top.module.genes){
    next()
  }else{
    # Plot feature plot on UMAP projection
    print(FeaturePlot(seurat.combined,
                      features = Top.cluster.genes[i],
                      reduction = "umap") + 
            NoLegend())
    
    dev.copy(pdf, paste0("output/figures/Top_DEG_plots_Imputed/FeaturePlot_", Top.cluster.genes[i], "_imputed.pdf"))
    dev.off()
  }
  
}




```


### Volcano DEGs
```{r Volcano_plots}

# Generate output directories
if(!dir.exists("output/figures/VolcanoPlots/Clusters")){
  dir.create("output/figures/VolcanoPlots/Clusters", 
             recursive = TRUE)
}

if(!dir.exists("output/figures/VolcanoPlots/Modules")){
  dir.create("output/figures/VolcanoPlots/Modules", 
             recursive = TRUE)
}

##############################
# Install and load package
##############################

# "EnhancedVolcano" package from Github repo
# devtools::install_github('kevinblighe/EnhancedVolcano')

library(EnhancedVolcano)


#############
# Functions
#############

clean.data <- function(input.data, group.id){
  
  output.data <- input.data %>%
    dplyr::filter(cluster == paste0(group.id))
  
  rownames(output.data) <- output.data$gene
  
  output.data <- output.data %>%
    dplyr::select(avg_logFC, p_val_adj)
  
  colnames(output.data) <- c("logFC", "FDR")
  return(output.data)
  
}



colour.points <- function(volcano.data, 
                          increase.col = "Red",
                          decreased.col = "Blue",
                          FDR.cutoff = 0.05,
                          logFC.cutoff = 0.25){
  
  # set the base colour
  keyvals <- rep('grey50', nrow(volcano.data))
  
  # set the base name/label as 'NS'
  names(keyvals) <- rep('NS', nrow(volcano.data))
  
  # modify keyvals for vars meeting FDR and LogFC threshold
  
  # Increased
  keyvals[which(volcano.data$logFC > logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- increase.col
  names(keyvals)[which(volcano.data$logFC > logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- 'Increased'
  
  # Decreased
  keyvals[which(volcano.data$logFC < -logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- decreased.col
  names(keyvals)[which(volcano.data$logFC < -logFC.cutoff & volcano.data$FDR < FDR.cutoff)] <- 'Decreased'
  
  return(keyvals)
  
}

# edited enhancedvolcano() function to have the default variables for aesthetics I want

source("R/Enhanced_volcano_custom_defaults.R")



################
# Clusters
################

cluster.markers.df <- read.csv("output/tables/DEG_Clusters/Cluster_markers_unfiltered.csv")


cluster.var <- unique(cluster.markers.df$cluster)


for(i in 1:length(cluster.var)){
  
  # format data
  volcano.data <- clean.data(cluster.markers.df,
                             group.id = cluster.var[i])
  
  keyvals <- colour.points(volcano.data)
  
  
  # get list of top 10 up and 10 downregulated genes
  goi.up <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(10, logFC)
  
  goi.dn <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(-10, logFC)
  
  # combine vectors
  goi <- unique(c(rownames(goi.up), rownames(goi.dn)))
  
  
  
  print(custom.enhanced.volcano(volcano.data, 
                                selectLab = goi, 
                                colCustom = keyvals, 
                                title = paste0(cluster.var[i])))
  
  
  dev.copy(pdf, paste0("output/figures/VolcanoPlots/Clusters/Volcano_", cluster.var[i], ".pdf"))
  dev.off()
  
  
}



################
# Modules
################

Module.markers.df <- read.csv("output/tables/DEG_Modules/Module_markers_unfiltered.csv")


module.var <- unique(Module.markers.df$cluster)


for(i in 1:length(module.var)){
  
  # format data
  volcano.data <- clean.data(Module.markers.df,
                             group.id = module.var[i])
  
  keyvals <- colour.points(volcano.data)
  
  
  # get list of top 10 up and 10 downregulated genes
  goi.up <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(10, logFC)
  
  goi.dn <- volcano.data %>%
    dplyr::filter(FDR < 0.05) %>%
    top_n(-10, logFC)
  
  # combine vectors
  goi <- unique(c(rownames(goi.up), rownames(goi.dn)))
  
  
  
  print(custom.enhanced.volcano(volcano.data, 
                                selectLab = goi, 
                                colCustom = keyvals, 
                                title = paste0(module.var[i])))
  
  
  dev.copy(pdf, paste0("output/figures/VolcanoPlots/Modules/Volcano_", module.var[i], ".pdf"))
  dev.off()
  
  
}















########################################################################
### Below code is kept for any future tweeking of volcano aesthetics 
########################################################################


# Custom point size for points of particular type 
# pointSize = c(ifelse(volcano.data$genes %in% goi, 10, 4))

# Add custom ticks
# +
#  ggplot2::coord_cartesian(xlim=c(-1.5, 3)) +
#  ggplot2::scale_x_continuous(
#    breaks=seq(-1.5, 3, 0.5))




#EnhancedVolcano(volcano.data,
#                lab = rownames(volcano.data),
#                x = 'logFC',
#                y = 'FDR',
#                selectLab = goi,
#xlim = c(-2.5, 2.5),
#ylim = c(0, 500),
#                title = "DNAM1 High vs. Neg",
#                subtitle = "",
#                ylab = bquote(~-Log[10]~adjusted~italic(P)),
##                pCutoff = 0.05,
#                FCcutoff = 0.25,
#                pointSize = 5, 
#col = c("black", "black", "black", "red2"),
#                colCustom = keyvals,
#                colAlpha = 0.2, 
#                drawConnectors = TRUE,
#                widthConnectors = 0.5,
#                colConnectors = 'grey30',
#                typeConnectors = "open",
#                labSize = 4,
#                gridlines.major = TRUE,
#                gridlines.minor = FALSE,
#                border = 'partial',
#                borderWidth = 0.5,
#                borderColour = 'black')   

```



## Cell-cell receptor-ligand analysis {.tabset}

### Celltalker analysis
```{r celltalker}

# Create output directories
if(!dir.exists("output/figures/Cell_cell_interaction/celltalker")){
  dir.create("output/figures/Cell_cell_interaction/celltalker", 
             recursive = T)
}



# load library
library("celltalker")

# Ref dataset supplied with celltalker
head(ramilowski_pairs)
tail(ramilowski_pairs)

dim(ramilowski_pairs) #There are 2,557 unique ligand/receptor interactions in this dataset


###########################################################################
#Identification of differentially expressed ligands and receptors
###########################################################################

# Identify ligands and receptors in our dataset
ligs <- as.character(unique(ramilowski_pairs$ligand))
recs <- as.character(unique(ramilowski_pairs$receptor))

ligs.present <- rownames(seurat.combined)[rownames(seurat.combined) %in% ligs]
recs.present <- rownames(seurat.combined)[rownames(seurat.combined) %in% recs]

genes.to.use <- union(ligs.present,recs.present)
length(genes.to.use) # 760


# Use FindAllMarkers for deferentially expressed ligands and receptors between groups

# Set idents to clusters
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

ligand.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA", 
                                 features = genes.to.use,
                                 only.pos = TRUE)

nrow(ligand.markers) # 269 


# Filter by adjusted P.value 
ligand.markers <- ligand.markers[ligand.markers$p_val_adj < 0.05, ]

nrow(ligand.markers) # 254

# get vector of unique ligands/receptors
ligs.recs.use <- unique(ligand.markers$gene)
length(ligs.recs.use) # 111




# Filter ramilowski pairs
interactions.forward1 <- ramilowski_pairs[as.character(ramilowski_pairs$ligand) %in% ligs.recs.use, ]

interactions.forward2 <- ramilowski_pairs[as.character(ramilowski_pairs$receptor) %in% ligs.recs.use, ]

interact.for <- rbind(interactions.forward1, interactions.forward2)

dim(interact.for) # 494 ligand receptor interactions




# Create data for celltalker
DefaultAssay(seurat.combined) <- "RNA"

expr.mat <- GetAssayData(seurat.combined, 
                         slot = "counts")

# define clusters and groups(condition)
defined.clusters <- seurat.combined@meta.data$seurat_clusters
defined.groups <- seurat.combined@meta.data$condition


# Need to get a replicates vector 
defined.replicates <- seurat.combined@meta.data$group
defined.replicates <- gsub("S1", "US_1", defined.replicates)
defined.replicates <- gsub("S2", "US_2", defined.replicates)
defined.replicates <- gsub("S3", "Stim_1", defined.replicates)
defined.replicates <- gsub("S4", "Stim_2", defined.replicates)

# Needs to be a named vector
names(defined.clusters) <- rownames(seurat.combined@meta.data)
names(defined.groups) <- rownames(seurat.combined@meta.data)
names(defined.replicates) <- rownames(seurat.combined@meta.data)

# should be a factor vector
defined.clusters <- factor(defined.clusters, levels = c("Naïve_like_1_CM",
                                                        "Naïve_like_2_SC",
                                                        "Naïve_like_3",
                                                        "Cytotoxic",
                                                        "Type_I_IFN",
                                                        "Stimulated_1",
                                                        "Stimulated_exhausted",
                                                        "Exhausted_1",
                                                        "Exhausted_2",
                                                        "TRM",
                                                        "gd_T_g9d2",
                                                        "gd_T_non_g9d2",
                                                        "MAIT",
                                                        "Proliferative"))

defined.groups <- factor(defined.groups, levels = c("US",
                                                    "Stim"))

defined.replicates <- factor(defined.replicates, levels = c("US_1",
                                                            "US_2",
                                                            "Stim_1",
                                                            "Stim_2"))



reshaped.matrices <- reshape_matrices(count.matrix = expr.mat,
                                      clusters = defined.clusters,
                                      groups = defined.groups,
                                      replicates = defined.replicates,
                                      ligands.and.receptors = interact.for)


#Check out the hierarchy of the tibble
reshaped.matrices
reshaped.matrices$group
reshaped.matrices$samples

unnest(reshaped.matrices,
       cols = "samples")

names(pull(unnest(reshaped.matrices, cols = "samples"))[[1]])

# small bug in create_lig_rec_tib function, required small modification 
source("R/Modified_Celltalker_function.R")

consistent.lig.recs <- create_lig_rec_tib.mod(exp.tib = reshaped.matrices,
                                              clusters = defined.clusters,
                                              groups = defined.groups,
                                              replicates = defined.replicates,
                                              cells.reqd = 10,
                                              freq.pos.reqd = 0.5,
                                              ligands.and.receptors = interact.for)





consistent.lig.recs


unnest(consistent.lig.recs[1,2], 
       cols = "lig.rec.exp")

pull(unnest(consistent.lig.recs[1,2],
            cols = "lig.rec.exp")[1,2])[[1]]

# Determine putative ligand/receptor pairs
put.int <- putative_interactions(ligand.receptor.tibble = consistent.lig.recs,
                                 clusters = defined.clusters,
                                 groups = defined.groups,
                                 freq.group.in.cluster = 0.05,
                                 ligands.and.receptors = interact.for)

# Identify and visualise unique ligand/receptor pairs in a group

# Identify unique ligand/receptor interactions present in each sample
unique.ints <- unique_interactions(put.int,
                                   group1 = "US",
                                   group2 = "Stim",
                                   interact.for)

temp.df <- as.data.frame(unique.ints)

# Get data to plot circos unique to US
US.to.plot <- pull(unique.ints[1,2])[[1]]
for.circos.US <- pull(put.int[1,2])[[1]][US.to.plot]

circos_plot(interactions = for.circos.US,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray") 

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_US_clusters.pdf")
dev.off()




#Get data to plot circos unique to Stim
Stim.to.plot <- pull(unique.ints[2,2])[[1]]
for.circos.Stim <- pull(put.int[2,2])[[1]][Stim.to.plot]

circos_plot(interactions = for.circos.Stim,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_Stim_clusters.pdf")
dev.off()





# Get data to plot circos common 
Common.to.plot <- pull(unique.ints[3,2])[[1]]
for.circos.common <- pull(put.int[1,2])[[1]][Common.to.plot]

circos_plot(interactions = for.circos.common,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_Common_clusters.pdf")
dev.off()









##################################################
### repeat analysis for modules 
##################################################

# Set idents
Idents(seurat.combined) <- seurat.combined@meta.data$Module

ligand.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA", 
                                 features = genes.to.use,
                                 only.pos = TRUE)

nrow(ligand.markers) # 104 


# Filter by adjusted P.value 
ligand.markers <- ligand.markers[ligand.markers$p_val_adj < 0.05, ]

nrow(ligand.markers) # 91

# get vector of unique ligands/receptors
ligs.recs.use <- unique(ligand.markers$gene)
length(ligs.recs.use) # 76



# Filter ramilowski pairs
interactions.forward1 <- ramilowski_pairs[as.character(ramilowski_pairs$ligand) %in% ligs.recs.use,]
interactions.forward2 <- ramilowski_pairs[as.character(ramilowski_pairs$receptor) %in% ligs.recs.use,]
interact.for <- rbind(interactions.forward1, interactions.forward2)

dim(interact.for) # 373



# Create data for celltalker
DefaultAssay(seurat.combined) <- "RNA"

expr.mat <- GetAssayData(seurat.combined, 
                         slot = "counts")

# Groups and replicates are defined in code for celltalk on clusters 
# Just "clusters" needs to be redefined to modules

defined.clusters <- seurat.combined@meta.data$Module

# Needs to be a named vector
names(defined.clusters) <- rownames(seurat.combined@meta.data)

# should be a factor vector
defined.clusters <- factor(defined.clusters, levels = c("Naive_Stem",
                                                        "Activated",
                                                        "Exhaustion",
                                                        "Innate",
                                                        "Cycling"))

reshaped.matrices <- reshape_matrices(count.matrix = expr.mat,
                                      clusters = defined.clusters,
                                      groups = defined.groups,
                                      replicates = defined.replicates,
                                      ligands.and.receptors = interact.for)


# Check out the hierarchy of the tibble
reshaped.matrices

unnest(reshaped.matrices,
       cols = "samples")

names(pull(unnest(reshaped.matrices, cols = "samples"))[[1]])


consistent.lig.recs <- create_lig_rec_tib.mod(exp.tib = reshaped.matrices,
                                              clusters = defined.clusters,
                                              groups = defined.groups,
                                              replicates = defined.replicates,
                                              cells.reqd = 10,
                                              freq.pos.reqd = 0.5,
                                              ligands.and.receptors = interact.for)

consistent.lig.recs


unnest(consistent.lig.recs[1,2], 
       cols = "lig.rec.exp")

pull(unnest(consistent.lig.recs[1,2],
            cols = "lig.rec.exp")[1,2])[[1]]

# Determine putative ligand/receptor pairs
put.int <- putative_interactions(ligand.receptor.tibble = consistent.lig.recs,
                                 clusters = defined.clusters,
                                 groups = defined.groups,
                                 freq.group.in.cluster = 0.05,
                                 ligands.and.receptors = interact.for)

# Identify and visualise unique ligand/receptor pairs in a group

# Identify unique ligand/receptor interactions present in each sample
unique.ints <- unique_interactions(put.int,
                                   group1 = "US",
                                   group2 = "Stim",
                                   interact.for)


#temp.df <- as.data.frame(unique.ints)

# Get data to plot circos unique to US
US.to.plot <- pull(unique.ints[1,2])[[1]]
for.circos.US <- pull(put.int[1,2])[[1]][US.to.plot]

circos_plot(interactions = for.circos.US,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray") 

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_US_modules.pdf")
dev.off()


#Get data to plot circos unique to Stim
Stim.to.plot <- pull(unique.ints[2,2])[[1]]
for.circos.Stim <- pull(put.int[2,2])[[1]][Stim.to.plot]

circos_plot(interactions = for.circos.Stim,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_unique_Stim_modules.pdf")
dev.off()


# Get data to plot circos common 
Common.to.plot <- pull(unique.ints[3,2])[[1]]
for.circos.common <- pull(put.int[1,2])[[1]][Common.to.plot]

circos_plot(interactions = for.circos.common,
            clusters = defined.clusters, 
            ligand.col = "lightgreen", 
            receptor.col = "blue",
            interactions.col = "lightgray")

dev.copy(pdf, "output/figures/Cell_cell_interaction/celltalker/Celltalker_Common_modules.pdf")
dev.off()


```

### Cellphonedb
```{r Cellphonedb}

# Create output directories
if(!dir.exists("output/tables/cellphonedb")){
  dir.create("output/tables/cellphonedb", 
             recursive = T)
}

# Cellphonedb is a python program - can also be used via an online webportal

# Prepare and export data for cellphonedb analysis



save.data.frame.function <- function(df, title){
  
  x <- as.data.frame(as.matrix(df))
  
  write.table(x, 
              paste0("output/tables/cellphonedb/", title, ".txt"),
              sep = "\t",
              quote = FALSE)
}




# Export dataset of all cells (US and Stim)

Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

save.data.frame.function(seurat.combined@assays$RNA@data, "cellphonedb_both_conditions_normed")


# Metadata with cluster annotation
tmp.meta.data <- cbind(rownames(seurat.combined@meta.data),
                       seurat.combined@meta.data[ ,"seurat_clusters", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_both_conditions_clusters.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)

# Metadata with module annotation
tmp.meta.data <- cbind(rownames(seurat.combined@meta.data),
                       seurat.combined@meta.data[ ,"Module", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_both_conditions_modules.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)


# Export dataset of just US cells
Idents(seurat.combined) <- seurat.combined@meta.data$condition

temp.seurat <- subset(seurat.combined, idents = "US")

Idents(temp.seurat) <- temp.seurat@meta.data$seurat_clusters

save.data.frame.function(temp.seurat@assays$RNA@data, "cellphonedb_US_normed")

# Metadata with cluster annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"seurat_clusters", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_US_clusters.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)

# Metadata with Module annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"Module", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_US_modules.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)



# Export dataset of just Stim cells
Idents(seurat.combined) <- seurat.combined@meta.data$condition

temp.seurat <- subset(seurat.combined, idents = "Stim")

Idents(temp.seurat) <- temp.seurat@meta.data$seurat_clusters

save.data.frame.function(temp.seurat@assays$RNA@data, "cellphonedb_Stim_normed")

# Metadata with cluster annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"seurat_clusters", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_Stim_clusters.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)


# Metadata with Module annotations
tmp.meta.data <- cbind(rownames(temp.seurat@meta.data), temp.seurat@meta.data[ ,"Module", drop = F])

write.table(tmp.meta.data,
            "output/tables/cellphonedb/Metadata_Stim_modules.txt",
            sep="\t", 
            quote = FALSE, 
            row.names = FALSE)


rm(tmp.meta.data, temp.seurat)


```

### iTalk
```{r iTalk}

# Create output directories
if(!dir.exists("output/figures/Cell_cell_interaction/iTALK")){
  dir.create("output/figures/Cell_cell_interaction/iTALK", 
             recursive = T)
}


# Load library
library(iTALK)


#############################
# Run analysis for clusters
#############################

# Downsample dataset
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

seurat.combined.small <- subset(seurat.combined, downsample = 300)

iTalk.input <- as.data.frame(seurat.combined.small@assays$RNA@data)

# Append metadata
temp <- as.data.frame(seurat.combined.small@meta.data)
sum(rownames(temp) != colnames(iTalk.input))

iTalk.input <- t(iTalk.input)
iTalk.input <- as.data.frame(iTalk.input)

iTalk.input$cell_type <- temp$seurat_clusters


# find top 50 percent highly expressed genes
highly_exprs_genes <- rawParse(iTalk.input, top_genes = 50, stats = 'mean')

# find the ligand-receptor pairs from highly expressed genes
comm_list<-c('growth factor','other','cytokine','checkpoint')

cell_col <- structure(c('Red','Blue','Green','Purple', 'Orange', 'Grey','Black', "Yellow", "Darkred", "lightblue", "Pink", "burlywood", "Brown", "Darkgreen"), names = unique(iTalk.input$cell_type))


par(mfrow = c(1,2))
par(mfrow = c(1,1))

res <- NULL

for(comm_type in comm_list){
  res_cat <- FindLR(highly_exprs_genes, 
                    datatype = 'mean count', 
                    comm_type = comm_type)
  
  res_cat <- res_cat[order(res_cat$cell_from_mean_exprs*res_cat$cell_to_mean_exprs, 
                           decreasing = TRUE), ]
  
  #plot by ligand category
  
  #top 50 ligand-receptor pairs
  LRPlot(res_cat[1:50,],
         datatype = 'mean count', 
         cell_col = cell_col,
         link.arr.lwd = res_cat$cell_from_mean_exprs[1:50], 
         link.arr.width = res_cat$cell_to_mean_exprs[1:50])
  title(comm_type)
  
  dev.copy(pdf, paste0("output/figures/Cell_cell_interaction/iTALK/Ligand_receptor_plot_", comm_type, ".pdf"))
  dev.off()
  
  res <- rbind(res,res_cat)
}






# Archived code below to plot network 1 by 1 for each cell type

#for(i in 1:14){

# col.vec <- rep("#BEBEBE00", 14)
#col.vec[i] <- "Red"


#cell_col <- structure(col.vec, names = unique(iTalk.input$cell_type))

#NetView(res_cat, 
#        col = cell_col,
#        vertex.label.cex = 1,
#        label = FALSE,
#        arrow.width = 1, 
#        edge.max.width = 20)

#}


```


## GSEA analysis {.tabset}

### Scillus
```{r Scillus_GSEA}

#remotes::install_github("xmc811/Scillus")

# Scillus package would not compile
# I took the functions and made a new .R file
# Some of the functions called and used in this script required modifications to work outside of the package environment

library("Scillus")

#source("~/Documents/Work/Sciebo/Scripts/Packages/Scillus_package/Scillus_functions.R")
#load("~/Documents/Work/Sciebo/Scripts/Packages/Scillus_package/pathways.hallmark.rda")


# Create output directories
if(!dir.exists("output/figures/GO_analysis/Scillus_GO")){
  dir.create("output/figures/GO_analysis/Scillus_GO", 
             recursive = T)
}

######################
# Module analysis
######################

# set idents to Module
Idents(seurat.combined) <- seurat.combined@meta.data$Module


# get a broad list of DEG markers 
Module.markers <- FindAllMarkers(seurat.combined,
                                 assay = "RNA",
                                 only.pos = FALSE,
                                 min.diff.pct = 0.1,
                                 logfc.threshold = 0,
                                 return.thresh = 0.01)




# Threshold marker list by P value and fold change for GO analysis 

GO.markers <- Module.markers[Module.markers$p_val_adj < 0.05, ]
GO.markers <- GO.markers[abs(GO.markers$avg_logFC) > 0.25, ]
dim(Module.markers) #2,132 genes
dim(GO.markers) # 1,232 genes

table(GO.markers$cluster) # number of genes DEG per cluster // used to justify using topn = 100

# Plot Gene Ontology analysis
# CC, BP, MF

# To plot graph for a specific cluster use below code
#plot_cluster_go(Module.markers, cluster_name = "Activated", org = "human", ont = "MF")

# CC 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Modules_CC.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "CC")

dev.off()


# BP 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Modules_BP.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "BP")

dev.off()

# MF 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Modules_MF.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "MF")
dev.off()




# Perform GSEA 
gsea_res <- test_GSEA(Module.markers, 
                      pathway = pathways.hallmark)



plot_GSEA(gsea_res)
dev.copy(pdf, "output/figures/GO_analysis/Scillus_GO/GSEA_Module.pdf")
dev.off()


######################
# Cluster analysis
######################

# set idents to cluster
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# get a broad list of DEG markers 
Cluster.markers <- FindAllMarkers(seurat.combined,
                                  assay = "RNA",
                                  only.pos = FALSE,
                                  min.diff.pct = 0.1,
                                  logfc.threshold = 0,
                                  return.thresh = 0.01)




# Threshold marker list by P value and fold change for GO analysis 

GO.markers <- Cluster.markers[Cluster.markers$p_val_adj < 0.05, ]
GO.markers <- GO.markers[abs(GO.markers$avg_logFC) > 0.25, ]
dim(Cluster.markers) # 8,635 genes
dim(GO.markers) # 4,890 genes

table(GO.markers$cluster) # number of genes DEG per cluster // used to justify using topn = 100

# Plot Gene Ontology analysis
# CC, BP, MF

# To plot graph for a specific cluster use below code
#plot_cluster_go(Module.markers, cluster_name = "Activated", org = "human", ont = "MF")

# CC 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Clusters_CC.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "CC")

dev.off()


# BP 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Clusters_BP.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "BP")

dev.off()

# MF 
pdf("output/figures/GO_analysis/Scillus_GO/GO_Clusters_MF.pdf", width = 20, height = 20)

plot_all_cluster_go(GO.markers,
                    topn = 100,
                    org = "human", 
                    ont = "MF")
dev.off()




# Perform GSEA 
#gsea_res <- test_GSEA(Cluster.markers, 
#                      pathway = pathways.hallmark)


#plot_GSEA(gsea_res)
#dev.copy(pdf, "output/figures/GO_analysis/Scillus_GO/GSEA_Clusters.pdf")
#dev.off()


```





## Misc analysis {.tabset}

### Secretome // Unfinished chunk 
```{r Secretome}

# set working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output/figures/Secretome")){
  dir.create("output/figures/Secretome",
             recursive = T)}

output.dir <- "output/figures/Secretome"
setwd(output.dir)

# Read in data
chemo.cytokines <- read.csv(paste0(working.dir, "/Data/Secretome/ChemoCytokines.csv"))
receptors <- read.csv(paste0(working.dir, "/Data/Secretome/receptors.csv"))


# Set idents
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Identify which of the query genes are in the database
query.genes <- unique(c(chemo.cytokines$GeneID, receptors$GeneID))

logic.vec <- rownames(seurat.combined) %in% query.genes
genes.to.test <- rownames(seurat.combined)[logic.vec]


# Run DEG test on all genes in query set that can be found in database
Query.DEG <- FindAllMarkers(seurat.combined,
                            assay = "RNA",
                            features = genes.to.test,
                            only.pos = FALSE,
                            min.diff.pct = 0.1,
                            logfc.threshold = 0,
                            return.thresh = 0.01)


# Filter Query.DEG for sig and arrange by LogFC within groups for nicer plotting
genes.plot <- Query.DEG %>% 
  dplyr::filter(p_val_adj < 0.05) %>%
  dplyr::group_by(cluster) %>%
  dplyr::arrange(desc(avg_logFC), .by_group = TRUE) %>%
  dplyr::select(gene)

genes.plot <- unique(genes.plot$gene)


# Get average expression
average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)


# Plot all genes DEG from query list
DoHeatmap(average.seurat, 
          features = genes.plot, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "All_sig_genes.pdf")
dev.off()



# Plot just chemokine and cytokine genes
logic.vec <- genes.plot %in% receptors$GeneID
chemo.cytokine.genes <- genes.plot[!logic.vec]

DoHeatmap(average.seurat, 
          features = chemo.cytokine.genes, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Chemo_cytokine_genes.pdf")
dev.off()


# Plot just receptor genes
logic.vec <- genes.plot %in% receptors$GeneID
receptor.genes <- genes.plot[logic.vec]

DoHeatmap(average.seurat, 
          features = receptor.genes, 
          size = 4, 
          angle = 90, 
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Receptor_genes.pdf")
dev.off()


# Return to working dir
setwd(working.dir)

# remove unneeded variables
rm(receptor.genes, genes.plot, receptors, chemo.cytokine.genes, average.seurat, Query.DEG)
```
 

## Additional analysis {.tabset}

### Cell cycle analysis
```{r cell_cycle}

# Analyse if there is any enrichment for cell cycle stage

if(!dir.exists("output/figures/cell_cycle")){
  dir.create("output/figures/cell_cycle")
}

##################################
# Ensure idents is set up
##################################

Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters



################
# Read in data
################

exp.mat <- read.table(file = "Data/Cell_cycle_input_dataset/nestorawa_forcellcycle_expressionMatrix.txt", 
                      header = TRUE, 
                      as.is = TRUE, row.names = 1)

# A list of cell cycle markers, from Tirosh et al, 2015, is loaded with Seurat.
# We can segregate this list into markers of G2/M phase and markers of S phase

cc.genes$s.genes
cc.genes$g2m.genes

s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes


#######################
# Cell cycle analysis
#######################

seurat.combined <- CellCycleScoring(seurat.combined, 
                                    s.features = s.genes, 
                                    g2m.features = g2m.genes, 
                                    set.ident = FALSE)


head(seurat.combined@meta.data)


#######################
# Visualisation
#######################

UMAPPlot(seurat.combined, 
         group.by = "Phase",
         split.by = "condition",
         pt.size = 1)

dev.copy(pdf, "output/figures/cell_cycle/UMAP_CellCycle_Phase.pdf")
dev.off()


FeaturePlot(seurat.combined, 
            reduction = "umap",
            features = "S.Score",
            pt.size = 1.5, 
            label = TRUE, 
            label.size = 5,
            order = TRUE, 
            cols = c("lightgray", "orange", "red")) + NoLegend()

dev.copy(pdf, "output/figures/cell_cycle/FeaturePlot_S.pdf")
dev.off()

FeaturePlot(seurat.combined, 
            reduction = "umap",
            features = "G2M.Score",
            pt.size = 1.5, 
            label = TRUE, 
            label.size = 5,
            order = TRUE, 
            cols = c("lightgray", "orange", "red")) + NoLegend()

dev.copy(pdf, "output/figures/cell_cycle/FeaturePlot_G2M.pdf")
dev.off()

#######################
# Vln plots
#######################

VlnPlot(seurat.combined, 
        features = "S.Score")

dev.copy(pdf, "output/figures/cell_cycle/VlnPlot_Sscore.pdf")
dev.off()


VlnPlot(seurat.combined,
        features = "G2M.Score")

dev.copy(pdf, "output/figures/cell_cycle/VlnPlot_G2Mscore.pdf")
dev.off()

#######################
# Ridge plots
#######################

RidgePlot(seurat.combined, 
          features = c("S.Score", "G2M.Score"), 
          log = TRUE)

dev.copy(pdf, "output/figures/cell_cycle/RidgePlot_S_and_G2Mscore.pdf")
dev.off()


table(seurat.combined@meta.data$Phase)


```

### CytoTRACE
```{r cytoTRACE_analysis}

#####################
# Install package
#####################

#BiocManager::install("sva")

# change with path to your local download of CytoTRACE.tar.gz file
#devtools::install_local("~/Documents/Work/Sciebo/Scripts/Packages/CytoTRACE_0.3.3.tar.gz")

# run in terminal 
# pip install scanoramaCT
# pip install numpy

# Example dataset
#data.file <- read.delim("CytoTRACE_Analysis/Example_datasets/Bone_marrow_10x_matrix.txt")
#data.pheno <- read.delim("CytoTRACE_Analysis/Example_datasets/Bone_marrow_10x_metadata.txt")


##############################
# Create output directories
##############################

if(!dir.exists("output/figures/CytoTRACE")){
  dir.create("output/figures/CytoTRACE", 
             recursive = T)}

##############
# Load library
##############

library("CytoTRACE")


# Prepare data

# Expression matrix (Raw data)
data.file <- as.data.frame(seurat.combined@assays$RNA@counts)
head(data.file[1:10, 1:10])

# Metadata file
data.pheno <- as.data.frame(seurat.combined@meta.data)
head(data.pheno)

# Run cytoTRACE
Trace.object <- CytoTRACE(data.file,
                          enableFast = TRUE,
                          ncores = 6, 
                          subsamplesize = 1000)


# Create phenotype label vector
pheno.labels <- as.character(data.pheno$seurat_clusters)
names(pheno.labels) <- rownames(data.pheno)


# Plot data
plotCytoTRACE(Trace.object,
              emb = data.pheno[ , c("UMAP_1", "UMAP_2")],
              phenotype = pheno.labels,
              outputDir = paste0(working.dir, "/output/figures/CytoTRACE/"))



plotCytoGenes(Trace.object, 
              numOfGenes = 50,
              outputDir = paste0(working.dir, "/output/figures/CytoTRACE/"))




# Remove variables to save space and prevent errors
rm(data.file, data.pheno, Trace.object, pheno.labels)


```

 
## Misc analysis {.tabset}

### Analysis with Augur 
```{r Augur_Analysis, echo = TRUE, eval = FALSE}

if(long.compute){
  
  # Install packages required
  
  #devtools::install_github("const-ae/sparseMatrixStats")
  #devtools::install_github("neurorestore/Augur")
  #install.packages("glmnet")
  
  
  ####################################  
  # Run Augur analysis on clusters
  ####################################  
  
  # Metadata info 
  metadata.df <- seurat.combined@meta.data
  
  # see which cols to keep
  colnames(metadata.df)
  
  # Select just cluster and condition cols 
  metadata.df <- metadata.df %>%
    dplyr::select(seurat_clusters, condition)
  
  # Name cols for input into augur function
  colnames(metadata.df) <- c("cell_type", "label")
  
  # output expression dataset
  normed.df <- seurat.combined@assays$RNA@data
  
  # Run Augur analysis // ~45 min compute time
  augur.out <- Augur::calculate_auc(normed.df,
                                    metadata.df, 
                                    n_threads = 8)
  
  # Output is stored in AUC slot 
  augur.out$AUC
  
  # Save RDS file
  saveRDS(augur.out, "Exported_RDS_files/Augur_output_clusters.rds")
  rm(augur.out)
  
  
  
  ###################################
  # Run Augur analysis on modules
  ###################################
  
  # Metadata info 
  metadata.df <- seurat.combined@meta.data
  
  # see which cols to keep
  colnames(metadata.df)
  
  # Select just cluster and condition cols 
  metadata.df <- metadata.df %>%
    dplyr::select(Module, condition)
  
  # Name cols for input into augur function
  colnames(metadata.df) <- c("cell_type", "label")
  
  
  # output expression dataset
  normed.df <- seurat.combined@assays$RNA@data
  
  # Run Augur analysis // ~10 min compute time
  augur.out <- Augur::calculate_auc(normed.df,
                                    metadata.df, 
                                    n_threads = 8)
  
  # Output is stored in AUC slot 
  augur.out$AUC
  
  # Save RDS file
  saveRDS(augur.out, "Exported_RDS_files/Augur_output_module.rds")
  rm(augur.out)
  
}

```


 
 
 
 
 ### TO DO ###########
 # scclusteval - to determine stability of identified clusters
 # VDJdb epitope prediction for clonotypes
 # group clonotypes by Gliph cluster 
 # Vis/analyse epitope and Gliph cluster data
 # Complex and richness of gliph clusters
 # SENIC analysis of Transcription factor regulon activity in clusters
 # Data-mining for Type I IFN clusters in HNSCC and other cancer datasets
 # Transcription factor analysis - both expression and downstream gene regulation analysis
 

 
 
 
 
## Transcription factor analysis {.tabset}

### Progeny Analysis
```{r Progeny_analysis}

#BiocManager::install("progeny")


library(progeny)
library(dplyr)
library(Seurat)
library(ggplot2)
library(tidyr)
library(readr)
library(pheatmap)
library(tibble)




## We compute the Progeny activity scores and add them to our Seurat object
## as a new assay called Progeny. 

DefaultAssay(seurat.combined) <- "RNA"
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


seurat.combined <- progeny(seurat.combined, 
                           scale = FALSE, 
                           organism = "Human", 
                           top = 500,
                           perm = 1,
                           return_assay = TRUE)


## We can now directly apply Seurat functions in our Progeny scores. 
## For instance, we scale the pathway activity scores. 
seurat.combined <- Seurat::ScaleData(seurat.combined, assay = "progeny")

## We transform Progeny scores into a data frame to better handling the results
progeny_scores_df <-
    as.data.frame(t(GetAssayData(seurat.combined, slot = "scale.data",
        assay = "progeny"))) %>%
    rownames_to_column("Cell") %>%
    gather(Pathway, Activity, -Cell)


## We create a data frame with the specification of the cells that belong to 
## each cluster to match with the Progeny scores.
CellsClusters <- data.frame(Cell = names(Idents(seurat.combined)),
                            CellType = as.character(Idents(seurat.combined)),
                            stringsAsFactors = FALSE)




## We match Progeny scores with the cell clusters.
progeny_scores_df <- inner_join(progeny_scores_df, CellsClusters)

## We summarize the Progeny scores by cellpopulation
summarized_progeny_scores <- progeny_scores_df %>%
  group_by(Pathway, CellType) %>%
  summarise(avg = mean(Activity), std = sd(Activity))


## We prepare the data for the plot
summarized_progeny_scores_df <- summarized_progeny_scores %>%
  dplyr::select(-std) %>%
  spread(Pathway, avg) %>%
  data.frame(row.names = 1, check.names = FALSE, stringsAsFactors = FALSE)

paletteLength = 100
myColor = colorRampPalette(c("Darkblue", "white","red"))(paletteLength)

progenyBreaks = c(seq(min(summarized_progeny_scores_df), 0,
                      length.out=ceiling(paletteLength/2) + 1),
                  seq(max(summarized_progeny_scores_df)/paletteLength,
                      max(summarized_progeny_scores_df),
                      length.out=floor(paletteLength/2)))


progeny_hmap = pheatmap(t(summarized_progeny_scores_df[,-1]),fontsize=14,
                        fontsize_row = 10,
                        color=myColor, breaks = progenyBreaks,
                        main = "PROGENy (500)", angle_col = 45,
                        treeheight_col = 0,  border_color = NA)


unique(progeny_scores_df$Pathway)

DefaultAssay(seurat.combined) <- "RNA"

```
 
### Exporting metadata for velocity analysis
```{r exporting_metadata}
# export metadata for velocity analysis 
meta.data <- seurat.combined@meta.data

colnames(meta.data)
head(meta.data)

# Remove non-necessary columns 
meta.data <- meta.data %>%
  dplyr::select(group, condition, seurat_clusters, UMAP_1, UMAP_2, PCA_1, PCA_2, Module, condition_clust, condition_module)

# Create new barcode columns 
meta.data$uniq_barcode <- rownames(meta.data)

meta.data$barcode <- gsub(".*_", "", rownames(meta.data))

write.table(meta.data, "output/tables/Meta_data.txt", sep = "\t", row.names = F, quote = F)



```





### RcisTarget
```{r TF_regulation}

# Create output directory 
if(!dir.exists("output/figures/RcisTarget")){
  dir.create("output/figures/RcisTarget",
             recursive = TRUE)}

if(!dir.exists("output/tables/RcisTarget")){
  dir.create("output/tables/RcisTarget",
             recursive = TRUE)}


# load library
library("RcisTarget")

# To support paralell execution:
#BiocManager::install(c("doMC", "doRNG"))

# Visualisations may require 
#BiocManager::install(c("DT", "visNetwork"))



###################################
# Generate input gene lists 
###################################

# Liver ILC1 vs. NK 
ILC1.up <- combined.df %>%
  dplyr::filter(FDR_Liver_ILC1_vs_NK < 0.05 & logFC_Liver_ILC1_vs_NK > 0) %>%
  rownames()

ILC1.dn <- combined.df %>%
  dplyr::filter(FDR_Liver_ILC1_vs_NK < 0.05 & logFC_Liver_ILC1_vs_NK < 0) %>%
  rownames()

# Spleen CD160Pos vs CD160Neg
SpPos.up <- combined.df %>%
  dplyr::filter(FDR_Spleen_Pos_vs_Neg < 0.05 & logFC_Spleen_Pos_vs_Neg > 0) %>%
  rownames()

SpPos.dn <- combined.df %>%
  dplyr::filter(FDR_Spleen_Pos_vs_Neg < 0.05 & logFC_Spleen_Pos_vs_Neg < 0) %>%
  rownames()

# BM CD160Pos vs CD160Neg
BMPos.up <- combined.df %>%
  dplyr::filter(FDR_BM_Pos_vs_Neg < 0.05 & logFC_BM_Pos_vs_Neg > 0) %>%
  rownames()

BMPos.dn <- combined.df %>%
  dplyr::filter(FDR_BM_Pos_vs_Neg < 0.05 & logFC_BM_Pos_vs_Neg < 0) %>%
  rownames()



geneLists <- list(Liver_ILC1up = ILC1.up, 
                  Liver_ILC1dn = ILC1.dn, 
                  Spleen_Posup = SpPos.up, 
                  Spleen_Posdn = SpPos.dn, 
                  BM_Posup = BMPos.up, 
                  BM_Posdn = BMPos.dn)



# Available motif databased - in order of narrow -> large search space
# available datasets can be found at = https://resources.aertslab.org/cistarget/

# mm9-500bp-upstream-7species.mc9nr.feather
# mm9-tss-centered-5kb-7species.mc9nr.feather
# mm9-tss-centered-10kb-7species.mc9nr.feather

# Download database
#featherURL <- "https://resources.aertslab.org/cistarget/databases/mus_musculus/mm9/refseq_r45/mc9nr/gene_based/mm9-tss-centered-10kb-7species.mc9nr.feather" 

#download.file(featherURL, destfile=basename(featherURL)) # saved in current dir


# Read in database
motifRankings <- importRankings("RcisTarget_feather_files/mm9-tss-centered-10kb-7species.mc9nr.feather")

# Load mouse motif annotations
data(motifAnnotations_mgi)

#motifAnnotations_mgi[199:202,]

motifAnnotations_mgi[(TF %in% c("Zfp683")), ]

TF.vec <- unique(motifAnnotations_mgi$TF)


# perform analysis
motifEnrichmentTable_wGenes <- cisTarget(geneLists, 
                                         motifRankings,
                                         motifAnnot = motifAnnotations_mgi, 
                                         highlightTFs = c("Eomes", "Tbx21", "Zfp683", "Batf3"),
                                         nCores = 4)

# Using 4 cores.
# Genes in the gene sets NOT available in the dataset: #
#	Liver_ILC1up: 	36 (3% of 1359)
#	Liver_ILC1dn: 	73 (5% of 1362)
#	Spleen_Posup: 	30 (3% of 1194)
#	Spleen_Posdn: 	32 (3% of 1053)
#	BM_Posup: 	6 (1% of 420)
#	BM_Posdn: 	11 (3% of 412)


# Add motif logo to table
motifEnrichmentTable_wGenes_wLogo <- addLogo(motifEnrichmentTable_wGenes)


 
# to view output data 
resultsSubset <- motifEnrichmentTable_wGenes_wLogo[1:50,]

library(DT)
datatable(resultsSubset[,-c("enrichedGenes", "TF_lowConf"), with=FALSE], 
          escape = FALSE, # To show the logo
          filter="top", options=list(pageLength=10))



# Write data to file 
write.csv(motifEnrichmentTable_wGenes_wLogo, "output/tables/RcisTarget/motif_enrichment_table_withLogo_10kb.csv")


# Extract all high confidence transcription factors for each geneset
anotatedTfs <- lapply(split(motifEnrichmentTable_wGenes$TF_highConf,
                            motifEnrichmentTable_wGenes$geneSet),
                      function(x) {
                        genes <- gsub(" \\(.*\\). ", "; ", x, fixed=FALSE)
                        genesSplit <- unique(unlist(strsplit(genes, "; ")))
                        return(genesSplit)
                        })
                      

fix.list.length <- function(input.list){
  temp <- unlist(lapply(input.list, length))
  x.max <- max(temp)
  
  output.list <- lapply(input.list, function(x){
    
    remain <- x.max - length(x)
    return(paste0(c(x, rep(NA, remain))))
  })
  
  return(output.list)
}

anotatedTfs.export <- fix.list.length(anotatedTfs)  

# Write data to file 
write.csv(anotatedTfs.export, "output/tables/RcisTarget/Transcription_factors_annotated_to_motifs_with_highConf.csv")
rm(anotatedTfs.export)


# Filter predicted TFs based on those that are also significantly DEGs

index.vec <- names(geneLists)
DEG.predicted.TFs <- list()

for(i in 1:length(index.vec)){
  
  DEG.var <- geneLists[[paste0(index.vec[i])]]
  TF.var <- anotatedTfs[[paste0(index.vec[i])]]
  DEG.predicted.TFs[[paste0(index.vec[i])]]<- DEG.var[DEG.var %in% TF.var]
  names(DEG.predicted.TFs)[i] <- paste0(index.vec[i])
  print(DEG.predicted.TFs)
}




DEG.predicted.TFs.export <- fix.list.length(DEG.predicted.TFs)  

# Write data to file 
write.csv(DEG.predicted.TFs.export, "output/tables/RcisTarget/Transcription_factors_predicted_which_are_also_DEG.csv")
rm(DEG.predicted.TFs.export)






# Plot heatmaps of DEG predicted TFs

for(i in 1:length(index.vec)){
heatmap.data <- remove.stats(combined.df)

sig.var <- DEG.predicted.TFs[[paste0(index.vec[i])]]

logic.vec <- rownames(heatmap.data) %in% sig.var
heatmap.data <- heatmap.data[logic.vec, ]

heatmap.data <- heatmap.data[order(match(rownames(heatmap.data), sig.var)), ]

#heatmap.data <- remove.sample(heatmap.data, "^BM.*")


print(basic.heatmap(heatmap.data, 
              title.var = paste0(index.vec[i]), 
              Row.cluster = TRUE, 
              Col.cluster = TRUE,
              row.size = 0.7,
              dist.method = "euclidean",
              hclust.method = "ward.D2"))

dev.copy(pdf, paste0("output/figures/RcisTarget/Heatmap_predicted_TFs_dif_expressed_", index.vec[i], ".pdf"))
dev.off()

}

```
 
 
### Searching for TFs
```{r TF_analysis}

# Create output dir
if(!dir.exists("output/figures/Transcription_factors")){
  dir.create("output/figures/Transcription_factors", 
             recursive = T)}


# Searching for TFs
TF.ref.list <- read.delim("Data/TFcheckpoint.txt") # http://www.tfcheckpoint.org/index.php/browse

dim(TF.ref.list) # 1020, 11
colnames(TF.ref.list)
head(TF.ref.list)

Cluster.markers <- read.csv("output/tables/DEG_Clusters/Cluster_markers_unfiltered.csv", row.names = 1)



# Up-regulated TFs
sig.genes <- Cluster.markers %>%
  dplyr::filter(p_val_adj < 0.05) %>%
  dplyr::filter(avg_logFC > 0.5 | avg_logFC < -0.5) %>%
  dplyr::select(gene)

sig.genes <- unique(sig.genes$gene)
TF.logic <- sig.genes %in% TF.ref.list$Gene_symbol

TF.DEG <- sig.genes[TF.logic]




########################################
# Plot TFs differentially regulated 
########################################


seurat.combined.small <- subset(seurat.combined, downsample = 300)

average.seurat <- AverageExpression(seurat.combined,
                                    assay = "RNA",
                                    slot = "data",
                                    verbose = TRUE,
                                    return.seurat = TRUE)

DoHeatmap(average.seurat, 
          features = TF.DEG, 
          draw.lines = F)





```
 
 
 
 
## SCENIC TF analysis {.tabset}

### SCENIC transcription factor analysis 

```{r SCENIC_analysis}

# SCENIC analysis performed using python script as this is considerably faster then R based analysis

# Analysis performed as outlined in Sande et al., 2020 Nature Protocols manuscript

# Input into SCENIC analysis is a .loom file 

# Export seurat object as Loom file

# Generate loom file for SCENIC analysis 

#devtools::install_github(repo = "hhoeflin/hdf5r", force = TRUE)
#devtools::install_github(repo = "mojaveazure/loomR", ref = "develop")

library(loomR)

library(SCENIC)
library(SCopeLoomR)

pyScenicLoomFile <- file.path("../Additional_Analysis/Velocity_loom/GEX1_20200121_BaldNextSeq_CountsOnly.loom")
loom <- open_loom(pyScenicLoomFile, mode="r")




Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

DefaultAssay(seurat.combined) <- "RNA"


as.loom(seurat.combined, 
        assay = "RNA",
        filename = "seurat_combined.loom",
        overwrite = FALSE,
        verbose = TRUE)

dim(seurat.combined@assays$RNA)


lfile <- connect(filename = "seurat_combined.loom", mode = "r+")

lfile[["matrix"]]

lfile$close_all()




```


## Trajectory analysis {.tabset}




## Need to amend root node settings etc 

### Preparing data for trajectory analysis
```{r Trajectory_data_prep, eval = TRUE}

library(dyno)
library(dynplot)
library(dynmethods)
library(dynutils)
library(dynwrap)
library(tidyverse)
dynwrap::test_docker_installation(detailed = TRUE)

############################
# Read in and prepare data
############################

# Read in dataframes
raw.data <- as.data.frame(seurat.combined@assays$RNA@counts)
normed.data <- as.data.frame(seurat.combined@assays$RNA@data)


# data is organized cols = cells and rows = genes
head(raw.data[1:10, 1:10])
head(normed.data[1:10, 1:10])

# Need to inverse data for input into dyno package
raw.data <- t(raw.data)
head(raw.data[1:10, 1:10])

normed.data <- t(normed.data)
head(normed.data[1:10, 1:10])

# Check data structure
dim(raw.data) # 11,658 cells and 16,295 genes
dim(normed.data) # 11,658 cells and 16,295 genes


if(long.compute){  
  ##########################################
  # Creating Dyno formatted data structure
  ##########################################
  
  Dyno.data <- wrap_expression(counts = raw.data,
                               expression = normed.data)
  
  # Add grouping info
  metadata.df <- seurat.combined@meta.data
  
  group.vect <- metadata.df$seurat_clusters
  names(group.vect) <- rownames(metadata.df)
  
  Dyno.data <- add_grouping(Dyno.data,
                            grouping = group.vect)
  
  
  # Add dim reduction
  logic.vect <- grepl("*UMAP", colnames(metadata.df))
  
  UMAP.dims <- metadata.df[ , logic.vect]
  UMAP.dims <- as.matrix(UMAP.dims)
  
  Dyno.data <- add_dimred(Dyno.data,
                          dimred = UMAP.dims)
  
  
  
}else{
  
  
  
  # Create vectors and matrix needed for visualisation of pre-calculated trajectories
  
  # Create grouping vector
  metadata.df <- seurat.combined@meta.data
  
  group.vect <- metadata.df$seurat_clusters
  names(group.vect) <- rownames(metadata.df)
  
  # Create dim reduction matrix
  logic.vect <- grepl("*UMAP", colnames(metadata.df))
  
  UMAP.dims <- metadata.df[ , logic.vect]
  UMAP.dims <- as.matrix(UMAP.dims)
  
  
}




```

### Running trajectory analysis
```{r trajectory_analysis, eval = FALSE}

if(long.compute){
  
  
  
  ################################################
  # selecting best trajectory method for dataset
  ################################################
  # Using shiny app to get guidelines
  # guidelines <- guidelines_shiny(Dyno.total.data)
  
  
  answers <- dynguidelines::answer_questions(multiple_disconnected = NULL, 
                                             expect_topology = NULL, 
                                             expected_topology = NULL, 
                                             n_cells = 11658, 
                                             n_features = 18295, 
                                             memory = "16GB", 
                                             prior_information = NULL, 
                                             docker = TRUE)
  
  guidelines.vals <- dynguidelines::guidelines(answers = answers) 
  
  methods.selected <- guidelines.vals$methods_selected
  
  print(methods.selected)
  
  
  #####################
  # Infer Trajectory
  #####################
  
  ##############
  # Slingshot
  ##############
  
  slingshot <- infer_trajectory(Dyno.data, 
                                method = "dynverse/ti_slingshot:v0.9.9.01", 
                                parameters = NULL, 
                                give_priors = NULL, 
                                seed = set.seed(42),
                                verbose = TRUE)
  
  saveRDS(slingshot, file = "Exported_RDS_files/combined_slingshot.rds")
  rm(slingshot)
  
  
  ##############
  # Scorpius
  ##############
  
  scorpius <- infer_trajectory(Dyno.data, 
                               method = ti_scorpius(), 
                               parameters = NULL, 
                               give_priors = NULL, 
                               seed = set.seed(42),
                               verbose = TRUE)
  
  saveRDS(scorpius, file = "Exported_RDS_files/combined_scorpius.rds")
  rm(scorpius)
  
  
  ##############
  # Angle
  ##############
  
  angle <- infer_trajectory(Dyno.data, 
                            method = ti_angle(), 
                            parameters = NULL, 
                            give_priors = NULL, 
                            seed = set.seed(42),
                            verbose = TRUE)
  
  saveRDS(angle, file = "Exported_RDS_files/combined_angle.rds")
  rm(angle)
  
}


```

### Visualisation trajectory analysis
```{r Visualisation_trajectory, eval = TRUE}

####################################
# Visualise exported trajectories 
####################################


# Create output directory
if(!dir.exists("output/figures/Trajectories")){
  dir.create("output/figures/Trajectories",
             recursive = T)}



###############
# Slingshot
###############

# Create output directory
if(!dir.exists("output/figures/Trajectories/Slingshot")){
  dir.create("output/figures/Trajectories/Slingshot",
             recursive = T)}


# Read data
slingshot <- readRDS("Exported_RDS_files/combined_slingshot.rds")

# Modify variables

# Set root milestone
slingshot <- add_root(trajectory = slingshot, 
                        root_milestone_id = "1")

dynplot::plot_dimred(slingshot, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     label_milestones = TRUE,
                     color_cells = "pseudotime")

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_plot_pseudotime.pdf")
dev.off()


dynplot::plot_dimred(slingshot, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     grouping = group.vect,
                     label_milestones = TRUE,
                     color_cells = "grouping")

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_plot_clusters.pdf")
dev.off()


# Rename milestone labels
#milestone.labels <- c("Naive_memory", "Exhausted", "Activated", "Stem-like")
#names(milestone.labels) <- c(1, 2, 3, 4)

#slingshot <- label_milestones(slingshot, 
#                                 labelling = milestone.labels)

dynplot::plot_dimred(slingshot, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     grouping = group.vect,
                     label_milestones = TRUE,
                     color_cells = "grouping")


# Cacluate trajectory feature importance

overall_feature_importances <- dynfeature::calculate_overall_feature_importance(slingshot, 
                                                                                expression_source = normed.data)

top.features <- overall_feature_importances %>% 
  top_n(50, importance) %>% 
  pull(feature_id)


plot_heatmap(slingshot, 
             expression_source = normed.data, 
             features_oi = top.features)

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_heatmap_top50_important_features.pdf")
dev.off()


# Calculate milestone importance
for(i in 1:length(slingshot$milestone_ids)){
  
  # Because milestone ids are not in order get the corresponding ID name for each milestone #
  logic.var <- names(slingshot$milestone_labelling) == i
  milestone.name <- paste0(slingshot$milestone_labelling[logic.var])
  
  
  milestone.feature.importance <- calculate_milestone_feature_importance(slingshot,
                                                                         expression_source = normed.data, 
                                                                         milestones_oi = i, 
                                                                         verbose = TRUE)
  
  
  top.features <- milestone.feature.importance %>% 
    top_n(25, importance) %>% 
    pull(feature_id)
  
  print(plot_heatmap(slingshot, 
                     expression_source = normed.data, 
                     features_oi = top.features))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Slingshot/Combined_heatmap_top25_milestone_", milestone.name, "_important_features.pdf"))
  dev.off()
  
  
}



################################################
# Base plots of other trajectories calculated
################################################


# Generate list of exported trajectories 
trajectories_master <- list.files("Exported_RDS_files/", ".rds")

print(trajectories_master)

for(i in 1:length(trajectories_master)){
  
  print(paste0("Plotting ", trajectories_master[i]))
  
  trajectory.val <- readRDS(paste0("Exported_RDS_files/", trajectories_master[i]))
  trajectory.name <- gsub(".rds", "", trajectories_master[i])
  
  
  #####################
  # Plot trajectory
  #####################
  
  # Vis pseudotime
  print(dynplot::plot_dimred(trajectory.val, 
                             dimred = UMAP.dims,
                             hex_cells = TRUE, 
                             label_milestones = TRUE,
                             color_cells = "pseudotime"))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Pseudotime_", trajectory.name, ".pdf"))
  dev.off()
  
  # Overlay clusters
  print(dynplot::plot_dimred(trajectory.val, 
                             dimred = UMAP.dims,
                             hex_cells = TRUE, 
                             grouping = group.vect,
                             label_milestones = TRUE,
                             color_cells = "grouping"))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Clusters_", trajectory.name, ".pdf"))
  dev.off()
  
  # Group clusters
  print(dynplot::plot_dimred(trajectory.val, 
                             color_cells = "grouping",
                             color_density = "grouping",
                             dimred = UMAP.dims,
                             hex_cells = TRUE,
                             grouping = group.vect))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Clusters_grouped_", trajectory.name, ".pdf"))
  dev.off()
  
}


rm(trajectory.val)




```





### Monocle trajectory
```{r Monocle_analysis}

library("monocle")


DefaultAssay(seurat.combined) <- "integrated"
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

unique(Idents(seurat.combined))


cds <- SeuratWrappers::as.cell_data_set(seurat.combined, group.by = "seurat_clusters")

cds <- monocle3::cluster_cells(cds, reduction_method = "UMAP")

p1 <- monocle3::plot_cells(cds, show_trajectory_graph = FALSE)
p2 <- monocle3::plot_cells(cds, color_cells_by = "partition", show_trajectory_graph = FALSE)

p1|p2

cds <- monocle3::learn_graph(cds)


monocle3::plot_cells(cds, label_groups_by_cluster = FALSE, label_leaves = FALSE, label_branch_points = FALSE)


monocle3::plot_cells(cds, label_groups_by_cluster = F, label_leaves = T, label_branch_points = T)


cds <- monocle3::order_cells(cds)


monocle3::plot_cells(cds, color_cells_by = "pseudotime", label_cell_groups = FALSE, label_leaves = FALSE, 
    label_branch_points = FALSE)

?find_gene_modules

gene_module_df <- monocle3::find_gene_modules(cds, resolution = 1e-2)

unique(gene_module_df$module)

goi <- gene_module_df %>% 
  filter(module %in% c(7)) %>%
  dplyr::select(id)




monocle3::plot_cells(cds, 
           genes= goi$id,
           group_cells_by="partition",
           color_cells_by="partition",
           show_trajectory_graph=FALSE)

monocle3::plot_cells(cds,
           color_cells_by = "cluster",
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE)



AFD_genes <- c("ICOS", "PDCD1", "IFNG")
AFD_lineage_cds <- cds[rowData(cds) %in% AFD_genes, ]

my_genes <- row.names(subset(fData(cds), gene_short_name %in% goi$id)) 
cds_subset <- HSMM[my_genes,]

monocle3::plot_genes_in_pseudotime(cds,
                         color_cells_by="cluster",
                         label_by_short_name = F,
                         min_expr=0.5)

?plot_genes_in_pseudotime

ciliated_cds_pr_test_res <- monocle3::graph_test(cds, neighbor_graph="principal_graph", cores=4)
pr_deg_ids <- row.names(subset(ciliated_cds_pr_test_res, q_value < 0.05))




```
 
 

## Analysis optimisation code {.tabset}

### Optimise UMAP
```{r Optimise_UMAP_vis, eval = FALSE}

source("R/scRNAseq_Functions.R")

if(long.compute){
  
  # determine best min distance & neighbour val for UMAP
  
  # Set assay 
  DefaultAssay(seurat.combined) <- "integrated"
  
  # Set Idents
  Idents(seurat.combined) <- seurat.combined@meta.data$Module
  
  UMAP.optimise(seurat.combined)
}

# Default of n.neighbor = 30 and min.dist = 0.3 work well

```

### Altering the cluster calling resolution
```{r Differing_clust_resolution, eval = FALSE, echo = FALSE}

if(long.compute){
  
  # Set assay 
  DefaultAssay(seurat.combined) <- "RNA"
  
  clust.res.optimise(seurat.combined)
  
}

```






## Script info {.tabset}

### Run time
```{r code_runtime, eval = TRUE}

# calculate compute time for compiling code so far
compute.time <- Sys.time()
print(compute.time-start.time)


```

## Code archive {.tabset}

### ProjecTILs 
```{r ProjecTILs, eval = FALSE}

# Use ProjecTILs package from Carmona Lab to map TILS to mouse T cell atlas 

# Create output directory
if(!dir.exists("output/figures/ProjecTILs")){
  dir.create("output/figures/ProjecTILs",
             recursive = T)}

# Load package as install failed. Killed: 9 error
devtools::load_all("~/Documents/Work/Sciebo/Scripts/Packages/ProjecTILs-master-devbranch/")

#library(Seurat)
library(ProjecTILs)
library(gridExtra)

# load reference map 
ref <- load.reference.map()

# project dataset onto mouse Atlas
query.projected <- make.projection(seurat.combined, 
                                   query.assay = "RNA", 
                                   filter.cells = FALSE,
                                   ref = ref,
                                   human.ortho = TRUE)

# plot projection on mouse Atlas
plot.projection(ref, query.projected)

# predict cell state
query.projected <- cellstate.predict(ref = ref,
                                     query = query.projected)

# Evaluate cluster call 
table(query.projected$functional.cluster, query.projected$seurat_clusters)

# Sanity check for rough overlay of UMAP dims 
temp.names <- rownames(query.projected@reductions$umap@cell.embeddings)
temp.names <- gsub("Q_", "", temp.names)
sum(temp.names != rownames(seurat.combined@reductions$umap@cell.embeddings))

# Change umap dims to original projection 
query.projected@reductions$umap@cell.embeddings <- seurat.combined@reductions$umap@cell.embeddings
rownames(query.projected@reductions$umap@cell.embeddings) <- paste0("Q_", rownames(query.projected@reductions$umap@cell.embeddings))



# show were cells sit by highlighting a single cell annotation each time 

# Loop over all clusters 

for(i in 1:9){
  
# set up col vector
temp.cols <- rep("Grey", 9)

# Set 1 cluster to be highlighted 
temp.cols[i] <- "Blue"


print(DimPlot(query.projected,
        reduction = "umap", 
        group.by = "functional.cluster", 
        pt.size = 1, 
        cols = temp.cols,
        label = FALSE))

dev.copy(pdf, paste0("output/figures/ProjecTILs/MouseAtlas_projection_cluster_", i, ".pdf"))
dev.off()
  
  
}


```


