---
title: "HNSCC_scTCRseq_analysis"
author: "Dillon Corvino & Nick Borcherding"
date: "03/02/2020"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: united
    highlight: tango
    df_print: paged
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

Built with R version `r getRversion()`

## Setup {.tabset}

### Environment
```{r Environment_setup, message = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,  
  eval = TRUE, 
  tidy = TRUE
)

# Environment Set up
rm(list = ls()) #Clean workspace
cat("\014")     #Clean Console
gc() # Free memory


# Establish working directory
library("rstudioapi")

# Set working directory to source file location
setwd(dirname(getActiveDocumentContext()$path))
setwd("..")

# Load packages
source("R/Load_packages.R", local = knitr::knit_global())

# Create output directories & load custom functions & colour scheme
source("R/Setup.R", local = knitr::knit_global())

# pipeline variables
quick.load <- TRUE
long.compute <- FALSE
do.plot <- TRUE

# load saved seurat object with cluster annotations and imputation performed
if(quick.load){
  seurat.combined <- readRDS("Exported_RDS_files/seurat_combined.rds")
  DefaultAssay(seurat.combined) <- "integrated"
  
  seurat.tcr <- readRDS("Exported_RDS_files/seurat_tcr.rds")
  DefaultAssay(seurat.tcr) <- "integrated"
  
  seurat.tcr.filt <- readRDS("Exported_RDS_files/seurat_tcr_filt.rds")
  DefaultAssay(seurat.tcr.filt) <- "integrated"
  
}

```


## VDJdb annotation analysis {.tabset}

### VDJdb annotation setup
```{r VDJdb_annotation}

if(long.compute){


# Create directory
if(!dir.exists("output_tcr/figures/VDJ_annotation")){
  dir.create("output_tcr/figures/VDJ_annotation",
             recursive = TRUE)}


######################################################################
# Use concept and read in function from immunarch for processing 
######################################################################

#install.packages("immunarch")
library("immunarch")



# Prepare TCR data
colnames(seurat.tcr.filt@meta.data)

# select useful data from seurat object
TCR.df <- seurat.tcr.filt@meta.data %>%
  dplyr::select(CTaa, TRBV, TRBJ, seurat_clusters, condition, Clone_conditionwise_n) 

# Split CTaa into TRA and TRB chains
TCR.df$CDR3a <- gsub("_.*", "", TCR.df$CTaa)
TCR.df$CDR3b <- gsub(".*_", "", TCR.df$CTaa)

# Get vectors of unique clonotypes 
CTaa.unique <- unique(TCR.df$CTaa)

########################
# Read in VDJ database 
########################

vdjdb <- dbLoad("Data/VDJ_database/vdjdb.slim.txt", "vdjdb")

####################
# Filter database
####################

colnames(vdjdb)

# HomoSapiens 
vdjdb <- vdjdb %>% 
  filter(species == "HomoSapiens")

# Score info:
# 0 = Low confidence/no information - a critical aspect of sequencing/specificity validation is missing
# 1	= Moderate confidence - no verification / poor TCR sequence confidence
# 2	= High confidence - has some specificity verification, good TCR sequence confidence
# 3	= Very high confidence - has extensive verification or structural data

# Score above 0
vdjdb <- vdjdb %>% 
  filter(vdjdb.score > 0)

# Reduce dataset to antigen.species level
vdjdb <- vdjdb %>% 
  dplyr::distinct(cdr3, antigen.species, gene)

# Split ref dataset by TCR chain
vdjdb.alpha <- vdjdb %>% 
  filter(gene == "TRA")

vdjdb.beta <- vdjdb %>% 
  filter(gene == "TRB")

# split CDR3 by chain and preserve position/pair order
CDR3.alpha <-  gsub("_.*", "", CTaa.unique)
CDR3.beta <-  gsub(".*_", "", CTaa.unique)
length(CDR3.alpha) == length(CDR3.beta)

# Find overlap between query and ref datasets
logic.alpha <- CDR3.alpha %in% vdjdb.alpha$cdr3
logic.beta <- CDR3.beta %in% vdjdb.beta$cdr3

alpha.overlap <- CDR3.alpha[logic.alpha & logic.beta]
beta.overlap <- CDR3.beta[logic.alpha & logic.beta]

length(alpha.overlap) == length(beta.overlap)



vdj.overlap.alpha <- vdjdb.alpha %>% 
  filter(cdr3 %in% alpha.overlap)

vdj.overlap.beta <- vdjdb.beta %>% 
  filter(cdr3 %in% beta.overlap)


# Plot where both chains are found in the dataset

CTaa.vec <- paste0(alpha.overlap, "_", beta.overlap)

for(i in seq_along(CTaa.vec)){

  seurat.tcr <- highlightClonotypes(seurat.tcr, 
                                    cloneCall= "aa", 
                                    sequence = CTaa.vec[i])
  
  
  seurat.tcr@meta.data$highlight[is.na(seurat.tcr@meta.data$highlight)] <- "NA"
  
  
  seurat.tcr@meta.data$highlight[seurat.tcr@meta.data$highlight != "NA"] <- CTaa.vec[i]
  
  seurat.tcr@meta.data$highlight <- factor(seurat.tcr@meta.data$highlight, levels = c(CTaa.vec[i], "NA"))
  
  
  
  print(DimPlot(seurat.tcr, 
                pt.size = 2, 
                split.by = "condition",
                cols = c("Red", "#BEBEBE33"),
                group.by = "highlight") + ggtitle(paste0(CTaa.vec[i])) +
          NoLegend()
  )
  
  dev.copy(pdf, paste0("output_tcr/figures/VDJ_annotation/UMAP_", CTaa.vec[i], ".pdf"))
  dev.off()
}



# Just beta chain 

beta.overlap <- CDR3.beta[logic.beta]

vdj.overlap.beta <- vdjdb.beta %>% 
  filter(cdr3 %in% beta.overlap)


antigen.vec <- unique(vdj.overlap.beta$antigen.species)

for(i in seq_along(antigen.vec)){
  
  antigen.specific.CDR3b <- vdj.overlap.beta %>% 
    filter(antigen.species == antigen.vec[i]) %>%
    pull(cdr3)
  
  
  output.temp <- TCR.df %>% 
    filter(CDR3b %in% antigen.specific.CDR3b)
  
  x <- unique(output.temp$CTaa)
  
  seurat.tcr <- highlightClonotypes(seurat.tcr, 
                                    cloneCall= "aa", 
                                    sequence = x)
  
  
  seurat.tcr@meta.data$highlight[is.na(seurat.tcr@meta.data$highlight)] <- "NA"
  
  
  seurat.tcr@meta.data$highlight[seurat.tcr@meta.data$highlight != "NA"] <- antigen.vec[i]
  
  seurat.tcr@meta.data$highlight <- factor(seurat.tcr@meta.data$highlight, levels = c(antigen.vec[i], "NA"))
  
  
  
  print(DimPlot(seurat.tcr, 
                pt.size = 2, 
                split.by = "condition",
                cols = c("Red", "#BEBEBE33"),
                group.by = "highlight") + ggtitle(paste0(antigen.vec[i])) + 
         NoLegend()
  )
  
  dev.copy(pdf, paste0("output_tcr/figures/VDJ_annotation/UMAP_just_betachain_matched_", antigen.vec[i], ".pdf"))
  dev.off()
}

}
```


## GLIPH analysis {.tabset}

### Export data for analysis
```{r GLIPH_analysis_export}

if(long.compute){

# Exporting data required for GLIPH analysis
colnames(seurat.tcr.filt@meta.data)

# select useful data from seurat object
GLIPH.df <- seurat.tcr.filt@meta.data %>%
  dplyr::select(CTaa, TRBV, TRBJ, condition, Clone_conditionwise_n) 

# Split CTaa into TRA and TRB chains
GLIPH.df$CDR3a <- gsub("_.*", "", GLIPH.df$CTaa)
GLIPH.df$CDR3b <- gsub(".*_", "", GLIPH.df$CTaa)

colnames(GLIPH.df)

# Format dataframe 
GLIPH.df$Subject <- GLIPH.df$condition
head(GLIPH.df)

GLIPH.df <- GLIPH.df %>%
  dplyr::select(CDR3b, TRBV, TRBJ, CDR3a, Subject, Clone_conditionwise_n) 


colnames(GLIPH.df) <- c("CDR3b", "TRBV", "TRBJ", "CDR3a", "Subject:condition", "count")

head(GLIPH.df)

# Write dataframe to file
write.table(GLIPH.df, "output_tcr/tables/GLIPH_input.txt", row.names = FALSE, quote = FALSE, sep = "\t", col.names = FALSE)


rm(GLIPH.df)

# terminal command call 
# ./irtools.osx -c GLIPH_param_file.cfg 

}

```

### read and format data
```{r GLIPH_formatting}

if(do.plot){

# Create directory
if(!dir.exists("output_tcr/figures/GLIPH_analysis")){
  dir.create("output_tcr/figures/GLIPH_analysis",
             recursive = TRUE)}



# read in data
GLIPH.data <- read.csv("output_tcr/GLIPH_analysis/Condition_wise/Condition_cluster.csv")

motif.table <- read.delim("output_tcr/GLIPH_analysis/Condition_wise/Condition_kmer.txt")
head(motif.table)

str(GLIPH.data)

# remove un-necessary columns 
remove.index <- grepl("^HLA", colnames(GLIPH.data))

GLIPH.data <- GLIPH.data[ , !remove.index]

head(GLIPH.data)


#######################################################
# filter GLIPH output for useful information
#######################################################

# to allow comparison with seurat object. must combine CDR3A and CDR3B chain to create CTaa call 
GLIPH.data$CTaa <- paste0(GLIPH.data$TcRa, "_", GLIPH.data$TcRb)


# Firstly remove single and global

#GLIPH.data.local <- 
 # GLIPH.data %>% 
#  dplyr::filter(pattern != "single" & pattern != "" & type != "global")

GLIPH.data <- 
  GLIPH.data %>% 
  dplyr::filter(pattern != "single" & pattern != "")



# now have a table of local motif calls 


head(GLIPH.data)

x <- GLIPH.data %>% 
  dplyr::distinct(pattern, Freq)


x <- x %>%
  dplyr::top_n(10, Freq) %>%
  dplyr::arrange(desc(Freq))





x <- GLIPH.data %>% 
  dplyr::distinct(number_unique_cdr3, pattern)


x <- x %>%
  dplyr::top_n(10, number_unique_cdr3) %>%
  dplyr::arrange(desc(number_unique_cdr3))







length(unique(x$pattern))

motif.vec <- unique(x$pattern)

for(i in seq_along(motif.vec)){
temp <- 
  GLIPH.data %>%
  dplyr::filter(pattern == paste0(motif.vec[i])) 


x <- unique(temp$CTaa)

seurat.tcr <- highlightClonotypes(seurat.tcr, 
                                    cloneCall= "aa", 
                                    sequence = x)
  
  seurat.tcr@meta.data$highlight[is.na(seurat.tcr@meta.data$highlight)] <- "NA"
    
  
  seurat.tcr@meta.data$highlight[seurat.tcr@meta.data$highlight != "NA"] <- paste0(motif.vec[i])

    seurat.tcr@meta.data$highlight <- factor(seurat.tcr@meta.data$highlight, levels = c(paste0(motif.vec[i]), "NA"))
    
    
    levels(seurat.tcr@meta.data$highlight)
  
  print(DimPlot(seurat.tcr, 
                pt.size = 2, 
                split.by = "condition",
                cols = c("Red", "#BEBEBE33"),
                group.by = "highlight") + ggtitle(paste0(motif.vec[i])) #+ 
         # NoLegend()
        )
  
}



CTaa.vec <- unique(GLIPH.data$CTaa)
motif.vec <- unique(GLIPH.data$pattern)

length(CTaa.vec)
length(motif.vec)


output.df <- matrix(nrow = length(motif.vec),
                    ncol = length(CTaa.vec))

colnames(output.df) <- CTaa.vec
rownames(output.df) <- motif.vec

for(i in seq_along(rownames(output.df))){

pattern.id <- gsub("%", "[[:alpha:]]", rownames(output.df)[i])

output.df[i, ] <- grepl(pattern.id, colnames(output.df))



}

x <- output.df[ ,colSums(output.df) > 1]


#x <- output.df


x <- x*1

x <- x[rowSums(x) != 0, ]


heatmap.2(x, 
          scale = "none",
          trace = "none",
          Colv = TRUE,
          Rowv = FALSE,
          cexRow = 0.5, 
          margins = c(8, 5),
          labCol = NA,
          cexCol = 0.8, 
          srtCol = 90,
          col = c("Red", "Blue"))   



?heatmap.2


heatmap(x)

temp.vec <- c("CALANDYKLSF_CASSLTGGRDEQYV")

pattern.id <- c("LSF{1}[[:alpha:]]DY")
pattern.id <- c("QYV[[:alpha:]]")


grepl(pattern.id, temp.vec)




sum(x)


}

```


## OLGA analysis {.tabset}

### Export data for OLGA analysis
```{r OLGA_analysis_export}


if(long.compute){

# Exporting data required for GLIPH analysis
colnames(seurat.tcr.filt@meta.data)

# select useful data from seurat object
OLGA.TCRA.df <- seurat.tcr.filt@meta.data %>%
  dplyr::select(CTgene, CTaa, TRBV, TRBJ, condition, Clone_conditionwise_n) 


OLGA.TCRB.df <- seurat.tcr.filt@meta.data %>%
  dplyr::select(CTgene, CTaa, TRBV, TRBJ, condition, Clone_conditionwise_n) 





}

```



## Script info {.tabset}

### Run time
```{r code_runtime, eval = TRUE}

# calculate compute time for compiling code so far
compute.time <- Sys.time()
print(compute.time-start.time)


```
