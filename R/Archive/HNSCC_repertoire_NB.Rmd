---
title: "Repertoire Analysis"
author: "Nick Borcherding"
date: "8/21/2020"
output: html_document
---
# Loading Data

## Read filtered contig
```{r}
S1.contig <- read.csv("~/Documents/GitHub/HNSCC_Descriptive/Data/VDJ_data/Sample1_filtered_contig_annotations.csv")
S2.contig <- read.csv("~/Documents/GitHub/HNSCC_Descriptive/Data/VDJ_data/Sample2_filtered_contig_annotations.csv")
S3.contig <- read.csv("~/Documents/GitHub/HNSCC_Descriptive/Data/VDJ_data/Sample3_filtered_contig_annotations.csv")
S4.contig <- read.csv("~/Documents/GitHub/HNSCC_Descriptive/Data/VDJ_data/Sample4_filtered_contig_annotations.csv")
```


### Combined TCR

Going to go with 3 seperate combinations - unfiltered (combined), remove NA (combined_NA), and how it was originally called (combined.org)

```{r}
library(scRepertoire)
combined <- combineTCR(list(S1.contig, S2.contig, S3.contig, S4.contig), samples = c("S1", "S2", "S3", "S4"), ID = c("US", "US", "S", "S"), cells = "T-AB")

combined_NA <- combineTCR(list(S1.contig, S2.contig, S3.contig, S4.contig), samples = c("S1", "S2", "S3", "S4"), ID = c("US", "US", "S", "S"), cells = "T-AB", removeNA = TRUE)

combined_Org <- combineTCR(list(S1.contig, S2.contig, S3.contig, S4.contig), samples = c("S1", "S2", "S3", "S4"), ID = c("US", "US", "S", "S"), cells = "T-AB", removeNA = TRUE, filterMulti = TRUE)

```

## Loading seurat object

```{r}
library(Seurat)
seurat.combined <- readRDS("~/Documents/GitHub/HNSCC_Descriptive/Exported_RDS_files/seurat_combined.rds")
```


### Checking barcodes

```{r}
head(rownames(seurat.combined[[]])) #seurat.combined[[]] grabs the meta.data
head(combined[[3]]$barcode) 
```

### Fixing barcode issue

This has been a consistent issue with the ID variable leading to a mismatch in barcodes compared to a seurat object. Just going to loop the gsub across all three combined objects.

```{r}
combined.list <- list(combined, combined_NA, combined_Org)

for (i in seq_along(combined.list)) {
    combined.list[[i]][[1]][["barcode"]] <- gsub('S1_US', 'S1', combined.list[[i]][[1]][["barcode"]]) #replaces S1_US with S1_
    combined.list[[i]][[2]][["barcode"]] <- gsub('S2_US', 'S2', combined.list[[i]][[2]][["barcode"]])
    combined.list[[i]][[3]][["barcode"]] <- gsub('S3_S', 'S3', combined.list[[i]][[3]][["barcode"]])
    combined.list[[i]][[4]][["barcode"]] <- gsub('S4_S', 'S4', combined.list[[i]][[4]][["barcode"]])
}
```


### Extracting and cleaning meta.data

Looking at the meta data - there is already columns for the TCR information. In addition, as we are going to loop over the 3 combinedTCR objects, I will just extract the meta.data and work with it. I am saving all the vectors from "group" to the end of the data frame.

```{r}
meta.data <- seurat.combined[[]][,which(colnames(seurat.combined[[]]) == "group"):ncol(seurat.combined[[]])]
```

## Merging data

Because we are using the meta data in lieu of the seurat object - I am going to modify the functions of scRepertoire a little and use them.

Here I used the `combineExpression()` and stripped out the parameters - now `combineMeta()` takes the combinedTCR() object, meta.data and the cloneTypes and calculated frequency by condition and the amino acid sequence. 

*Based on reading the code - the assumption I am making here is you want to group frequencies by condition instead of samples* 


```{r}
source("~/Documents/GitHub/HNSCC_Descriptive/R/combineMeta.R")

meta.list <- list()

for (i in seq_along(combined.list)){
    meta.list[[i]] <- combineMeta(combined.list[[i]], meta = meta.data)
}
```

***

# Data visualization

Now we have the meta data from seurat.combined merged with the TCR data we can perform the alluvial comparisons.

## Load Libraries
```{r}
library(ggplot2)
library(ggalluvial)
library(ggfittext)
```

## Chord Diagrams 

Here is a little more inuitive for me, seperate the Stim and US cells, create a matrix that counts the shared clonotype by clusters, correct for overcounting and visuaize both conditions using Chord Diagrams. 

For the most part the function `getCircles()` does all the processing. 

```{r}
library(circlize)

source("~/Documents/GitHub/HNSCC_Descriptive/R/getCircles.R")

Chord.list <- list()
for (i in seq_along(meta.list)) {
    Stim <- subset(meta.list[[i]], condition == "Stim")
    US <- subset(meta.list[[i]], condition == "US")
    Stim <- getCircles(Stim)
    US <- getCircles(US)
    Chord.list[[i]] <- list(Stim, US)
    names(Chord.list[[i]]) <- c("Stim", "US")
}


#Defining grid colors
grid.cols = c(Naive_like_1_CM = "#E41A1C",
                Naive_like_2_SC = "#A6761D",
                Naive_like_3 = "#8DA0CB", 
                Cytotoxic = "#666666", 
                Type_I_IFN = "#A6D854", 
                Stimulated_1= "#984EA3", 
                Stimulated_exhausted = "#1B9E77", 
                Exhausted_1 = "#D95F02", 
                Exhausted_2 = "#7570B3", 
                TRM = "#E7298A", 
                gd_T_g9d2 = "#E6AB02", 
                gd_T_non_g9d2 = "#8DD3C7", 
                MAIT = "#FF7F00", 
                Proliferatice = "#E78AC3")
```

```{r}
Stim <- subset(meta.list[[1]], condition == "Stim")
US <- subset(meta.list[[1]], condition == "US")
list <- list("Stim" = Stim, "US" = US)
output <- getCollapsedCircle(list)
chordDiagram(output, grid.col = grid.cols, self.link = 1,annotationTrack = "grid", 
    preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(output))))))
circos.track(track.index = 1, panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    xplot = get.cell.meta.data("xplot")
    ylim = get.cell.meta.data("ylim")
    sector.name = get.cell.meta.data("sector.index")

    circos.text(mean(xlim), ylim[1], sector.name, facing = "clockwise",
        niceFacing = TRUE, adj = c(0, 0.5)) }, bg.border = NA)
```

## Plotting Chord Diagrams
```{r}
dir.create("~/Documents/GitHub/HNSCC_Descriptive/Visualizations")
dir <- "~/Documents/GitHub/HNSCC_Descriptive/Visualizations/"

files <- c("nofilter", "NAfilter", "Orgfilter")

#Slight alteration in ciros.track to produce labels that are perpindicular to the circle instead of parallel
for (i in seq_along(Chord.list)) {
    pdf(paste0(dir, files[i], "_Stimulated_TCRcircos.pdf"), height=10, width=10)
chordDiagram(Chord.list[[i]][["Stim"]], grid.col = grid.cols, self.link = 1, annotationTrack = "grid", 
    preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(Chord.list[[i]][["Stim"]]))))))
circos.track(track.index = 1, panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    xplot = get.cell.meta.data("xplot")
    ylim = get.cell.meta.data("ylim")
    sector.name = get.cell.meta.data("sector.index")

    circos.text(mean(xlim), ylim[1], sector.name, facing = "clockwise",
        niceFacing = TRUE, adj = c(0, 0.5)) }, bg.border = NA)
dev.off()

pdf(paste0(dir, files[i], "_Untimulated_TCRcircos.pdf"), height=10, width=10)
chordDiagram(Chord.list[[i]][["US"]], grid.col = grid.cols, self.link = 1, annotationTrack = "grid", 
    preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(Chord.list[[i]][["US"]]))))))
circos.track(track.index = 1, panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    xplot = get.cell.meta.data("xplot")
    ylim = get.cell.meta.data("ylim")
    sector.name = get.cell.meta.data("sector.index")

    circos.text(mean(xlim), ylim[1], sector.name, facing = "clockwise",
        niceFacing = TRUE, adj = c(0, 0.5)) }, bg.border = NA)
dev.off()
}

```


```{r}
test <- data[, c("CTaa", "seurat_clusters")]

    dTest <- reshape2::dcast(test, CTaa ~ seurat_clusters)

    dTest <- dTest[apply(dTest[,-1], 1, function(x) !all(x==0)),]
    dTest <- dTest[-1]
    total <- nrow(dTest)
    matrix_out <- matrix(ncol = ncol(dTest), nrow = ncol(dTest))
    for (x in seq_len(ncol(dTest))) {
        for (y in seq_len(ncol(dTest)) ){
            matrix_out[y,x] <- length(which(dTest[,x] >= 1 & dTest[,y] >= 1))
        }
    }
    colnames(matrix_out) <- colnames(dTest)
    rownames(matrix_out) <- colnames(dTest)
    #Need to subtract extra cells - will take the difference of the sum of the column minus and the respective cell and subtract that from the respective cell
    for (y in seq_len(ncol(matrix_out))) {
        matrix_out[y,y] <- matrix_out[y,y] - (sum(matrix_out[,y])-matrix_out[y,y])
        if (matrix_out[y,y] < 0) {
            matrix_out[y,y] <- 0
        }
    }
    # Reduces the clonotypes in half - this will allow for accurate depiction by total number of cells in cluster
    for (i in seq_len(ncol(matrix_out))) {
        for (j in seq_len(ncol(matrix_out))) {
            matrix_out[i,j] <- as.integer(matrix_out[i,j]/2)
        }
    }
    output <- data.frame(from = rep(rownames(matrix_out), times = ncol(matrix_out)),
                         to = rep(colnames(matrix_out), each = nrow(matrix_out)),
                         value = as.vector(matrix_out),
                         stringsAsFactors = FALSE)
    # Reorder columns to eliminate redundant comparisons
    for (k in 1:nrow(output)) {
        max <- order(output[k,1:2])[1] #which is first alphabetically
        max <- output[k,max]
        min <- order(output[k,1:2])[2] #which is second alphabetically
        min <- output[k,min]
        output[k,1] <- max
        output[k,2] <- min
    }
    unique <- rownames(unique(output[,1:2])) #removing redundant comparisons
    output <- output[rownames(output) %in% unique, ]
    
    return(output)
```

```{r}
test <- data[, c("CTaa", "seurat_clusters", "condition")]
    dTest <- reshape2::dcast(test, CTaa ~ condition + seurat_clusters)
    totalUS <- table(test$condition)[1]
    totalStim <- table(test$condition)[2]
    dTest <- dTest[apply(dTest[,-1], 1, function(x) !all(x==0)),]
    dTest <- dTest[,-1]
    dTest[dTest > 1] <- 1
    matrix_out <- matrix(ncol = ncol(dTest), nrow = ncol(dTest))
    for (x in seq_len(ncol(dTest))) {
        for (y in seq_len(ncol(dTest)) ){
            matrix_out[y,x] <- length(which(dTest[,x] >= 1 & dTest[,y] >= 1))
        }
    }
    
    colnames(matrix_out) <- colnames(dTest)
    rownames(matrix_out) <- colnames(dTest)
    #Need to subtract extra cells - will take the difference of the sum of the column minus and the respective cell and subtract that from the respective cell
    for (y in seq_len(ncol(matrix_out))) {
        matrix_out[y,y] <- matrix_out[y,y] - (sum(matrix_out[,y])-matrix_out[y,y])
        if (matrix_out[y,y] < 0) {
            matrix_out[y,y] <- 0
        }
    }
    # Reduces the clonotypes in half - this will allow for accurate depiction by total number of cells in cluster
    for (i in seq_len(ncol(matrix_out))) {
        for (j in seq_len(ncol(matrix_out))) {
            matrix_out[i,j] <- as.integer(matrix_out[i,j]/2)
        }
    }
    output <- data.frame(from = rep(rownames(matrix_out), times = ncol(matrix_out)),
                         to = rep(colnames(matrix_out), each = nrow(matrix_out)),
                         value = as.vector(matrix_out),
                         stringsAsFactors = FALSE)
    # Reorder columns to eliminate redundant comparisons
    for (k in 1:nrow(output)) {
        max <- order(output[k,1:2])[1] #which is first alphabetically
        max <- output[k,max]
        min <- order(output[k,1:2])[2] #which is second alphabetically
        min <- output[k,min]
        output[k,1] <- max
        output[k,2] <- min
    }
    unique <- rownames(unique(output[,1:2])) #removing redundant comparisons
    output <- output[rownames(output) %in% unique, ]
    
     output$from_group <- stringr::str_split(output$from, "_", simplify = T, n=2)[,1]
    output$to_group <- stringr::str_split(output$to, "_", simplify = T, n=2)[,1]
    output$from<- stringr::str_split(output$from, "_", simplify = T, n=2)[,2]
    output$to <- stringr::str_split(output$to, "_", simplify = T, n=2)[,2]
    
    output$value <- ifelse(output$from == "US", output$value/totalUS, output$value/totalStim)
```


```{r}
combined_Org <- combined.list[[3]]
seurat.combined <- combineExpression(combined_Org, seurat.combined, groupBy = "ID")
data <- seurat.combined[[]]

output <- getIntegratedCircle(data)

#####Defined data frame that will use to graph
df2 = data.frame(from = paste(output[[1]], output[[4]], sep = "|"),
                 to = paste(output[[2]], output[[5]], sep = "|"),
                 value = output[[3]], stringsAsFactors = FALSE)

###Data frame for the extra track
combined = data.frame(condition = c(output[[5]]), 
    from = c(output[[1]]), to = c(output[[2]]), stringsAsFactors = FALSE)
combined = combined[order(combined$from, combined$to, combined$condition), ]
order = paste(combined$from, combined$condition, sep = "|")


####Ploting
chordDiagram(df2, self.link = 1, annotationTrack = c("grid", "axis"),
    grid.col = grid.col, directional = TRUE,
    order = order,
    preAllocateTracks = list(
        track.height = 0.04,
        track.margin = c(0.05, 0)
    )
)
for(species in unique(combined$from)) {
    l = combined$from == species
    sn = paste(combined$from[l], combined$condition[l], sep = "|")
    highlight.sector(sn, track.index = 1, col = color_species[species], 
        text = species, niceFacing = TRUE)
}
legend("bottomleft", pch = 15, col = color_regions, 
    legend = names(color_regions), cex = 0.6)
legend("bottomright", pch = 15, col = color_species, 
    legend = names(color_species), cex = 0.6)

circos.clear()

#####Changing order of tracks for Clusters on the inside

df2 = data.frame(from = paste(output[[4]], output[[1]], sep = "|"),
                 to = paste(output[[5]], output[[2]], sep = "|"),
                 value = output[[3]], stringsAsFactors = FALSE)

###Data frame for the extra track
combined = data.frame(condition = c(output[[5]]), 
    from = c(output[[1]]), to = c(output[[2]]), stringsAsFactors = FALSE)
combined = combined[order(combined$condition, combined$from, combined$to), ]
order = paste(combined$condition, combined$from, sep = "|")
grid.col = structure(color_species[combined$from], names = order)

gap = rep(1, length(order))
gap[which(!duplicated(combined$condition, fromLast = TRUE))] = 5

####Ploting
circos.par(gap.degree = gap)
chordDiagram(df2, self.link = 1, annotationTrack = c("grid", "axis"),
    grid.col = grid.col, directional = TRUE,
    order = order,
    preAllocateTracks = list(
        track.height = 0.04,
        track.margin = c(0.05, 0)
    )
)


for(region in unique(combined$condition)) {
    l = combined$condition == region
    sn = paste(combined$condition[l], combined$from[l], sep = "|")
    highlight.sector(sn, track.index = 1, col = color_regions[region], 
        text = region, niceFacing = TRUE)
}
legend("bottomleft", pch = 15, col = color_regions, 
    legend = names(color_regions), cex = 0.6)
legend("bottomright", pch = 15, col = color_species, 
    legend = names(color_species), cex = 0.6)

circos.clear()
```

```{r}
library(RColorBrewer)
getPalette1 <- colorRampPalette(brewer.pal(9, "Set1"))
getPalette2 <- colorRampPalette(brewer.pal(9, "Set2"))
all_species = unique(output[[1]])
color_species = structure(getPalette1(length(all_species)), names = all_species)
all_regions = unique(output[[4]])
color_regions = structure(getPalette2(length(all_regions)), names = all_regions)
grid.col = structure(color_regions[combined$condition], names = order)
```


## Alluvial Plots

Still working on this code

```{r}
clust.cols <- c("#E41A1C", # Naive_like_1_CM
                "#A6761D", # Naive_like_2_SC
                "#8DA0CB", # Naive_like_3
                "#666666", # Cytotoxic
                "#A6D854", # Type_I_IFN
                "#984EA3", # Stimulated_1
                "#1B9E77", # Stimulated_exhausted
                "#D95F02", # Exhausted_1
                "#7570B3", # Exhausted_2
                "#E7298A", # TRM
                "#E6AB02", # gd_T_g9d2
                "#8DD3C7", # gd_T_non_g9d2
                "#FF7F00", # MAIT 
                "#E78AC3")

for (i in seq_along(meta.list)) {
graph.df <- meta.list[[i]]
graph.df$barcodes <- rownames(graph.df)

y.axes <- unique(c("condition", "seurat_clusters"))
set.axes <- seq_along(y.axes)
tmp <- graph.df[,c("condition", "seurat_clusters", "CTaa", "barcodes")]
lodes <- to_lodes_form(tmp, key = "x", value = "stratum", 
        id = "alluvium", axes = set.axes, diffuse = c("seurat_clusters", "condition"))

plot <- ggplot(data = lodes, aes(x = x, stratum = stratum, 
                alluvium = alluvium, label = stratum)) +
        geom_stratum() + theme_classic() +
        geom_fit_text(stat = "stratum", infer.label = FALSE, reverse = TRUE) +
        theme(axis.title.x = element_blank(), axis.ticks.x = element_blank()) + 
        geom_flow(aes(fill = lodes[,"seurat_clusters"]), 
            stat = "alluvium", lode.guidance = "forward") + 
        labs(fill = "Cluster") + 
    scale_fill_manual(values = clust.cols) 
ggsave(path = dir, file = paste0(files[i], "_TCRalluvial.pdf"), height=4, width=6)
}

```
