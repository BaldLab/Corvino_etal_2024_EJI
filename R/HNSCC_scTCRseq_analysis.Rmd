---
title: "HNSCC_scTCRseq_analysis"
author: "Dillon Corvino & Nick Borcherding"
date: "03/02/2020"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: united
    highlight: tango
    df_print: paged
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

Built with R version `r getRversion()`

## Setup {.tabset}

### Dataset information
```{r Dataset_Info}

# HNSCC scRNAseq/scTCRseq dataset
# Cells are HNSCC TILs sorted on Lymphocytes/Live/CD3+/CD4-/CD8+
# Human samples
# Each sample is a pool of 4 patients
# samples 1 and 2 are unstimulated 
# samples 3 and 4 are stimulated 
# Patients in sample 1 match patients in sample 3 and sample 2 pairs with 4
# Data acquired was transcript expression, ADT (antibody expression), and TCRA & B sequences
# This analysis uses just Transcript and TCR data


# General information
# CellRanger was used for sequence alignment/QC/counts/TCR calls - performed by Ross (QIMR, Brisbane, Aus)
# DC was provided the output from CellRanger (counts matrix) and used this as input for analysis within this script

```

### Environment
```{r Environment_setup, message = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,  
  eval = TRUE, 
  tidy = TRUE
)

# Environment Set up
rm(list = ls()) #Clean workspace
cat("\014")     #Clean Console
gc() # Free memory

# pipeline variables
start.time <- Sys.time()
quick.load <- TRUE
long.compute <- FALSE

###################
# Install packages
###################

# CITEseq requires latest version of Seurat i.e at least V3
# To install the development version of seurat
# devtools::install_github(repo = 'satijalab/seurat', ref = 'develop')

pkgs <- c("remedy", "Seurat", "dplyr", "rstudioapi",
          "cowplot", "ggplot2", "grid", "gridExtra",
          "styler", "stringr", "inlmisc", "RColorBrewer",
          "readxl", "devtools", "tidyverse", "hdf5r", "scales", "useful")

for(i in 1:length(pkgs)){
  if(!require(pkgs[i], character.only = T)){
    install.packages(pkgs[i])
    require(pkgs[i], character.only = T)
  }else{
    require(pkgs[i], character.only = T)
  }
}

pkgs <- c("gplots", "fgsea", "biomaRt", "clusterProfiler", 
          "GSEABase", "org.Hs.eg.db", "org.Mm.eg.db", "pcaMethods",
          "SingleCellExperiment", "batchelor", "DelayedArray", "DelayedMatrixStats",
          "limma", "SummarizedExperiment")

for(i in 1:length(pkgs)){
  if(!require(pkgs[i], character.only = T)){
    BiocManager::install(pkgs[i])
    require(pkgs[i], character.only = T)
  }else{
    require(pkgs[i], character.only = T)
  }
}


#####################
# Github packages
#####################

# Installed packages 

# library("devtools")

# usethis::browse_github_pat()
# usethis::edit_r_environ()
# GITHUB_PAT = "d8207153aef7b295cdf66eb1e1b2a2ed38b0ca18"
# R_MAX_VSIZE = 30Gb

#devtools::install_github("immunomind/immunarch")

#devtools::install_github("ncborcherding/scRepertoire")
library(scRepertoire)

#.rs.restartR()


####################
# Colour scheme
####################


####################
# Colour scheme
####################

Condition.cols <- c("turquoise", "red")

clust.cols <- c("#E41A1C", # Naive_like_1_CM
                "#A6761D", # Naive_like_2_SC
                "#8DA0CB", # Naive_like_3
                "#666666", # Cytotoxic
                "#A6D854", # Type_I_IFN
                "#984EA3", # Stimulated_1
                "#1B9E77", # Stimulated_exhausted
                "#D95F02", # Exhausted_1
                "#7570B3", # Exhausted_2
                "#E7298A", # TRM
                "#E6AB02", # gd_T_g9d2
                "#8DD3C7", # gd_T_non_g9d2
                "#FF7F00", # MAIT 
                "#E78AC3") # Proliferative

clust.names <- c("Naive_like_1_CM",
                 "Naive_like_2_SC",
                 "Naive_like_3",
                 "Cytotoxic",
                 "Type_I_IFN",
                 "Stimulated_1",
                 "Stimulated_exhausted",
                 "Exhausted_1",
                 "Exhausted_2",
                 "TRM",
                 "gd_T_g9d2",
                 "gd_T_non_g9d2",
                 "MAIT",
                 "Proliferative")

names(clust.cols) <- clust.names

# Set working directory to source file location
setwd(dirname(getActiveDocumentContext()$path))

# since moving script from local to github - I want to adjust work dir to be main github dir - therefore 
setwd("..")
working.dir <- getwd()

# create output directories
if(!dir.exists("Exported_RDS_files")){dir.create("Exported_RDS_files", recursive = T)}
if(!dir.exists("output_tcr")){dir.create("output_tcr", recursive = T)}
if(!dir.exists("output_tcr/figures")){dir.create("output_tcr/figures", recursive = T)}
if(!dir.exists("output_tcr/tables")){dir.create("output_tcr/tables", recursive = T)}
if(!dir.exists("output_tcr/QC")){dir.create("output_tcr/QC", recursive = T)}


# load saved seurat object with cluster annotations and imputation performed
if(quick.load){
  seurat.combined <- readRDS("Exported_RDS_files/seurat_combined.rds")
  DefaultAssay(seurat.combined) <- "integrated"
  
  seurat.tcr <- readRDS("Exported_RDS_files/seurat_tcr.rds")
  DefaultAssay(seurat.tcr) <- "integrated"
  
}



```


### Reproducibility

```{r Reproducibility}

# Only run once to initialise 
#renv::init()

# Run snapshot to update renv.lock file 
#renv::snapshot()


# use to restore environment 
#renv::restore()

```


## TCR analysis - based on scRNAseq expression {.tabset}

### Expression of TCR genes
```{r TCR_gene_expression}

# Set wd
setwd(working.dir)

# Create output directories
if(!dir.exists("output_tcr/figures/TCR_gene_expression/VlnPlot")){
  dir.create("output_tcr/figures/TCR_gene_expression/VlnPlot",
             recursive = T)}

# set and move to output.dir
output.dir <- "output_tcr/figures/TCR_gene_expression"
setwd(output.dir)

# set idents
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# set assay 
DefaultAssay(seurat.combined) <- "RNA"


# Find TCR genes to plot
genes <- rownames(seurat.combined)

pattern <- c("TRAV", "TRBV", "TRAC", "TRBC", "TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

length(TCR.genes)


for(i in 1:length(TCR.genes)){
  print(paste0("Plotting ", TCR.genes[i]))
  
  skip.iteration <- FALSE
  tryCatch(print(VlnPlot(seurat.combined, 
                         paste0(TCR.genes[i]),
                         log = T,
                         group.by = "seurat_clusters",
                         cols = clust.cols,
                         pt.size = 0)),
           error = function(e){skip.iteration <- TRUE})
  if(skip.iteration){next}
  
  
  dev.copy(pdf, paste0("VlnPlot/VlnPlot_", TCR.genes[i], ".pdf"))
  dev.off()
  
}


##################################################
# Plot heatmap of gene expression for TCR genes
##################################################



# get average expression 
Avg.seurat <- AverageExpression(seurat.combined,
                                assay = "integrated",
                                slot = "data",
                                verbose = TRUE,
                                return.seurat = TRUE)



# TCRA genes 
pattern <- c("TRAV", "TRAC")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          group.colors = clust.cols,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRA_genes.pdf")
dev.off()


# TCRB genes
pattern <- c("TRBV", "TRBC")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          group.colors = clust.cols,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRB_genes.pdf")
dev.off()




# TCRG and TCRD genes
pattern <- c("TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          group.colors = clust.cols,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG_TCRD_genes_all_clusts.pdf")
dev.off()



#################################################
# Heatmaps with just G/D and MAIT clusters
#################################################

# Subset data for just GD and MAIT clusters 
clust.pattern <- c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT")
Avg.seurat <- subset(Avg.seurat, idents = clust.pattern)

# Plot all TCRG and TCRD genes across just G/D and MAIT clusters
pattern <- c("TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)


keep.index <- grepl(paste0(clust.pattern, collapse = "|"), names(clust.cols))

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          group.colors = clust.cols[keep.index],
          draw.lines = FALSE,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG_TCRD_genes_gd_MAIT_clusts.pdf")
dev.off()


# Plot all specific G/D TCR and KLRB1 gene expression
TCR.genes <- c("TRGV9", "TRDV2", "TRGC1", "TRGC2", "TRDC", "TRAV1-2", "KLRB1")


DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          group.colors = clust.cols[keep.index],
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG9_TCRD2_KLRB1_expression_gd_MAIT_clusts.pdf")
dev.off()


# Remove unneeded object
rm(Avg.seurat)

# return to working directory
setwd(working.dir)

```

### Expression of TCR genes // IMPUTED
```{r TCR_gene_expression_imputed}
# Set wd
setwd(working.dir)

# Create output directories
if(!dir.exists("output_tcr/figures/TCR_gene_expression/Imputed/VlnPlot")){
  dir.create("output_tcr/figures/TCR_gene_expression/Imputed/VlnPlot",
             recursive = T)}

# set and move to output.dir
output.dir <- "output_tcr/figures/TCR_gene_expression/Imputed"
setwd(output.dir)

# set idents
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# set assay 
DefaultAssay(seurat.combined) <- "alra"


# Find TCR genes to plot
genes <- rownames(seurat.combined)

pattern <- c("TRAV", "TRBV", "TRAC", "TRBC", "TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

length(TCR.genes)


for(i in 1:length(TCR.genes)){
  print(paste0("Plotting ", TCR.genes[i]))
  
  skip.iteration <- FALSE
  tryCatch(print(VlnPlot(seurat.combined, 
                         paste0(TCR.genes[i]),
                         log = TRUE,
                         cols = clust.cols,
                         group.by = "seurat_clusters",
                         pt.size = 0)),
           error = function(e){skip.iteration <- TRUE})
  if(skip.iteration){next}
  
  
  dev.copy(pdf, paste0("VlnPlot/VlnPlot_", TCR.genes[i], "_imputed.pdf"))
  dev.off()
  
}


##################################################
# Plot heatmap of gene expression for TCR genes
##################################################



# get average expression 
Avg.seurat <- AverageExpression(seurat.combined,
                                assay = "alra",
                                slot = "data",
                                verbose = TRUE,
                                return.seurat = TRUE)



# TCRA genes 
pattern <- c("TRAV", "TRAC")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          group.colors = clust.cols,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRA_genes_imputed.pdf")
dev.off()


# TCRB genes
pattern <- c("TRBV", "TRBC")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          group.colors = clust.cols,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRB_genes_imputed.pdf")
dev.off()




# TCRG and TCRD genes
pattern <- c("TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          group.colors = clust.cols,
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG_TCRD_genes_all_clusts_imputed.pdf")
dev.off()



#################################################
# Heatmaps with just G/D and MAIT clusters
#################################################

# Subset data for just GD and MAIT clusters 
clust.pattern <- c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT")
Avg.seurat <- subset(Avg.seurat, idents = clust.pattern)

# Plot all TCRG and TCRD genes across just G/D and MAIT clusters
pattern <- c("TRG", "TRD")

TCR.genes <- unique(grep(paste0(pattern, collapse = "|"), 
                         genes,
                         value = TRUE))

TCR.genes <- sort(TCR.genes, decreasing = TRUE)

keep.index <- grepl(paste0(clust.pattern, collapse = "|"), names(clust.cols))

DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          group.colors = clust.cols[keep.index],
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG_TCRD_genes_gd_MAIT_clusts_imputed.pdf")
dev.off()


# Plot all specific G/D TCR and KLRB1 gene expression
TCR.genes <- c("TRGV9", "TRDV2", "TRGC1", "TRGC2", "TRDC", "TRAV1-2", "KLRB1")


DoHeatmap(Avg.seurat, 
          features = TCR.genes,
          draw.lines = FALSE,
          group.colors = clust.cols[keep.index],
          raster = FALSE)

dev.copy(pdf, "Heatmap_TCRG9_TCRD2_KLRB1_expression_gd_MAIT_clusts_imputed.pdf")
dev.off()


# Remove unneeded object
rm(Avg.seurat)

# return to working directory
setwd(working.dir)

```


## TCR analysis - formatting {.tabset}

### Format data with scRepertoire
```{r Format_data_with_scRep}

# Ensure set to working dir
setwd(working.dir)

#################################
# Read in and format data
#################################

# Load library
library("scRepertoire")

# read in contig files
S1.contig <- read.csv("Data/TCR_data/Sample1_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S2.contig <- read.csv("Data/TCR_data/Sample2_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S3.contig <- read.csv("Data/TCR_data/Sample3_filtered_contig_annotations.csv", stringsAsFactors = FALSE)
S4.contig <- read.csv("Data/TCR_data/Sample4_filtered_contig_annotations.csv", stringsAsFactors = FALSE)

# create list of contigs
contig.list <- list(S1.contig, S2.contig,
                    S3.contig, S4.contig)

# Combine contig list
combined.contig <- combineTCR(contig.list, 
                              samples = c("S1", "S2", "S3", "S4"), 
                              ID = c("US", "US", "Stim", "Stim"), 
                              cells = "T-AB",
                              removeNA = TRUE,
                              removeMulti = FALSE, 
                              filterMulti = TRUE) # take the top 2 expressed chains for cells with multiple chains 

# on average, filteringMulti results in approx. 200 more cells for each sample than outright removing cells

# Need to amend BarcodeID to match with seurat object
combined.contig$S1_US$barcode <- gsub("US_", "", combined.contig$S1_US$barcode)
combined.contig$S2_US$barcode <- gsub("US_", "", combined.contig$S2_US$barcode)
combined.contig$S3_Stim$barcode <- gsub("Stim_", "", combined.contig$S3_Stim$barcode)
combined.contig$S4_Stim$barcode <- gsub("Stim_", "", combined.contig$S4_Stim$barcode)


# Get metadata from seurat object
meta.data <- seurat.combined[[]]

# See my comment about this in the next code chunk - dataset filtering
source("R/combineMeta.R")

# Combined metadata with TCR info
meta.tcr <- combineMeta(combined.contig,
                        meta = meta.data, 
                        cloneTypes = c(None = 0,
                                       Single = 1, 
                                       Small = 5,
                                       Medium = 10, 
                                       Large = 20,
                                       Hyperexpanded = 150))


# Combine seurat object with contig info
seurat.tcr <- combineExpression(combined.contig,
                                seurat.combined,
                                cloneCall = "aa",
                                cloneTypes = c(None = 0,
                                               Single = 1,
                                               Small = 5,
                                               Medium = 10,
                                               Large = 20,
                                               Hyperexpanded = 150),
                                groupBy = "none", # Alternative frequencies are calculated in next code Chunk
                                filterNA = TRUE) # should seurat object be subsetted to remove NA values

# Max freq of a clonotype is 127, therefore reset cloneTypes accordingly

# Seurat object went from 11658 samples to 6625 samples 
# Therefore 56% of original dataset remains 


# Remove frequency column calculated by combineExpression function
logic.vec <- grepl("Frequency", colnames(seurat.tcr@meta.data))
seurat.tcr@meta.data[ ,logic.vec] <- NULL
head(seurat.tcr@meta.data)

# Ensure seurat object cloneType var is a factor with correct levels
seurat.tcr@meta.data$cloneType <- factor(seurat.tcr@meta.data$cloneType, 
                                         levels = c("Hyperexpanded (20 < X <= 150)",
                                                    "Large (10 < X <= 20)", 
                                                    "Medium (5 < X <= 10)",
                                                    "Small (1 < X <= 5)", 
                                                    "Single (0 < X <= 1)"))

# remove unneeded objects
rm(contig.list, S1.contig, S2.contig, S3.contig, S4.contig, meta.data)

```

### Analysis with scRepertoire
```{r scRepertoire_analysis}

# Ensure dir back in working
setwd(working.dir)

# Create output directories
if(!dir.exists("output_tcr/figures/TCRseq/scRepertoire/clusters")){
  dir.create("output_tcr/figures/TCRseq/scRepertoire/clusters",
             recursive = T)}

if(!dir.exists("output_tcr/figures/TCRseq/scRepertoire/modules")){
  dir.create("output_tcr/figures/TCRseq/scRepertoire/modules",
             recursive = T)}

output.dir <- "output_tcr/figures/TCRseq/scRepertoire"
setwd(output.dir)

#########################
# Set uniform variables 
#########################

# for clonalProportion split
split.var <- c(1, 5, 10, 20, 50, 500, 5000, 1e+05)

# for clonalHomeostasis split
homeostasis.var <- c(Rare = 0.001, 
                     very_small = 0.002,
                     Small = 0.005, 
                     Medium = 0.01, 
                     Large = 0.05, 
                     very_Large = 0.1, 
                     Hyperexpanded = 1)


#########################################################
# Perform basic clonotype analysis and visualisation
#########################################################

# quantify % unique clonotype per sample
quantContig(combined.contig,
            cloneCall="aa", 
            scale = TRUE)

dev.copy(pdf, "Quant_contig_sample.pdf")
dev.off()

# quantify % unique clonotype per group
quantContig(combined.contig,
            cloneCall="aa", 
            group = "ID",
            scale = TRUE)

dev.copy(pdf, "Quant_contig_treatment.pdf")
dev.off()


# abundance of clonotypes
abundanceContig(combined.contig,
                cloneCall = "aa",
                group = "ID", 
                scale = TRUE)

dev.copy(pdf, "Clonotype_abundance_by_treatment.pdf")
dev.off()



# Chain length overview 
lengthContig(combined.contig, 
             cloneCall="aa", 
             chains = "combined",
             group = "ID") 

dev.copy(pdf, "Chain_length_combined.pdf")
dev.off()

# Chain length by chain
lengthContig(combined.contig, 
             cloneCall="aa", 
             chains = "single",
             group = "ID")

dev.copy(pdf, "Chain_length_by_locus.pdf")
dev.off()


## Something looks weird with the alluvial plots - lines dont line up

# Compare clonotypes across samples

compareClonotypes(combined.contig,
                  numbers = 20, 
                  samples = c("S1_US", "S3_Stim"), 
                  cloneCall = "aa", 
                  graph = "alluvial") + NoLegend()


compareClonotypes(combined.contig,
                  numbers = 20, 
                  samples = c("S2_US", "S4_Stim"), 
                  cloneCall = "aa", 
                  graph = "alluvial") + NoLegend()



# Overview of clonal homeostasis
clonalHomeostasis(combined.contig, 
                  cloneType = homeostasis.var,
                  cloneCall = "aa")

dev.copy(pdf, "clonalHomeostasis.pdf")
dev.off()


# Clonal Proportion
clonalProportion(combined.contig,
                 split = split.var,
                 cloneCall = "aa") 

dev.copy(pdf, "clonalProportion.pdf")
dev.off()

# clonal overlap
clonalOverlap(combined.contig, 
              cloneCall = "aa", 
              method = "morisita")

dev.copy(pdf, "cloncalOverlap.pdf")
dev.off()


# clone size distribution
clonesizeDistribution(combined.contig, 
                      cloneCall = "aa", 
                      method = "ward.D2")

dev.copy(pdf, "cloneSizeDistribution.pdf")
dev.off()

# Clonal Diversity 
clonalDiversity(combined.contig,
                cloneCall = "aa",
                group = "ID")

dev.copy(pdf, "clonalDiversity.pdf")
dev.off()



########################################################################
# perform basic repertoire analysis across clusters & modules
########################################################################

# Modified function, original was not subsetting correctly
expression2List.mod <- function(sc, group){
  meta <- sc@meta.data
  unique.var <- str_sort(as.character(unique(meta[,group])), numeric = TRUE)
  df <- NULL
  for (i in seq_along(unique.var)) {
    subset.var <- meta[meta[,group] == unique.var[i],]
    df[[i]] <- subset.var
  }
  names(df) <- unique.var
  
  return(df)
}

tcr.clusters <- expression2List.mod(seurat.tcr, group = "seurat_clusters")

####################
# Clonal Diversity 
####################

clonalDiversity(tcr.clusters, 
                cloneCall = "aa")

dev.copy(pdf, "clusters/clonalDiversity_clusters.pdf")
dev.off()


####################
# Clonal Homeostasis
####################

clonalHomeostasis(tcr.clusters, 
                  cloneType = homeostasis.var,
                  cloneCall = "aa") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "clusters/clonalHomeostasis_clusters.pdf")
dev.off()


####################
# Clonal Proportion
####################

clonalProportion(tcr.clusters, 
                 split = split.var,
                 cloneCall = "aa") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "clusters/clonalproportion_clusters.pdf")
dev.off()


####################
# Clonal Overlap
####################

clonalOverlap(tcr.clusters, 
              cloneCall = "aa", 
              method = "overlap") + 
  theme(axis.text.x = element_text(angle = 90))

dev.copy(pdf, "clusters/clonaloverlap_clusters.pdf")
dev.off()


###################################
# Split dataset by condition
###################################

Idents(seurat.tcr) <- seurat.tcr@meta.data$condition

# US
US.seurat.tcr <- subset(seurat.tcr, ident = "US")
tcr.clusters.US <- expression2List.mod(US.seurat.tcr, group = "seurat_clusters")

# Stimulated
Stim.seurat.tcr <- subset(seurat.tcr, ident = "Stim")
tcr.clusters.Stim <- expression2List.mod(Stim.seurat.tcr, group = "seurat_clusters")




p1 <- clonalOverlap(tcr.clusters.US, 
                    cloneCall = "aa", 
                    method = "overlap") + 
  theme(axis.text.x = element_text(angle = 90))

p2 <- clonalOverlap(tcr.clusters.Stim, 
                    cloneCall = "aa", 
                    method = "overlap") + 
  theme(axis.text.x = element_text(angle = 90))


p1|p2



rm(US.seurat.tcr, tcr.clusters.US, Stim.seurat.tcr, tcr.clusters.Stim, tcr.modules, tcr.clusters)


# reset to working dir
setwd(working.dir)
```

### Filter dataset 
```{r Filter_data}

# NICK: 
# What is the difference between seurat.tcr@meta.data and meta.tcr 
# former created with combineExpression() and latter with combineMeta() 
# they look almost identical except the clonetype annotation (single, ... hyperexpanded) is different 

##################################################################################################
# Created this code chuck to control the filtering parameters for TCR dataset
# Keeps downstream analysis consistent 
# also allows easy modification of any of the filtering parameters 
##################################################################################################

###################
# Filter dataset
###################

# Define filtering parameters 
min.clonesize <- 3

clonosize.per.clust <- FALSE # Should the min.clonesize use total dataset clonesize (FALSE) or cluster-wise clonesize (TRUE)

remove.subsets <- c("gd_T_g9d2", 
                    "gd_T_non_g9d2", 
                    "MAIT")

remove.self.ribbons <- FALSE # term used later in circos plot generation

meta.tcr <- seurat.tcr@meta.data
initial.n <- nrow(meta.tcr)
init.clone.n <- length(unique(meta.tcr$CTaa))


# Remove non-alpha/beta T cells and invariant subsets
for(i in seq_along(remove.subsets)){
  logic.vec <- meta.tcr$seurat_clusters == remove.subsets[i]
  meta.tcr <- meta.tcr[!logic.vec, ]
}

# Remove small clonotypes (i.e, <= min.clonesize) 
if(clonosize.per.clust){
  # Filter min clone size in a per condition specific manner i.e must hit threshold within the condition not the entire dataset
  clonotypes <- table(meta.tcr$CTaa, meta.tcr$condition)
  keep.clonotypes <- rownames(clonotypes)[clonotypes[,1] > min.clonesize | clonotypes[,2] > min.clonesize]
  meta.tcr <- meta.tcr[meta.tcr$CTaa %in% keep.clonotypes, ]
}else{
  clonotypes <- table(meta.tcr$CTaa)
  keep.clonotypes <- names(clonotypes)[clonotypes > min.clonesize]
  meta.tcr <- meta.tcr[meta.tcr$CTaa %in% keep.clonotypes, ]
}

filt.n <- nrow(meta.tcr)
filt.clone.n <- length(unique(meta.tcr$CTaa))

# Print info on filtering
print(paste0("# of cells in dataset before filtering = ", initial.n, " and # of clonotypes = ", init.clone.n))
print(paste0("# of cells in dataset after filtering = ", filt.n, " and # of clonotypes = ", filt.clone.n))
print(paste0("# of cells removed in filtering process = ", initial.n - filt.n))


```




## Circos AKA Chord Diagrams {.tabset}

### Set up data for chord diagrams 
```{r setup_chord}

#Here is a little more inuitive for me, seperate the Stim and US cells, create a matrix that counts the shared clonotype by clusters, correct for overcounting and visuaize both conditions using Chord Diagrams. 

#For the most part the function `getCircles()` does all the processing. 

# Load libraries
library(circlize)
library(ggplot2)
library(ggalluvial)
library(ggfittext)

# Source functions
source("R/getCircles.R")


### Proportion parameter to get getGircles(), will divide by total size of none-NA clonotypes
###clonotypesOnly can be used to just count the clonotypes shared between cluster (removes cell numbers from the equation)

# Subset dataset by condition
US <- subset(meta.tcr, condition == "US")

Stim <- subset(meta.tcr, condition == "Stim")


# Collect clonotype overlaps and format data for Circos plots
US <- getCircles(US, 
                 proportion = TRUE, 
                 clonotypesOnly = TRUE)

Stim <- getCircles(Stim,
                   proportion = TRUE, 
                   clonotypesOnly = TRUE)

Chord.list <- list(US, Stim)

names(Chord.list) <- c("US", "Stim")


# Remove ribbons originating and ending in the same cluster
if(remove.self.ribbons){
  for(i in seq_along(names(Chord.list))){
    logic.vec <- Chord.list[[i]][ ,1] == Chord.list[[i]][ ,2]
    Chord.list[[i]] <- Chord.list[[i]][!logic.vec, ]
  }
}


# Defining grid colors
grid.cols <- c(Naive_like_1_CM = "#E41A1C",
               Cytotoxic = "#666666", 
               Exhausted_1 = "#D95F02", 
               Exhausted_2 = "#7570B3", 
               Naive_like_2_SC = "#A6761D",
               Naive_like_3 = "#8DA0CB", 
               Type_I_IFN = "#A6D854", 
               Stimulated_1= "#984EA3", 
               Stimulated_exhausted = "#1B9E77", 
               TRM = "#E7298A",
               Proliferative = "#E78AC3")

```

## Plotting Chord Diagrams
```{r chord_plots}

# Create output directory
dir.create("output_tcr/figures/ChordVisualizations")
dir <- "output_tcr/figures/ChordVisualizations"

# Load required library & source custom functions
library(circlize)
source("R/getCircles.R")

####################
# Plot US dataset
####################

pdf(paste0(dir, "/Unstimulated_TCRcircos_filt.pdf"), height=10, width=10)

chordDiagram(Chord.list[["US"]], 
             grid.col = grid.cols, 
             self.link = 1, 
             annotationTrack = "grid", 
             preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(Chord.list[["US"]]))))))


circos.track(track.index = 1, 
             panel.fun = function(x, y) {
               xlim = get.cell.meta.data("xlim")
               xplot = get.cell.meta.data("xplot")
               ylim = get.cell.meta.data("ylim")
               sector.name = get.cell.meta.data("sector.index")
               
               circos.text(mean(xlim), 
                           ylim[1], 
                           sector.name, 
                           facing = "clockwise",
                           niceFacing = TRUE, 
                           adj = c(0, 0.5)) 
             }, 
             bg.border = NA)

dev.off()

####################
# Plot Stim dataset
####################

pdf(paste0(dir, "/Stimulated_TCRcircos_filt.pdf"), height=10, width=10)

chordDiagram(Chord.list[["Stim"]], 
             grid.col = grid.cols, 
             self.link = 1, 
             annotationTrack = "grid", 
             preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(Chord.list[["Stim"]]))))))

circos.track(track.index = 1, 
             panel.fun = function(x, y) {
               xlim = get.cell.meta.data("xlim")
               xplot = get.cell.meta.data("xplot")
               ylim = get.cell.meta.data("ylim")
               sector.name = get.cell.meta.data("sector.index")
               
               circos.text(mean(xlim), 
                           ylim[1], 
                           sector.name, 
                           facing = "clockwise",
                           niceFacing = TRUE, 
                           adj = c(0, 0.5)) 
             }, 
             bg.border = NA)

dev.off()


```

## Plotting Integrated Chord Diagram
```{r integrated_chord}

#2020/09/01 Still needs adjustment for very small groups to get secondary track - as of now, the code will segregate the clusters between #conditions, but errors at the **for(species in unique(combined$from))** loop


# Create output directory
dir.create("output_tcr/figures/ChordVisualizations")
dir <- "output_tcr/figures/ChordVisualizations"

# Load required library & source custom functions
library(circlize)
source("R/getCircles.R")


# Set colour scheme 
color_species  = c(Naive_like_1_CM = "#E41A1C",
                   Cytotoxic = "#666666", 
                   Exhausted_1 = "#D95F02", 
                   Exhausted_2 = "#7570B3", 
                   Naive_like_2_SC = "#A6761D",
                   Naive_like_3 = "#8DA0CB", 
                   Type_I_IFN = "#A6D854", 
                   Stimulated_1= "#984EA3", 
                   Stimulated_exhausted = "#1B9E77", 
                   TRM = "#E7298A",
                   Proliferative = "#E78AC3")

color_regions  <- c(US = "turquoise", 
                    Stim = "red")

# transparent colour function
mycolour <- function(color, percent = 50, name = NULL) {
  #      color = color name
  #    percent = % transparency
  #       name = an optional name for the color
  
  ## Get RGB values for named color
  rgb.val <- col2rgb(color)
  
  ## Make new color using input color as base and alpha set by transparency
  t.col <- rgb(rgb.val[1], rgb.val[2], rgb.val[3],
               max = 255,
               alpha = (100 - percent) * 255 / 100,
               names = name)
  
  ## Save the color
  return(t.col)
}


# Calculate overlap
output <- getIntegratedCircle(meta.tcr, 
                              proportion = F, 
                              clonotypesOnly = TRUE) # clonotypesOnly will ignore cell # and just count the # of clonotypes that overlap

dim(output) # 253

######################################
# Remove intra-condition links 
######################################

# preserve self links (note: there are only 6 clones unique to condition/cluster)
output[output$from == output$to & output$from_group == output$to_group, ]

# Self-links
self.links <- output$from == output$to & output$from_group == output$to_group

# Inter-condition links only
inter.condition <- output$from_group != output$to_group

# Keep all inter.condition links or self-links
output <- output[self.links | inter.condition, ]
dim(output) # 143



# note there is no directionality in the dataset - simply overlap between clusters in conditions 
df2 <- data.frame(clust_1 = paste(output[[5]], output[[2]], sep = "|"),
                  clust_2 = paste(output[[4]], output[[1]], sep = "|"),
                  value = output[[3]], 
                  stringsAsFactors = FALSE)

##############################
# Set plotting params
##############################

# Ensure plotting params are all cleared
circos.clear()

# Plotting order
df2 <- df2 %>%
  dplyr::arrange(clust_1, clust_2)

order.val <- c(df2$clust_2, df2$clust_1)

# Track colour
grid.col.1 <- color_species
names(grid.col.1) <- paste0("US|", names(grid.col.1))

grid.col.2 <- color_species
names(grid.col.2) <- paste0("Stim|", names(grid.col.2))

grid.col <- c(grid.col.1, grid.col.2)

# Set gap variable
gap.var <- rep(1, length(unique(names(grid.col))))
names(gap.var) <- unique(names(grid.col))

logic.vec <- grepl("US\\|Type_I_IFN", names(gap.var))
gap.var[logic.vec] <- 10

logic.vec <- grepl("Stim\\|Type_I_IFN", names(gap.var))
gap.var[logic.vec] <- 10

circos.par(gap.after = gap.var)


# Ribbon colour
for(i in seq_along(color_species)){
  
  
  link.col <- rep(mycolour("Gray", percent = 80), length(df2$clust_1))
  
  link.col[df2$clust_1 == paste0("US|", names(color_species)[i])] <- color_species[i]
  
  # Set gap
  circos.par(gap.after = gap.var)
  
  
  ####Ploting
  pdf(paste0(dir, "/Circos_inter_condition_", names(color_species)[i], ".pdf"), height=10, width=10)
  
  
  chordDiagram(df2, 
               self.link = 1, 
               annotationTrack = c("grid"),
               grid.col = grid.col,
               col = link.col,
               order = order.val,
               directional = 1,
               link.overlap = FALSE,
               preAllocateTracks = list(
                 track.height = 0.3,
                 track.margin = c(0.05, 0)
               )
  )
  
  
  circos.track(track.index = 1, 
               panel.fun = function(x, y) {
                 xlim = get.cell.meta.data("xlim")
                 xplot = get.cell.meta.data("xplot")
                 ylim = get.cell.meta.data("ylim")
                 sector.name = get.cell.meta.data("sector.index")
                 
                 circos.text(mean(xlim), 
                             ylim[1], 
                             sector.name, 
                             facing = "clockwise",
                             niceFacing = TRUE, 
                             adj = c(0, 0.5)) 
               }, 
               bg.border = NA)
  
  
  dev.off()
  
  circos.clear()
  
}



```


## TCR analysis - General analysis {.tabset}

### Subsetting metadata to designate TRAV/J/C and TRBV/J/C genes
```{r Format_metadata_TCR}

# Split the CTgene string at "." 
temp.list <- str_split(seurat.tcr@meta.data$CTgene, "\\.")

# First and second elements of the list are V and J calls
seurat.tcr@meta.data$TRAV <- sapply(temp.list, "[[", 1)
seurat.tcr@meta.data$TRAJ <- sapply(temp.list, "[[", 2)

# Third element is the TRAC and TRBV combined - therefore split this by "_"
temp.list.2 <- sapply(temp.list, "[[", 3)
temp.list.2 <- str_split(temp.list.2, "_")

# First element is TRAC and second is TRBV gene call
seurat.tcr@meta.data$TRAC <- sapply(temp.list.2, "[[", 1)
seurat.tcr@meta.data$TRBV <- sapply(temp.list.2, "[[", 2)

# 4th and 5th elements of original list are TRBJ and TRBC calls respectively
seurat.tcr@meta.data$TRBJ <- sapply(temp.list, "[[", 4)
seurat.tcr@meta.data$TRBC <- sapply(temp.list, "[[", 6)


```

### Heatmaps VJ gene usage
**Note: Just would add the packages for heatmap.2 (gplots) and your color pallete (RColorBrewer)
```{r V_J_usage_heatmaps}

# Move to working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output_tcr/figures/TCRseq/VJ_usage")){
  dir.create("output_tcr/figures/TCRseq/VJ_usage",
             recursive = T)}

# set and move to output.dir
output.dir <- "output_tcr/figures/TCRseq/VJ_usage"
setwd(output.dir)



########################
# Heatmap functions
########################

hclust.func <- function(x){
  hclust(x, method = 'ward.D2')
}

dist.func <- function(x){
  dist(x,method = 'binary')
}

col.palette <- colorRampPalette(brewer.pal(8, "RdYlBu"))(600)

######################################################
# Plot V/J gene usage as a log2() of cell number
######################################################

# TRA-V gene usage

x <- table(seurat.tcr@meta.data$TRAV, seurat.tcr@meta.data$seurat_clusters)

cells.remove <- c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT")

x <- x[ ,-grep(paste0(cells.remove, collapse = "|"), colnames(x))]


heatmap.2(as.matrix(log2(x+1)), 
          scale = "none",
          trace = "none",
          Colv = TRUE,
          cexRow = 0.5, 
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_TRA_V_usage.pdf")
dev.off()

# TRA-J gene usage

x <- table(seurat.tcr@meta.data$TRAJ, seurat.tcr@meta.data$seurat_clusters)

cells.remove <- c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT")

x <- x[ ,-grep(paste0(cells.remove, collapse = "|"), colnames(x))]


heatmap.2(as.matrix(log2(x+1)), 
          scale = "none",
          trace = "none",
          Colv = TRUE,
          cexRow = 0.5, 
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_TRA_J_usage.pdf")
dev.off()


# TRB-V gene usage

x <- table(seurat.tcr@meta.data$TRBV, seurat.tcr@meta.data$seurat_clusters)

cells.remove <- c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT")

x <- x[ ,-grep(paste0(cells.remove, collapse = "|"), colnames(x))]


heatmap.2(as.matrix(log2(x+1)), 
          scale = "none",
          trace = "none",
          Colv = TRUE,
          cexRow = 0.5, 
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_TRB_V_usage.pdf")
dev.off()



# TRB-J gene usage

x <- table(seurat.tcr@meta.data$TRBJ, seurat.tcr@meta.data$seurat_clusters)

cells.remove <- c("gd_T_non_g9d2", "gd_T_g9d2", "MAIT")

x <- x[ ,-grep(paste0(cells.remove, collapse = "|"), colnames(x))]


heatmap.2(as.matrix(log2(x+1)), 
          scale = "none",
          trace = "none",
          Colv = TRUE,
          cexRow = 0.5, 
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_TRB_J_usage.pdf")
dev.off()




# Reset working dir
setwd(working.dir)




```

### Heatmap of top clonotypes
**Note: This is a very cool way of looking at overlapping clonotypes and it seems consistent from all iterations that Stimulate_1/Cytotoxic/Type_1_interferon are related and more to the point you mentioned Exhusted_1 vs Stimulated_Exhuasted has a greater overlap than Exhusated_2 vs Stimulated_Exhuasted. However it is interesting that the major clonotype in Exhuasted_2 is seen in Stimulated_exhuasted, Exhuasted_1 and proliferative?**
```{r Heatmap_top_clonotypes}

# Move to working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output_tcr/figures/TCRseq/Top_clonotypes_heatmaps")){
  dir.create("output_tcr/figures/TCRseq/Top_clonotypes_heatmaps",
             recursive = T)}

# set and move to output.dir
output.dir <- "output_tcr/figures/TCRseq/Top_clonotypes_heatmaps"
setwd(output.dir)



########################
# Heatmap functions
########################

hclust.func <- function(x){
  hclust(x, method = 'ward.D2')
}

dist.func <- function(x){
  dist(x,method = 'binary')
}

col.palette <- colorRampPalette(brewer.pal(8, "RdYlBu"))(600)





# Get data of how many cells in each cluster are assigned to what clonotypes
clonotype.data <- table(seurat.tcr@meta.data$CTaa, seurat.tcr@meta.data$seurat_clusters)

# remove non-T cell clusters
cells.remove <- c("gd_T_non_g9d2", "gd_T_g9d2")
cells.remove.index <- grep(paste0(cells.remove, collapse = "|"), colnames(clonotype.data))
clonotype.data <- clonotype.data[ ,-cells.remove.index]

# also filter colouring variable to remove non-T cell clusters
temp.cols <- clust.cols[-cells.remove.index]






# Plot the top 10 clonotypes
aa.keep <- sort(rowSums(clonotype.data), decreasing = TRUE)[1:10]

keep.vec <- rownames(clonotype.data) %in% names(aa.keep)

plot.data <- clonotype.data[keep.vec, ]


heatmap.2(as.matrix(log2(plot.data+1)), 
          scale = "none",
          trace = "none",
          ColSideColors = temp.cols,
          Colv = TRUE,
          cexRow = 0.8, 
          margins = c(8, 15),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_top_10_clonotypes.pdf")
dev.off()



# Plot the top 50 clonotypes
aa.keep <- sort(rowSums(clonotype.data), decreasing = TRUE)[1:50]

keep.vec <- rownames(clonotype.data) %in% names(aa.keep)

plot.data <- clonotype.data[keep.vec, ]


heatmap.2(as.matrix(log2(plot.data+1)), 
          scale = "none",
          trace = "none",
          ColSideColors = temp.cols,
          Colv = TRUE,
          cexRow = 0.5, 
          labRow = FALSE,
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_top_50_clonotypes.pdf")
dev.off()



# Plot the all clonotypes in > 3 cells

aa.keep <- rowSums(clonotype.data) > 3

keep.vec <- rownames(clonotype.data) %in% names(aa.keep)[aa.keep]

plot.data <- clonotype.data[keep.vec, ]

heatmap.2(as.matrix(log2(plot.data+1)), 
          scale = "none",
          trace = "none",
          ColSideColors = temp.cols,
          Colv = TRUE,
          cexRow = 0.5, 
          labRow = FALSE,
          margins = c(8, 5),
          cexCol = 0.8, 
          distfun = dist.func,
          hclustfun = hclust.func,
          srtCol = 90,
          col = rev(col.palette))     

dev.copy(pdf, "Heatmap_top_all_clonotypes_in_morethan_3_cells.pdf")
dev.off()




############################################
# Plot top clonotypes in each cluster 
############################################

for(i in seq_along(colnames(clonotype.data))){
  temp <- as.data.frame(clonotype.data)
  
  temp <- temp %>%
    dplyr::filter(Var2 == paste0(colnames(clonotype.data)[i])) %>%
    dplyr::top_n(10)
  
  clonotypes.to.plot <- temp$Var1
  
  keep.vec <- rownames(clonotype.data) %in% clonotypes.to.plot
  
  plot.data <- clonotype.data[keep.vec, ]
  
  heatmap.2(as.matrix(log2(plot.data+1)), 
            scale = "none",
            trace = "none",
            ColSideColors = temp.cols,
            Colv = FALSE,
            cexRow = 0.8, 
            margins = c(8, 15),
            cexCol = 0.8, 
            distfun = dist.func,
            hclustfun = hclust.func,
            srtCol = 90,
            col = rev(col.palette))
  
  dev.copy(pdf, paste0("Heatmap_top_10_clonotypes_in_", colnames(clonotype.data)[i], ".pdf"))
  dev.off()
  
}



# Reset working dir
setwd(working.dir)
```


### Clonotype frequency on UMAP
**Note: To me this also is interesting that you have 2 distinct clusters in the stimulation - one comprised of expanded clonotypes (presumably from the ehuasted clusters) and one of non-expanded clonotypes**
```{r Clonotype_freq}

# Ensure dir back in working
setwd(working.dir)

# Create output directory
if(!dir.exists("output_tcr/figures/TCRseq/Binned_clonotype_expansion_plots")){
  dir.create("output_tcr/figures/TCRseq/Binned_clonotype_expansion_plots",
             recursive = T)}

output.dir <- "output_tcr/figures/TCRseq/Binned_clonotype_expansion_plots"
setwd(output.dir)

###################################
# Plot dataset on UMAP projection
###################################

Idents(seurat.tcr) <- seurat.tcr@meta.data$seurat_clusters

clonetype.col <- c("Red", "Black", "blue", "orange", "lightblue")

# Vis clonotype size on UMAP
UMAPPlot(seurat.tcr, 
         group.by = "cloneType", 
         pt.size = 1) +
  scale_color_manual(values = clonetype.col, 
                     na.value="grey")


dev.copy(pdf, "Clonotype_size_UMAP.pdf")
dev.off()

# Split by condition
UMAPPlot(seurat.tcr, 
         group.by = "cloneType", 
         split.by = "condition", 
         pt.size = 1) +
  scale_color_manual(values = clonetype.col, 
                     na.value="grey")

dev.copy(pdf, "Clonotype_size_UMAP_split_condition.pdf")
dev.off()


# Split by cloneType visualise clusters
UMAPPlot(seurat.tcr, 
         group.by = "seurat_clusters", 
         split.by = "cloneType", 
         pt.size = 1, 
         cols = clust.cols) 

dev.copy(pdf, "Clonotype_size_UMAP_split_cloneType_Clusters.pdf")
dev.off()

# Ensure dir back in working
setwd(working.dir)
```

## TCR analysis - cluster-specific clonotypes {.tabset}

### Count clonotype frequencies and normalise
```{r Count_and_normalise_clonotype_frequencies}

####################################################################################
# Need to count clonotype occurrence per condition and then normalise this value 
####################################################################################

# create temp meta.data df and append cell_ID as column (lost in dplyr workflow)
meta.data.temp <- seurat.tcr@meta.data
meta.data.temp$cell_ID <- rownames(seurat.tcr@meta.data)

corner(meta.data.temp, c = ncol(meta.data.temp))


# Get total number of cells in each condition
US.cell.n <- table(meta.data.temp$condition)[1] # 3,184 
Stim.cell.n <- table(meta.data.temp$condition)[2] # 3,441
total.cell.n <- US.cell.n + Stim.cell.n # 6,625 

#dim(meta.data.temp) // sanity check of total cell number




####################################################################################
# Count occurence of clonotypes across entire dataset 
####################################################################################
# Also: Normalise n() by # of cells within dataset
meta.data.temp <- meta.data.temp %>%
  dplyr::group_by(CTaa) %>%
  dplyr::mutate(Total_clonotype_n = n()) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(Total_clonotype_freq = (Total_clonotype_n/total.cell.n)*100) %>%
  dplyr::ungroup()

####################################################################################
# Count occurence of clonotypes across entire condition 
####################################################################################
# Also: Normalise n() by # of cells within condition
meta.data.temp <- meta.data.temp %>%
  dplyr::group_by(CTaa, condition) %>%
  dplyr::mutate(Clone_conditionwise_n = n()) %>%
  dplyr::group_by(condition) %>%
  dplyr::mutate(Clone_conditionwise_freq = case_when(condition == "US" ~ (Clone_conditionwise_n/US.cell.n)*100, 
                                                     condition == "Stim" ~ (Clone_conditionwise_n/Stim.cell.n)*100)) %>%
  dplyr::ungroup()

####################################################################################
# Count occurence of clonotypes within each cluster per condition 
####################################################################################
# Also: Normalise n() by # of cells within condition
meta.data.temp <- meta.data.temp %>%
  dplyr::group_by(CTaa, condition, seurat_clusters) %>%
  dplyr::mutate(Clone_Clust_conditionwise_n = n()) %>%
  dplyr::group_by(condition) %>%
  dplyr::mutate(Clone_Clust_conditionwise_freq = case_when(condition == "US" ~ (Clone_Clust_conditionwise_n/US.cell.n)*100, 
                                                           condition == "Stim" ~ (Clone_Clust_conditionwise_n/Stim.cell.n)*100)) %>%
  dplyr::ungroup()


######################################
# Add new metadata to seurat object
######################################

#########
# Total 
#########

# Add total clonotype n value
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Total_clonotype_n",
                          metadata = meta.data.temp$Total_clonotype_n)

# Add total clonotype freq
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Total_clonotype_freq",
                          metadata = meta.data.temp$Total_clonotype_freq)

##################
# Condition-wise 
##################

# Add clone condition-wise n value
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Clone_conditionwise_n",
                          metadata = meta.data.temp$Clone_conditionwise_n)

# Add Clone condition-wise freq
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Clone_conditionwise_freq",
                          metadata = meta.data.temp$Clone_conditionwise_freq)

################################
# Cluster and Condition-wise 
################################

# Add Clone Clust and condition-wise n value
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Clone_Clust_conditionwise_n",
                          metadata = meta.data.temp$Clone_Clust_conditionwise_n)

# Add Clone Clust and condition-wise Freq
seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Clone_Clust_conditionwise_freq",
                          metadata = meta.data.temp$Clone_Clust_conditionwise_freq)


#############################################
# Scale variables for downstream plotting
#############################################
scale.var <- c(0, 10)

# Scale total clonotype number
seurat.tcr@meta.data$Total_clonotype_scaled <- scales::rescale(seurat.tcr@meta.data$Total_clonotype_n, 
                                                               to = scale.var)


# Scale clonotype per condition freq
seurat.tcr@meta.data$Clone_conditionwise_scaled <- scales::rescale(seurat.tcr@meta.data$Clone_conditionwise_freq, 
                                                                   to = scale.var)

# Scale clonotype per cluster per condition freq
seurat.tcr@meta.data$Clone_Clust_conditionwise_scaled <- scales::rescale(seurat.tcr@meta.data$Clone_Clust_conditionwise_freq, 
                                                                         to = scale.var)




rm(meta.data.temp)


```

### Get clonotypes function
```{r Get_clonotypes_function}

get.clonotypes <- function(input.seurat, identity.column, ident.id){
  
  # identitiy column = cluster or module 
  # ident.id = a specific module or cluster ID
  
  # This function identifies all clonotypes in a specified cluster/module subset and then pulls out all occurances of these clonotypes
  
  
  
  # set idents
  Idents(input.seurat) <- input.seurat@meta.data[ , paste0(identity.column)]
  
  # Subset by ident.id
  Ident.specific.seurat <- subset(input.seurat, idents = paste0(ident.id))
  
  # get list of clonotypes in selected cluster/module
  Ident.specific.clones <- sort(table(Ident.specific.seurat@meta.data$CTaa), decreasing = TRUE)
  
  # Find all cells that have these clonotypes
  keep.logic <- input.seurat@meta.data$CTaa %in% names(Ident.specific.clones)
  cells.with.ident.sp.clones <- rownames(input.seurat@meta.data)[keep.logic]
  
  # Subset seurat by these cell IDs
  seurat.ident.specific.clones <- subset(input.seurat, cells = cells.with.ident.sp.clones)
  
  
  return(seurat.ident.specific.clones)
  
}

```

## Reduce dataset to clonotypes per cluster
```{r Cluster_clonotypes}

# set working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output_tcr/figures/TCRseq/Cluster_clonotypes")){
  dir.create("output_tcr/figures/TCRseq/Cluster_clonotypes",
             recursive = T)}

output.dir <- "output_tcr/figures/TCRseq/Cluster_clonotypes"
setwd(output.dir)

##########################################################
# Keep only one occurrence of a clonotype in each cluster
##########################################################

uniq.clonotypes <- seurat.tcr@meta.data %>% 
  dplyr::distinct(seurat_clusters, CTaa) %>%
  rownames()

clust.clonotypes.seurat <- subset(seurat.tcr, cells = uniq.clonotypes)
#3773 clonotypes 

# Set Idents
Idents(clust.clonotypes.seurat) <- clust.clonotypes.seurat@meta.data$seurat_clusters

# Cluster Clonotypes
UMAPPlot(clust.clonotypes.seurat, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         cols = clust.cols) + 
  ggtitle("Pts = Cluster clonotypes")

dev.copy(pdf, "Cluster_clonotypes.pdf")
dev.off()

# Cluster Clonotypes // No legend
UMAPPlot(clust.clonotypes.seurat, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         label = TRUE,
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("Pts = Cluster clonotypes") + 
  NoLegend()

dev.copy(pdf, "Cluster_clonotypes_NoLegend.pdf")
dev.off()


# Plot number of clonotypes per cluster
x <- table(clust.clonotypes.seurat@meta.data$seurat_clusters)

barplot(x, 
        las = 2, 
        ylim = c(0, 1000), 
        ylab = "# of clonotypes",
        col = clust.cols,
        main = "# of clonotypes per cluster")

dev.copy(pdf, "Barplot_Num_Cluster_clonotypes.pdf")
dev.off()



############################################
# Scale pt size with clonotype frequency
############################################

Total.clonotype.scale <- clust.clonotypes.seurat@meta.data$Total_clonotype_scaled 

# Total dataset
UMAPPlot(clust.clonotypes.seurat, 
         pt.size = Total.clonotype.scale, 
         group.by = "seurat_clusters", 
         cols = clust.cols) + 
  ggtitle("Clonotypes - scaled by total occurrence")

dev.copy(pdf, "Cluster_clonotypes_scaled_by_occurrence.pdf")
dev.off()



# Total dataset // No legend
UMAPPlot(clust.clonotypes.seurat, 
         pt.size = Total.clonotype.scale, 
         group.by = "seurat_clusters", 
         label = TRUE, 
         label.size = 4,
         cols = clust.cols) + 
  ggtitle("Clonotypes - scaled by total occurrence") +
  NoLegend()

dev.copy(pdf, "Cluster_clonotypes_scaled_by_occurrence_Nolegend.pdf")
dev.off()


# Remove seurat
rm(clust.clonotypes.seurat)


# set working dir
setwd(working.dir)

```


## Reduce dataset to clonotypes per cluster per condition

```{r Cluster_condition_clonotypes}

# set working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output_tcr/figures/TCRseq/Cluster_condition_clonotypes")){
  dir.create("output_tcr/figures/TCRseq/Cluster_condition_clonotypes",
             recursive = T)}

output.dir <- "output_tcr/figures/TCRseq/Cluster_condition_clonotypes"
setwd(output.dir)


############################################################################
# Keep only one occurrence of a clonotype in each cluster per condition
############################################################################

uniq.clonotypes <- seurat.tcr@meta.data %>% 
  dplyr::distinct(seurat_clusters, CTaa, condition) %>%
  rownames()

clust.cond.clonotypes.seurat <- subset(seurat.tcr, cells = uniq.clonotypes)
# 4093 clonotypes

# Set Idents
Idents(clust.cond.clonotypes.seurat) <- clust.cond.clonotypes.seurat@meta.data$seurat_clusters


# Cluster & Condition clonotypes
UMAPPlot(clust.cond.clonotypes.seurat, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         cols = clust.cols) + 
  ggtitle("Pts = Cluster and condition clonotypes")

dev.copy(pdf, "Cluster_condition_clonotypes.pdf")
dev.off()

# Split by condition // no legend
UMAPPlot(clust.cond.clonotypes.seurat, 
         pt.size = 1, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         label = TRUE, 
         label.size = 4,
         cols = clust.cols) + 
  ggtitle("Pts = Cluster and condition clonotypes") + 
  NoLegend()

dev.copy(pdf, "Cluster_condition_clonotypes_Nolegend.pdf")
dev.off()


# Barplot of # of unique clonotypes per clust per condition

x <- table(clust.cond.clonotypes.seurat@meta.data$seurat_clusters, clust.cond.clonotypes.seurat@meta.data$condition)


barplot(t(x),
        las = 2,
        beside = TRUE,
        col = Condition.cols,
        legend = TRUE,
        ylim = c(0, 600),
        ylab = "# of clonotypes", 
        main = "# of unique clonotypes per cluster per condition")

dev.copy(pdf, "Barplot_Num_Cluster_condition_clonotypes.pdf")
dev.off()


############################################
# Scale pt size with clonotype frequency
############################################

Condition.clonotype.scale <- clust.cond.clonotypes.seurat@meta.data$Clone_Clust_conditionwise_scaled 

# Split by condition
UMAPPlot(clust.cond.clonotypes.seurat, 
         pt.size = Condition.clonotype.scale, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         cols = clust.cols) + 
  ggtitle("Clust/Cond Clonotype - by normed condition freq") + NoLegend()

dev.copy(pdf, "Cluster_condition_clonotypes_scaled_by_normalised_conditionwise_freq.pdf")
dev.off()


# Split by condition // No legend
UMAPPlot(clust.cond.clonotypes.seurat, 
         pt.size = Condition.clonotype.scale, 
         group.by = "seurat_clusters", 
         split.by = "condition",
         label = TRUE, 
         label.size = 4,
         cols = clust.cols) + 
  ggtitle("Clust/Cond Clonotype - by normed condition freq") + 
  NoLegend()

dev.copy(pdf, "Cluster__condition_clonotypes_scaled_by_normalised_conditionwise_freq_Nolegend.pdf")
dev.off()


# set working dir
setwd(working.dir)

```

### Cluster-condition-specific clonotypes
```{r Cluster_condition_specific_clonotypes}

# Create output directories
setwd(working.dir)

if(!dir.exists("output_tcr/figures/TCRseq/Cluster_condition__specific_clonotypes")){
  dir.create("output_tcr/figures/TCRseq/Cluster_condition__specific_clonotypes",
             recursive = T)}

output.dir <- "output_tcr/figures/TCRseq/Cluster_condition__specific_clonotypes"
setwd(output.dir)


# Set Idents to Cluster ID
Idents(clust.cond.clonotypes.seurat) <- clust.cond.clonotypes.seurat@meta.data$seurat_clusters



# Get x and y lims for UMAP plots
z <- UMAPPlot(clust.cond.clonotypes.seurat, 
              pt.size = 1,
              group.by = "seurat_clusters",
              split.by = "condition",
              cols = clust.cols)

# extract x and y lims
umap.x.lim <- layer_scales(z)$x$range$range
umap.y.lim <- layer_scales(z)$y$range$range


###################################
# get Cluster specific clonotypes
###################################

Cluster.vect <- unique(clust.cond.clonotypes.seurat@meta.data$condition_clust)

for(i in 1:length(Cluster.vect)){
  
  print(paste0("Performing analysis for Cluster = ", Cluster.vect[i]))
  
  
  # Extract clonotypes found in a specific clust/condition
  clonotype.seurat <- get.clonotypes(clust.cond.clonotypes.seurat, "condition_clust", Cluster.vect[i])
  
  
  ########################
  # Visualisation 
  ########################
  
  # Overall distribution of clonotypes 
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = 1,
                 group.by = "seurat_clusters",
                 split.by = "condition",
                 cols = clust.cols) + 
          xlim(umap.x.lim) + ylim(umap.y.lim) + 
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  dev.copy(pdf, 
           paste0("Clonotypes_found_in_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Scale clonotype size
  print(UMAPPlot(clonotype.seurat, 
                 pt.size = clonotype.seurat@meta.data$Clone_Clust_conditionwise_scaled,
                 group.by = "seurat_clusters", 
                 split.by = "condition",
                 cols = clust.cols) +
          xlim(umap.x.lim) + ylim(umap.y.lim) + 
          ggtitle(paste0("Clonotypes found in ", Cluster.vect[i])))
  
  dev.copy(pdf, 
           paste0("Clonotypes_found_in_", Cluster.vect[i], "_pt_scaled.pdf"))
  dev.off()
  
  
  ############
  # Barplots
  ############
  
  # Number of unique clones
  n.clonotypes <- table(clonotype.seurat@meta.data$seurat_clusters)
  
  print(barplot(n.clonotypes, 
                ylim = c(0, 1000),
                ylab = "# of clonotypes",
                main = paste0("# clonotypes found in Cluster ", Cluster.vect[i]), 
                cex.names = 0.7, 
                las = 2))   
  
  dev.copy(pdf, 
           paste0("Barplot_of_clonotypes_found_in_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Freq of clone overlap
  n.clonotypes <- table(clonotype.seurat@meta.data$seurat_clusters, clonotype.seurat@meta.data$condition)
  total.n.clonotypes <- table(clust.cond.clonotypes.seurat@meta.data$seurat_clusters, clust.cond.clonotypes.seurat@meta.data$condition)
  
  x <- (n.clonotypes/total.n.clonotypes)*100
  
  print(barplot(t(x), 
                ylim = c(0, 100),
                ylab = "% of clonotype overlap",
                main = paste0("% of clonotypes present in ", Cluster.vect[i]), 
                cex.names = 0.9, 
                col = Condition.cols,
                legend = TRUE,
                beside = TRUE,
                las = 2))   
  
  dev.copy(pdf, paste0("Barplot_freq_of_clonotypes_found_in_", Cluster.vect[i], ".pdf"))
  dev.off()
  
  
  # Remove unneeded variable
  rm(clonotype.seurat)
}


setwd(working.dir)




```

### Venn overlap of clonotypes
```{r Unique_shared_clonotypes_Venn}

# Create output directories
setwd(working.dir)

if(!dir.exists("output_tcr/figures/TCRseq/Venn_overlap")){
  dir.create("output_tcr/figures/TCRseq/Venn_overlap",
             recursive = T)}

output.dir <- "output_tcr/figures/TCRseq/Venn_overlap"
setwd(output.dir)

# Load package
library("RVenn")

####################################
# Overlap of all clonotypes
####################################

# Get vector of clonotypes found in US cells
US.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "US") %>%
  dplyr::select(CTaa)

US.clonotypes <- unique(US.clonotypes$CTaa)

length(US.clonotypes) # 1,845 clonotypes

# Get vector of clonotypes found in US cells
Stim.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "Stim") %>%
  dplyr::select(CTaa)

Stim.clonotypes <- unique(Stim.clonotypes$CTaa)

length(Stim.clonotypes) # 1,754 clonotypes

# Venn clonotypes

clonotype.list <- list(US = US.clonotypes, 
                       Stim = Stim.clonotypes)

clonotype.list <- Venn(clonotype.list)


ggvenn(clonotype.list,
       fill = rev(Condition.cols),
       thickness = 0) + 
  ggtitle("All Clonotypes") 

dev.copy(pdf, "Venn_overlap_All_clonotypes.pdf")
dev.off()

# Extract vectors
shared.clonotypes <- overlap(clonotype.list)
unique.US <- discern(clonotype.list, "US")
unique.Stim <- discern(clonotype.list, "Stim")

####################
# Add to metadata
####################
meta.data.vec <- seurat.tcr@meta.data %>%
  dplyr::mutate(Clonotype_overlap = case_when(CTaa %in% shared.clonotypes ~ "Shared", 
                                              CTaa %in% unique.US ~ "US", 
                                              CTaa %in% unique.Stim ~ "Stim")) %>%
  dplyr::select(Clonotype_overlap)


seurat.tcr <- AddMetaData(seurat.tcr, meta.data.vec$Clonotype_overlap, "Clonotype_overlap")


############################################
# Plot distribution on UMAP projection
############################################

# Reduce dataset to a single pt per clonotype per cluster
uniq.clonotypes <- seurat.tcr@meta.data %>% 
  dplyr::distinct(seurat_clusters, CTaa) %>%
  rownames()

clust.clonotypes.seurat <- subset(seurat.tcr, cells = uniq.clonotypes) # 3,773 clonotypes 

x <- clust.clonotypes.seurat@meta.data$Total_clonotype_scaled

UMAPPlot(clust.clonotypes.seurat, 
         pt.size = x, 
         cols = clust.cols,
         split.by = "Clonotype_overlap") + 
  ggtitle("Venn overlap clonotypes")

dev.copy(pdf, "Distribution_of_clonotypes_shared_or_unique_to_condition.pdf")
dev.off()



###########################
# min.clonesize >= 3
###########################

condition.min <- 3

# Get vector of clonotypes found in US cells
US.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "US" & Clone_conditionwise_n >= condition.min) %>%
  dplyr::select(CTaa)

US.clonotypes <- unique(US.clonotypes$CTaa)

length(US.clonotypes) # 183

# Get vector of clonotypes found in US cells
Stim.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "Stim" & Clone_conditionwise_n >= condition.min) %>%
  dplyr::select(CTaa)

Stim.clonotypes <- unique(Stim.clonotypes$CTaa)

length(Stim.clonotypes) # 211

# Venn overlap
clonotype.list <- list(US = US.clonotypes, 
                       Stim = Stim.clonotypes)

clonotype.list <- Venn(clonotype.list)

ggvenn(clonotype.list,
       fill = rev(Condition.cols),
       thickness = 0) + 
  ggtitle("Clones with condition-wise n >= 3") 

dev.copy(pdf, "Venn_overlap_clonesize_greaterthan_equal_3.pdf")
dev.off()


###########################
# Abundant clonotypes only
###########################

condition.min <- 20

# Get vector of clonotypes found in US cells
US.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "US" & Clone_conditionwise_n >= condition.min) %>%
  dplyr::select(CTaa)

US.clonotypes <- unique(US.clonotypes$CTaa)

length(US.clonotypes) #

# Get vector of clonotypes found in US cells
Stim.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "Stim" & Clone_conditionwise_n >= condition.min) %>%
  dplyr::select(CTaa)

Stim.clonotypes <- unique(Stim.clonotypes$CTaa)

length(Stim.clonotypes) #

# Venn overlap
clonotype.list <- list(US = US.clonotypes, 
                       Stim = Stim.clonotypes)

clonotype.list <- Venn(clonotype.list)

ggvenn(clonotype.list,
       fill = rev(Condition.cols),
       thickness = 0) + 
  ggtitle("Abundant clonotypes") 

dev.copy(pdf, "Venn_overlap_abundant_clonotypes.pdf")
dev.off()


################
# Singletons
################

# Get vector of clonotypes found in US cells
US.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "US" & Clone_conditionwise_n == 1) %>%
  dplyr::select(CTaa)

US.clonotypes <- unique(US.clonotypes$CTaa)

length(US.clonotypes)

# Get vector of clonotypes found in US cells
Stim.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "Stim" & Clone_conditionwise_n == 1) %>%
  dplyr::select(CTaa)

Stim.clonotypes <- unique(Stim.clonotypes$CTaa)

length(Stim.clonotypes)

# Venn overlap
clonotype.list <- list(US = US.clonotypes, 
                       Stim = Stim.clonotypes)

clonotype.list <- Venn(clonotype.list)

ggvenn(clonotype.list,
       fill = rev(Condition.cols),
       thickness = 0) + 
  ggtitle("Singletons") 

dev.copy(pdf, "Venn_overlap_singleton_clonotypes.pdf")
dev.off()


##############################################
# Low abundance in US and abundant in Stim
##############################################

# Get vector of clonotypes found in US cells
US.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "US" & Clone_conditionwise_n <= 5) %>%
  dplyr::select(CTaa)

US.clonotypes <- unique(US.clonotypes$CTaa)

length(US.clonotypes)

# Get vector of clonotypes found in US cells
Stim.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "Stim" & Clone_conditionwise_n >= 30) %>%
  dplyr::select(CTaa)

Stim.clonotypes <- unique(Stim.clonotypes$CTaa)

length(Stim.clonotypes)

# Venn overlap 
clonotype.list <- list(US = US.clonotypes, 
                       Stim = Stim.clonotypes)

clonotype.list <- Venn(clonotype.list)

ggvenn(clonotype.list,
       fill = rev(Condition.cols),
       thickness = 0) + 
  ggtitle("US <= 5 and Stim >= 30") 

dev.copy(pdf, "Venn_overlap_low_US_high_Stim_abundance_clonotypes.pdf")
dev.off()


# return to working directory
setwd(working.dir)


# Remove large objects no longer required
rm(clust.clonotypes.seurat)
```


# TO DO 
# Look at shared and unique clonotypes - distribution 

### Plotting top X clonotypes on UMAP projection

```{r highlight_top_clonotypes}

# set working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output_tcr/figures/Top_clonotypes")){
  dir.create("output_tcr/figures/Top_clonotypes",
             recursive = TRUE)}

output.dir <- "output_tcr/figures/Top_clonotypes"
setwd(output.dir)


# Get list of all shared clonotypes (i.e in both US and Stim conditions)
Query.clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(Clonotype_overlap == "Shared") 

Query.clonotypes <- sort(table(Query.clonotypes$CTaa), decreasing = TRUE)

sum(Query.clonotypes > 20)


# Loop over top X clonotypes 
Top.clonotypes <- 30

for(i in seq_len(Top.clonotypes)){
  
  seurat.tcr <- highlightClonotypes(seurat.tcr, 
                                    cloneCall= "aa", 
                                    sequence = names(Query.clonotypes)[i])
  
  seurat.tcr@meta.data$highlight[is.na(seurat.tcr@meta.data$highlight)] <- "NA"
  
  
  print(DimPlot(seurat.tcr, 
                pt.size = 2, 
                split.by = "condition",
                cols = c("Red", "#BEBEBE33"),
                group.by = "highlight") + ggtitle(paste0("Top ", i, " ", names(x)[i])) + NoLegend())
  
  dev.copy(pdf, paste0("Top_clone_", i, "_UMAP_distribution.pdf"))
  dev.off()
  
}


# set working dir
setwd(working.dir)

```






### Export or read in tcr seurat object
```{r export_RDS}

if(quick.load){
  seurat.tcr <- readRDS("Exported_RDS_files/seurat_tcr.rds")
}else if(!quick.load){
  saveRDS(seurat.tcr, file = "Exported_RDS_files/seurat_tcr.rds")
}

```


## GLIPH analysis {.tabset}


### Export data for analysis
```{r GLIPH_analysis_export}

# Exporting data required for GLIPH analysis
colnames(seurat.tcr@meta.data)

# select useful data from seurat object
GLIPH.df <- seurat.tcr@meta.data %>%
  dplyr::select(CTaa, TRBV, TRBJ, condition, Clone_conditionwise_n) 

# Split CTaa into TRA and TRB chains
GLIPH.df$CDR3a <- gsub("_.*", "", GLIPH.df$CTaa)
GLIPH.df$CDR3b <- gsub(".*_", "", GLIPH.df$CTaa)

colnames(GLIPH.df)

# Format dataframe 
GLIPH.df$Subject <- GLIPH.df$condition
head(GLIPH.df)

GLIPH.df <- GLIPH.df %>%
  dplyr::select(CDR3b, TRBV, TRBJ, CDR3a, Subject, Clone_conditionwise_n) 


colnames(GLIPH.df) <- c("CDR3b", "TRBV", "TRBJ", "CDR3a", "Subject:condition", "count")

head(GLIPH.df)

# Write dataframe to file
write.table(GLIPH.df, "output_tcr/tables/GLIPH_input.txt", row.names = FALSE, quote = FALSE, sep = "\t", col.names = FALSE)


rm(GLIPH.df)

# terminal command call 
# ./irtools.osx -c GLIPH_param_file.cfg 


```

### read and format data
```{r GLIPH_formatting}

# read in data
GLIPH.data <- read.csv("output_tcr/GLIPH_analysis/Condition_wise/Condition_cluster.csv")

motif.table <- read.delim("output_tcr/GLIPH_analysis/Condition_wise/Condition_kmer.txt")
head(motif.table)

str(GLIPH.data)

# remove un-necessary columns 
remove.index <- grepl("^HLA", colnames(GLIPH.data))

GLIPH.data <- GLIPH.data[ , !remove.index]

head(GLIPH.data)


#######################################################
# filter GLIPH output for useful information
#######################################################

# to allow comparison with seurat object. must combine CDR3A and CDR3B chain to create CTaa call 
GLIPH.data$CTaa <- paste0(GLIPH.data$TcRa, "_", GLIPH.data$TcRb)


# Firstly remove single and global

GLIPH.data.local <- 
  GLIPH.data %>% 
  dplyr::filter(pattern != "single" & pattern != "" & type != "global")



# now have a table of local motif calls 

motif.table
GLIPH.data.local










motif.data %>%
  dplyr::top_n(10, number_unique_cdr3) 


x <- motif.data %>%
  dplyr::arrange(desc(number_unique_cdr3))



motif.data %>%
  dplyr::top_n(100, Freq) 




length(unique(x$pattern))

motif.vec <- unique(x$pattern)[1:5]

for(i in seq_along(motif.vec)){
temp <- 
  motif.data %>%
  dplyr::filter(pattern == paste0(motif.vec[i])) 

length(unique(temp$CTaa))


x <- unique(temp$CTaa)


seurat.tcr <- highlightClonotypes(seurat.tcr, 
                                    cloneCall= "aa", 
                                    sequence = x)
  
  #seurat.tcr@meta.data$highlight[is.na(seurat.tcr@meta.data$highlight)] <- paste0(motif.vec[i])

  seurat.tcr@meta.data$highlight[is.na(seurat.tcr@meta.data$highlight)] <- "NA"
    
  
  seurat.tcr@meta.data$highlight[seurat.tcr@meta.data$highlight != "NA"] <- paste0(motif.vec[i])

    seurat.tcr@meta.data$highlight <- factor(seurat.tcr@meta.data$highlight, levels = c(paste0(motif.vec[i]), "NA"))
    
    
    levels(seurat.tcr@meta.data$highlight)
  
  print(DimPlot(seurat.tcr, 
                pt.size = 2, 
                split.by = "condition",
                cols = c("Red", "#BEBEBE33"),
                group.by = "highlight") + ggtitle(paste0(motif.vec[i])) #+ 
         # NoLegend()
        )
  
}






head(GLIPH.data)
unique(GLIPH.data$pattern)
unique(GLIPH.data$type)





#-> x

length(unique(x$TcRb))




unique(GLIPH.data$pattern)

GLIPH.data %>%
  dplyr::filter(pattern == "") -> x

x <- GLIPH.data[GLIPH.data$type == "global", ]

unique(x$pattern)

summary(x$Fisher_score)




```


## VDJdb annotation analysis {.tabset}

### VDJdb annotation setup
```{r VDJdb_annotation}

##############################
# Use immunarch for processing 
##############################

#install.packages("immunarch")
library("immunarch")



# Prepare TCR data
colnames(seurat.tcr@meta.data)

# select useful data from seurat object
TCR.df <- seurat.tcr@meta.data %>%
  dplyr::select(CTaa, TRBV, TRBJ, seurat_clusters, condition, Clone_conditionwise_n) 

# Split CTaa into TRA and TRB chains
TCR.df$CDR3a <- gsub("_.*", "", TCR.df$CTaa)
TCR.df$CDR3b <- gsub(".*_", "", TCR.df$CTaa)

# Get vectors of unique clonotypes 
CTaa.unique <- unique(TCR.df$CTaa)
CDR3a.unique <- unique(TCR.df$CDR3a)
CDR3b.unique <- unique(TCR.df$CDR3b)


########################
# Read in VDJ database 
########################

vdjdb <- dbLoad("Data/VDJ_database/vdjdb.slim.txt", "vdjdb")

# Filter database
colnames(vdjdb)

vdjdb <- vdjdb %>% 
  filter(species == "HomoSapiens")

# TCR A chain only
vdjdb.TCRA <- vdjdb %>% 
  filter(gene == "TRA")

# TCR B chain only
vdjdb.TCRB <- vdjdb %>% 
  filter(gene == "TRB")

########################################################
# Identify which clones are found in the vdj database
########################################################

# TCRA chain
logic.vec <- CDR3a.unique %in% vdjdb.TCRA$cdr3
x <- CDR3a.unique[logic.vec]

# TCRB chain
logic.vec <- CDR3b.unique %in% vdjdb.TCRB$cdr3
x <- CDR3b.unique[logic.vec]

# Temp just use the TCRB chain for now
# TO DO: 
# Amend analysis to use both Alpha and beta chain matching



vdj.overlap <- vdjdb.TCRB %>% 
  filter(cdr3 %in% x)

# Restrict output based on having a score >1
#vdj.overlap <- vdj.overlap %>% 
#  filter(vdjdb.score > 1)

# Score info:
# 0 = Low confidence/no information - a critical aspect of sequencing/specificity validation is missing
# 1	= Moderate confidence - no verification / poor TCR sequence confidence
# 2	= High confidence - has some specificity verification, good TCR sequence confidence
# 3	= Very high confidence - has extensive verification or structural data

colnames(vdj.overlap)

# Reduce dataset to keep only a single entry for each antigen.species i.e reduce data to level of antigen.species
vdj.overlap <- vdj.overlap %>% 
  dplyr::distinct(cdr3, antigen.species)


unique(vdj.overlap$antigen.species)


EBV.CDR3b <- vdj.overlap %>% 
  filter(antigen.species == "HIV-1") %>%
  pull(cdr3)


output.temp <- TCR.df %>% 
  filter(CDR3b %in% EBV.CDR3b)






x <- unique(output.temp$CTaa)


seurat.tcr <- highlightClonotypes(seurat.tcr, 
                                    cloneCall= "aa", 
                                    sequence = x)
  

  seurat.tcr@meta.data$highlight[is.na(seurat.tcr@meta.data$highlight)] <- "NA"
    
  
  seurat.tcr@meta.data$highlight[seurat.tcr@meta.data$highlight != "NA"] <- "EBV"

    seurat.tcr@meta.data$highlight <- factor(seurat.tcr@meta.data$highlight, levels = c(paste0("EBV"), "NA"))
    
    
    levels(seurat.tcr@meta.data$highlight)
  
    
    
    
    
    DimPlot(seurat.tcr, 
        pt.size = 2, 
        split.by = "condition",
        cols = c("Red", "#BEBEBE33"),
        group.by = "highlight")


    
    
    
    
    
    
    
    
  print(DimPlot(seurat.tcr, 
                pt.size = 2, 
                split.by = "condition",
                cols = c("Red", "#BEBEBE33"),
                group.by = "highlight") + ggtitle(paste0(motif.vec[i])) #+ 
         # NoLegend()
        )












duplicated(vdj.overlap$cdr3)




res <- dbAnnotate(immdata$data, vdjdb, "CDR3.aa", "cdr3")

?dbAnnotate

data("immdata")

immdata$data






colnames(TCR.df)
head(TCR.df)



```




### TO DO ###########
# scclusteval - to determine stability of identified clusters
# VDJdb epitope prediction for clonotypes
# group clonotypes by Gliph cluster 
# Vis/analyse epitope and Gliph cluster data
# Complex and richness of gliph clusters
# SENIC analysis of Transcription factor regulon activity in clusters
# Data-mining for Type I IFN clusters in HNSCC and other cancer datasets
# Transcription factor analysis - both expression and downstream gene regulation analysis


## Work in progress {.tabset}


#### WORK IN PROGRESS BELOW


### Evaluating the ability for clonotypes to be restimed
```{r Evaluating_clonotype_restim_ability}

# set working dir
setwd(working.dir)

# Create output directories
if(!dir.exists("output_tcr/figures/Clonotype_restimability")){
  dir.create("output_tcr/figures/Clonotype_restimability",
             recursive = TRUE)}

output.dir <- "output_tcr/figures/Clonotype_restimability"
setwd(output.dir)


# Filter dataset for clonesize.min > 3 
clonesize.min <- 3
clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(Total_clonotype_n > clonesize.min) %>%
  dplyr::select(CTaa, seurat_clusters, condition, Clonotype_overlap)

# Get clonotypes found in Exhausted US subsets that are shared with Stim
Ex.clonotypes <- clonotypes %>%
  dplyr::filter(Clonotype_overlap == "Shared" & condition == "US") %>%
  dplyr::filter(seurat_clusters %in% c("Exhausted_1", "Exhausted_2")) %>%
  dplyr::select(CTaa)

Ex.clonotypes <- unique(Ex.clonotypes$CTaa)
length(Ex.clonotypes) # 94 clonotypes


# Within Stimulated condition filter dataset by Ex.clonotypes
Query.clonotypes <- clonotypes %>%
  dplyr::filter(Clonotype_overlap == "Shared" & condition == "Stim") %>%
  dplyr::filter(seurat_clusters %in% c("Stimulated_exhausted", "Exhausted_1", "Exhausted_2")) %>%
  dplyr::filter(CTaa %in% Ex.clonotypes) %>%
  dplyr::select(seurat_clusters, CTaa)

length(Query.clonotypes$CTaa) 
length(unique(Query.clonotypes$CTaa)) # 89 clonotypes // diff in number is due to some clonotypes which have a single cell occuring in US Exhausted cluster but not present in stimulated condition exhausted cluster or Sim_exh clusters.


# To clean up analysis - generated an external function 
source(paste0(working.dir, "/R/Clonotype_distribution_function.R"))

clonotype.freq <- Get.distribution(Query.clonotypes, 
                                   threshold.rowval = 1)

# Plot clonotype.freq
temp <- t(clonotype.freq)
barplot(temp[,], beside = T, las = 2, legend = T)

dev.copy(pdf, "Barplot_clonotype_freq_distribution.pdf")
dev.off()


# Select clones using freq stimulated
stimulatable.clones <- rownames(clonotype.freq)[clonotype.freq[,1] >= 50]
unstimulatable.clones <- rownames(clonotype.freq)[clonotype.freq[,1] <= 40]






# # Bin clonotypes by there distribution frequency
# # get top and bottom 10 clonotypes
# stimulatable.clones <- rownames(clonotype.freq)[1:10]
# 
# n.val <- nrow(clonotype.freq)
# unstimulatable.clones <- rownames(clonotype.freq)[(n.val-9):n.val]
# 


# Reduce seurat object to these clones in US condition only
clonotypes <- seurat.tcr@meta.data %>%
  dplyr::filter(CTaa %in% c(unstimulatable.clones, stimulatable.clones)) %>%
  dplyr::filter(seurat_clusters %in% c("Exhausted_1", "Exhausted_2")) %>%
  dplyr::filter(condition == "US") %>%
  dplyr::select(CTaa, seurat_clusters, condition, Clonotype_overlap)

dim(clonotypes) # 96 cells
unique(clonotypes$seurat_clusters)
length(unique(clonotypes$CTaa)) # 20 clones

# 96 cells before stm
# 294 cells after stim 

# Subset seurat object
keep.cells <- rownames(clonotypes)

seurat.exhausted <- subset(seurat.tcr, cells = keep.cells)

# Annotate metadata in seurat object 
meta.data.temp <- seurat.exhausted@meta.data$CTaa
names(meta.data.temp) <- rownames(seurat.exhausted@meta.data)
logic.vec <- meta.data.temp %in% unstimulatable.clones
meta.data.temp[logic.vec] <- "Unstimable"

logic.vec <- meta.data.temp %in% stimulatable.clones
meta.data.temp[logic.vec] <- "Stimable"



seurat.exhausted <- AddMetaData(object = seurat.exhausted, 
                                col.name = "Stim_potential",
                                metadata = meta.data.temp)

# Plot data
DimPlot(seurat.exhausted, 
        pt.size = 2, 
        group.by = "Stim_potential", 
        split.by = "group")


# Perform dif gene expression
Idents(seurat.exhausted) <- seurat.exhausted@meta.data$Stim_potential


Stim.potential.markers <- FindMarkers(seurat.exhausted, 
                                      ident.1 = "Stimable", 
                                      ident.2 = "Unstimable")

Stim.potential.markers <- Stim.potential.markers %>%
  dplyr::filter(p_val_adj < 0.05) %>%
  dplyr::arrange(avg_logFC)

Stim.potential.markers


# Perform UMAP dim reduction 
seurat.exhausted <- RunUMAP(object = seurat.exhausted,
                            reduction = "pca",
                            reduction.key = "Subset_UMAP",
                            dims = 1:20,
                            umap.method = "uwot",
                            n.neighbors = 30, # 5 to 50
                            min.dist = 0.3, # Sensible values are in the range 0.001 to 0.5
                            seed.use = 42)


UMAPPlot(seurat.exhausted, group.by = "group")
UMAPPlot(seurat.exhausted, group.by = "Stim_potential")

# Vis gene expression
FeaturePlot(seurat.exhausted, 
            "HLA-DRB5")

FeaturePlot(seurat.tcr, 
            "MAD2L2")

FeaturePlot(seurat.tcr, order = T,
            "CD38", pt.size = 2)


VlnPlot(seurat.exhausted, group.by = "seurat_clusters",
        "IFNG", assay = "alra")

VlnPlot(seurat.tcr, group.by = "seurat_clusters",
        "TIM3", assay = "alra", pt.size = 0)



Idents(seurat.tcr) <- seurat.tcr@meta.data$seurat_clusters


Stim.potential.markers <- FindMarkers(seurat.tcr, 
                                      ident.1 = "Stimulated_exhausted", 
                                      ident.2 = "Exhausted_1")


Stim.potential.markers <- Stim.potential.markers %>%
  dplyr::filter(p_val_adj < 0.05) %>%
  dplyr::arrange(desc(avg_logFC))

Stim.potential.markers


x <- grep("^MTRNR.*", rownames(seurat.tcr), value = T)

x <- rownames(Stim.potential.markers)


for(i in seq_along(x)){
  
  print(
    FeaturePlot(seurat.tcr, 
                x[i]))
  
}


#library("Nebulosa")
#Nebulosa::plot_density(seurat.tcr, "CD5")




#############################################
# Append metadata to larger seurat object
#############################################

# Create metadata for unstimable and stimable clonotypes
meta.data.temp <- seurat.tcr@meta.data$CTaa
names(meta.data.temp) <- rownames(seurat.tcr@meta.data)
logic.vec <- meta.data.temp %in% unstimulatable.clones
meta.data.temp[logic.vec] <- "Unstimable"

logic.vec <- meta.data.temp %in% stimulatable.clones
meta.data.temp[logic.vec] <- "Stimable"

logic.vec <- meta.data.temp %in% c("Unstimable", "Stimable")
meta.data.temp[!logic.vec] <- "Other"

unique(meta.data.temp)


seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Stim_potential",
                          metadata = meta.data.temp)




UMAPPlot(seurat.tcr, 
         group.by = "Stim_potential", 
         pt.size = 2,
         split.by = "condition",
         cols = c("#BEBEBE33", "Blue", "Red"))



# return to working directory 
setwd(working.dir)

# # Visualise Unstimable and Stimable clones
# seurat.tcr <- highlightClonotypes(seurat.tcr, 
#                               cloneCall= "aa", 
#                               sequence = unstimulatable.clones)
# 
# seurat.tcr@meta.data$highlight[!is.na(seurat.tcr@meta.data$highlight)] <- "Unstimable"
# seurat.tcr@meta.data$highlight[is.na(seurat.tcr@meta.data$highlight)] <- "NA"
# 
# 
# print(DimPlot(seurat.tcr, 
#               pt.size = 2, 
#               split.by = "condition",
#               cols = c("#BEBEBE33", "Red"),
#               group.by = "highlight"))


```


```{r re_cluster_Exhausted_subsets}


keep.cells <- seurat.tcr@meta.data %>%
  dplyr::filter(condition == "US" & seurat_clusters %in% c("Exhausted_1", "Exhausted_2") & Clonotype_overlap == "Shared") %>%
  rownames_to_column() %>%
  dplyr::pull(rowname)


Exhausted.seurat <- subset(seurat.tcr, cells = keep.cells)

# Save original cluster IDs
Exhausted.seurat@meta.data$RNA_clusters <- Exhausted.seurat@meta.data$seurat_clusters





Idents(Exhausted.seurat) <- Exhausted.seurat@meta.data$Stim_potential
DefaultAssay(Exhausted.seurat) <- "integrated"


# Find variable genes
Exhausted.seurat <- FindVariableFeatures(Exhausted.seurat, 
                                         verbose = TRUE)

# Scale data
Exhausted.seurat <- ScaleData(Exhausted.seurat, 
                              verbose = TRUE)

# Run PCA
Exhausted.seurat <- RunPCA(Exhausted.seurat, 
                           npcs = 30, 
                           verbose = TRUE)

# Find Neighbors
Exhausted.seurat <- FindNeighbors(Exhausted.seurat, 
                                  reduction = "pca", 
                                  k.param = 20,
                                  dims = 1:20)

# Find clusters
Exhausted.seurat <- FindClusters(Exhausted.seurat, 
                                 random.seed = 42,
                                 resolution = 0.4) 


# Run UMAP
Exhausted.seurat <- RunUMAP(object = Exhausted.seurat,
                            reduction = "pca",
                            dims = 1:20,
                            umap.method = "uwot",
                            n.neighbors = 30, # 5 to 50
                            min.dist = 0.3, # Sensible values are in the range 0.001 to 0.5
                            seed.use = 42)

UMAPPlot(Exhausted.seurat, 
         group.by = "RNA_clusters")


UMAPPlot(Exhausted.seurat, 
         group.by = "group")


UMAPPlot(Exhausted.seurat, 
         group.by = "seurat_clusters")


UMAPPlot(Exhausted.seurat, 
         group.by = "Stim_potential", pt.size = 2)









x <- seurat.tcr@meta.data %>%
  dplyr::filter(Stim_potential == "Unstimable") %>%
  pull(CTaa)

length(unique(x)) # 37 clonotypes nostimable & 114 clonotypes restimable
nrow(x) # 223 cells non-stimable & 220 cells restimable 

# Originally 10 clonotypes stimable from 252 cells 
# originally 10 clonotypes unstimable from 156 cells 






# Get clonotypes found in Exhausted US subsets that are shared with Stim
Unstim.clonotypes <- Exhausted.seurat@meta.data %>%
  dplyr::filter(seurat_clusters == 1 | seurat_clusters == 2) %>%
  pull(CTaa)

Unstim.clonotypes <- unique(Unstim.clonotypes)
length(Unstim.clonotypes) # 37 clonotypes

Stimable.clonotypes <- Exhausted.seurat@meta.data %>%
  dplyr::filter(seurat_clusters == 0) %>%
  pull(CTaa)

Stimable.clonotypes <- unique(Stimable.clonotypes)
length(Stimable.clonotypes) # 114 clonotypes


# Within Stimulated condition filter dataset by Unstim.clonotypes
Query.clonotypes.US <- seurat.tcr@meta.data %>%
  dplyr::filter(Clonotype_overlap == "Shared" & condition == "Stim") %>%
  dplyr::filter(seurat_clusters %in% c("Stimulated_exhausted", "Exhausted_1", "Exhausted_2")) %>%
  dplyr::filter(CTaa %in% Unstim.clonotypes) %>%
  dplyr::select(seurat_clusters, CTaa)

length(Query.clonotypes.US$CTaa) 
length(unique(Query.clonotypes.US$CTaa))



Query.clonotypes.stim <- seurat.tcr@meta.data %>%
  dplyr::filter(Clonotype_overlap == "Shared" & condition == "Stim") %>%
  dplyr::filter(seurat_clusters %in% c("Stimulated_exhausted", "Exhausted_1", "Exhausted_2")) %>%
  dplyr::filter(CTaa %in% Stimable.clonotypes) %>%
  dplyr::select(seurat_clusters, CTaa)

length(Query.clonotypes.stim$CTaa) 
length(unique(Query.clonotypes.stim$CTaa))



# Extract clonotype by cluster info
temp <- table(Query.clonotypes.stim$CTaa, Query.clonotypes.stim$seurat_clusters)

# Format table
logic.vec <- colnames(temp) %in% c("Stimulated_exhausted", "Exhausted_1", "Exhausted_2")
temp <- temp[ ,logic.vec]

# Sum values in two exhausted clusters together
logic.vec <- colnames(temp) %in% c("Exhausted_1", "Exhausted_2")
temp[,2] <- rowSums(temp[ ,logic.vec])
colnames(temp)[2] <- "Exhausted"
temp <- temp[,1:2]
colnames(temp)
head(temp)

# Create variable
clonotype.counts <- temp

# Get rowSums
row.values <- rowSums(clonotype.counts)

# remove clonotypes with < clone.min requirement in this subsetted dataset 
summary(row.values) # median = 5
dim(clonotype.counts) # 89 clonotypes

keep.clonotypes <- names(row.values)[row.values >= 5]

clonotype.counts <- clonotype.counts[rownames(clonotype.counts) %in% keep.clonotypes, ]

dim(clonotype.counts) # 49 clonotypes remaining 

# Get rowSums vec for new clonotypes
row.values <- rowSums(clonotype.counts)

# Convert rows to percentages 
clonotype.freq <- clonotype.counts / row.values
clonotype.freq <- clonotype.freq*100

# Order dataset
clonotype.freq <- clonotype.freq[order(clonotype.freq[,1], decreasing = T), ]


# Plot clonotype.freq
temp <- t(clonotype.freq)
barplot(temp[,], beside = T, las = 2, legend = T)

dev.copy(pdf, "Barplot_clonotype_freq_distribution.pdf")
dev.off()









































































# Highlight clusters in larger seurat object 
clust.0.clonotypes <- Exhausted.seurat@meta.data %>%
  dplyr::filter(seurat_clusters == 1 | seurat_clusters == 2) %>%
  pull(CTaa)


clust.0.clonotypes <- Exhausted.seurat@meta.data %>%
  dplyr::filter(seurat_clusters == 0) %>%
  pull(CTaa)


clust.0.clonotypes <- unique(clust.0.clonotypes)



Clonotype.ids <- seurat.tcr@meta.data %>%
  dplyr::filter(CTaa %in% clust.0.clonotypes) %>%
  rownames_to_column() %>%
  pull(rowname)



cell.ids <- rep("Other", nrow(seurat.tcr@meta.data))
names(cell.ids) <- rownames(seurat.tcr@meta.data)

logic.vec <- names(cell.ids) %in% Clonotype.ids

cell.ids[logic.vec] <- "Cluster_0"


seurat.tcr <- AddMetaData(object = seurat.tcr, 
                          col.name = "Reclustering",
                          metadata = cell.ids)


UMAPPlot(seurat.tcr, 
         group.by = "Reclustering", 
         split.by = "condition")








```




## Script info {.tabset}

### Run time
```{r code_runtime, eval = TRUE}

# calculate compute time for compiling code so far
compute.time <- Sys.time()
print(compute.time-start.time)


```
