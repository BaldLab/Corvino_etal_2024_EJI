---
title: "HNSCC_Dataset_Preprocessing"
author: "Dillon Corvino"
date: "03/02/2020"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: united
    highlight: tango
    df_print: paged
    code_folding: hide
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

Built with R version `{r} getRversion()`

## Setup {.tabset}

### Dataset information

```{r Dataset_Info}

# HNSCC scRNAseq/scTCRseq dataset
# Cells are HNSCC TILs sorted on Lymphocytes/Live/CD3+/CD4-/CD8+
# Human samples
# Each sample is a pool of 4 patients
# samples 1 and 2 are unstimulated 
# samples 3 and 4 are stimulated 
# Patients in sample 1 match patients in sample 3 and sample 2 pairs with 4
# Data acquired was transcript expression, ADT (antibody expression), and TCRA & B sequences
# This analysis uses just Transcript and TCR data


# General information
# CellRanger was used for sequence alignment/QC/counts/TCR calls - performed by Ross (QIMR, Brisbane, Aus)
# DC was provided the output from CellRanger (counts matrix) and used this as input for analysis within this script

```

### Environment

```{r Environment_setup, message = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,  
  eval = TRUE, 
  tidy = TRUE
)

# Environment Set up
rm(list = ls()) #Clean workspace
cat("\014")     #Clean Console
gc() # Free memory


# Establish working directory
library("rstudioapi")

# Set working directory to source file location
setwd(dirname(getActiveDocumentContext()$path))
setwd("..")

# Load packages and create output directories
source("R/Load_packages.R", local = knitr::knit_global())
source("R/Setup.R", local = knitr::knit_global())

# Establish colour scheme
source("R/Colour_scheme_variable.R", local = knitr::knit_global())

# Load custom functions
source("R/scRNAseq_function.R", local = knitr::knit_global())
source("R/annotate_seurat_heatmap_function.R", local = knitr::knit_global())
source("R/Enhanced_volcano_custom_defaults_function.R", local = knitr::knit_global())


# pipeline variables
quick.load <- FALSE
long.compute <- TRUE

```


### Reading data

```{r reading_data}

# Load dataset from output generated by Ross, file is annotated as filtered_feature_bc_matrix

Sample1.data <- Read10X(data.dir = "Data/10X_GEX_data/Sample1_US/")
Sample2.data <- Read10X(data.dir = "Data/10X_GEX_data/Sample2_US/")
Sample3.data <- Read10X(data.dir = "Data/10X_GEX_data/Sample3_Stim/")
Sample4.data <- Read10X(data.dir = "Data/10X_GEX_data/Sample4_Stim/")


Sample1.seurat <- CreateSeuratObject(counts = Sample1.data,
                                     min.cells = 3,
                                     min.features = 200)

Sample2.seurat <- CreateSeuratObject(counts = Sample2.data,
                                     min.cells = 3,
                                     min.features = 200)

Sample3.seurat <- CreateSeuratObject(counts = Sample3.data,
                                     min.cells = 3,
                                     min.features = 200)

Sample4.seurat <- CreateSeuratObject(counts = Sample4.data,
                                     min.cells = 3,
                                     min.features = 200)

# Add metadata 
Sample1.seurat@meta.data$group <- "S1"
Sample2.seurat@meta.data$group <- "S2"
Sample3.seurat@meta.data$group <- "S3"
Sample4.seurat@meta.data$group <- "S4"

```

### Merge Seurat objects

```{r merge_seurat}


######################
# Merge samples
######################

# Unstimulated samples 1 & 2
US.seurat <- merge(x = Sample1.seurat, 
                   y = Sample2.seurat,
                   add.cell.ids = c("S1", "S2"), 
                   merge.data = FALSE, # Should normed data be merged as well or just raw data slot
                   project = "Unstimulated")

x <- ncol(Sample1.seurat) + ncol(Sample2.seurat)
paste0("expected number of cells after merge is ", ncol(US.seurat) == x)

Sample1.seurat # 14,695 genes and 3,042 cells
Sample2.seurat # 14,706 genes and 3,536 cells
US.seurat # 15,428 genes and 6,578 cells

head(US.seurat@meta.data)


# Stimulated samples 3 & 4
Stim.seurat <- merge(x = Sample3.seurat, 
                     y = Sample4.seurat,
                     add.cell.ids = c("S3", "S4"), 
                     merge.data = FALSE, # Should normed data be merged as well or just raw data slot
                     project = "Stimulated")

x <- ncol(Sample3.seurat) + ncol(Sample4.seurat)
paste0("expected number of cells after merge is ", ncol(Stim.seurat) == x)

Sample3.seurat # 14,740 genes and 3,885 cells
Sample4.seurat # 14,926 genes and 3,279 cells
Stim.seurat # 15,619 genes and 7,164 cells

head(Stim.seurat@meta.data)

# Add a condition metadata column
US.seurat@meta.data$condition <- "US"
Stim.seurat@meta.data$condition <- "Stim"





#total.seurat <- merge(x = US.seurat, 
#                   y = Stim.seurat,
#                   merge.data = FALSE, # Should normed data be merged as well or just raw data slot
#                   project = "merged_seurat")







```

### Remove large variables that are no longer needed

```{r Remove_unneeded_variables}

rm(Sample1.data, 
   Sample2.data, 
   Sample3.data, 
   Sample4.data,
   Sample1.seurat, 
   Sample2.seurat,
   Sample3.seurat,
   Sample4.seurat)


```

## QC and Normalisation {.tabset}

### QC & Normalisation

```{r QC_and_normalisation}


# QC metrics commonly used
# The number of unique genes detected in each cell.
# Low-quality cells or empty droplets will often have very few genes
# Cell doublets or multiplets may exhibit an aberrantly high gene count

# Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes)

# The percentage of reads that map to the mitochondrial genome
# Low-quality / dying cells often exhibit extensive mitochondrial contamination


################################################
#  Get percentage Mitochondria gene expression
################################################

# Unstimulated
US.seurat[["percent.mito"]] <- PercentageFeatureSet(US.seurat, pattern = "^MT-")

# Stimulated
Stim.seurat[["percent.mito"]] <- PercentageFeatureSet(Stim.seurat, pattern = "^MT-")

# total
total.seurat[["percent.mito"]] <- PercentageFeatureSet(total.seurat, pattern = "^MT-")


##################################
# Plot mitochondria percentage
##################################

# nFeature & nCount & Mito (US)
VlnPlot(object = US.seurat, 
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), 
        pt.size = 0.1)

dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_US.pdf")
dev.off()

# Mito (US)
VlnPlot(US.seurat, 
        features = "percent.mito", 
        y.max = 20,
        pt.size = 0.1)

dev.copy(pdf, "output/QC/QC_RNA_percentMito_US.pdf")
dev.off()

# nFeature & nCount & Mito (Stim)
VlnPlot(object = Stim.seurat, 
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), 
        pt.size = 0.1)

dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Stim.pdf")
dev.off()

# Mito (Stim)
VlnPlot(Stim.seurat, 
        features = "percent.mito",
        y.max = 20, 
        pt.size = 0.1)

dev.copy(pdf, "output/QC/QC_RNA_percentMito_Stim.pdf")
dev.off()



########################################
# Count vs Mito & Count vs Feature
########################################

# Unstimulated
plot1 <- FeatureScatter(US.seurat, feature1 = "nCount_RNA", feature2 = "percent.mito")
plot2 <- FeatureScatter(US.seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1|plot2

dev.copy(pdf, "output/QC/QC_RNA_percentMito_nCount_nFeature_corr_US.pdf")
dev.off()

# Stimulated
plot1 <- FeatureScatter(Stim.seurat, feature1 = "nCount_RNA", feature2 = "percent.mito")
plot2 <- FeatureScatter(Stim.seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1|plot2

dev.copy(pdf, "output/QC/QC_RNA_percentMito_nCount_nFeature_corr_Stim.pdf")
dev.off()


############################
# Structure and metadata 
############################

# Unstimulated
head(US.seurat@meta.data)
str(US.seurat@meta.data)

# Stimulated
head(Stim.seurat@meta.data)
str(Stim.seurat@meta.data)

###################
#  Filter cells
###################

# Seurat recommends removing cells with <200 or >2,500 genes or >10% mito genes

# Unstimulated
US.seurat.filt <- subset(US.seurat,
                         subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mito < 10)


# Post-filtering metrics

US.seurat # 15,429 genes across 6,584 cells
US.seurat.filt # 15,429 genes across 5,785 cells

# Therefore
6584 - 5785
# 799 cells were deleted

# Stimulated
Stim.seurat.filt <- subset(Stim.seurat,
                           subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mito < 10)

# Post-filtering metrics

Stim.seurat # 15,618 genes across 7,167 cells
Stim.seurat.filt # 15,618 genes across 6,042 cells

# Therefore
7167 - 6042
# 1125 cells were deleted


# total
total.seurat.filt <- subset(total.seurat,
                            subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mito < 10)

# Post-filtering metrics

total.seurat # 16,295 genes across 13,751 cells
total.seurat.filt # 16,295 genes across 11,827 cells


##########################################
# Visualise QC metrics after filtering
##########################################

# Unstimulated

# Before Filtering
VlnPlot(object = US.seurat,
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), 
        pt.size = 0.1)

# After filtering
VlnPlot(object = US.seurat.filt,
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"),
        pt.size = 0.1)

dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Post_filtering_US.pdf")
dev.off()

# Stimulated

# Before Filtering
VlnPlot(object = Stim.seurat, 
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"),
        pt.size = 0.1)

# After filtering
VlnPlot(object = Stim.seurat.filt,
        features = c("nFeature_RNA", "nCount_RNA", "percent.mito"),
        pt.size = 0.1)

dev.copy(pdf, "output/QC/QC_nFeature_nCount_RNA_percentMito_Post_filtering_Stim.pdf")
dev.off()



################################################
# Normalise, scale & find variable genes 
################################################

#################
# Unstimulated
#################

# Normalise
US.seurat.filt <- NormalizeData(
  object = US.seurat.filt,
  assay = "RNA",
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  verbose = TRUE
)

# Find variable genes
US.seurat.filt <- FindVariableFeatures(
  object = US.seurat.filt,
  verbose = TRUE
)

# Scale data
US.seurat.filt <- ScaleData(
  object = US.seurat.filt,
  assay = "RNA",
  vars.to.regress = c("nCount_RNA", "percent.mito"),
  model.use = "linear",
  do.scale = TRUE,
  do.center = TRUE,
  verbose = TRUE
)

#################
# Stimulated
#################

# Normalise
Stim.seurat.filt <- NormalizeData(
  object = Stim.seurat.filt,
  assay = "RNA",
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  verbose = TRUE
)

# Find variable genes
Stim.seurat.filt <- FindVariableFeatures(
  object = Stim.seurat.filt,
  verbose = TRUE
)

# Scale data
Stim.seurat.filt <- ScaleData(
  object = Stim.seurat.filt,
  assay = "RNA",
  vars.to.regress = c("nCount_RNA", "percent.mito"),
  model.use = "linear",
  do.scale = TRUE,
  do.center = TRUE,
  verbose = TRUE
)

#################
# total
#################

# Normalise
total.seurat.filt <- NormalizeData(
  object = total.seurat.filt,
  assay = "RNA",
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  verbose = TRUE
)

# Find variable genes
total.seurat.filt <- FindVariableFeatures(
  object = total.seurat.filt,
  verbose = TRUE
)

# Scale data
total.seurat.filt <- ScaleData(
  object = total.seurat.filt,
  assay = "RNA",
  vars.to.regress = c("nCount_RNA", "percent.mito"),
  model.use = "linear",
  do.scale = TRUE,
  do.center = TRUE,
  verbose = TRUE
)



###############################
# Remove unneeded variables
###############################

rm(US.seurat, Stim.seurat, total.seurat)


```

## Combine treatment conditions {.tabset}

### Integrate data

```{r Integrate_across_conditions}

# Set activate assay to RNA
DefaultAssay(US.seurat.filt) <- "RNA"
DefaultAssay(Stim.seurat.filt) <- "RNA"

# Create list of seurat objects
seurat.list <- list(US = US.seurat.filt, Stim = Stim.seurat.filt)

# Find Integration Anchors
immune.anchors <- FindIntegrationAnchors(object.list = seurat.list, 
                                         anchor.features = 2000, 
                                         scale = TRUE, 
                                         normalization.method = "LogNormalize", 
                                         reduction = "cca", 
                                         l2.norm = TRUE,
                                         dims = 1:30,
                                         k.anchor = 5,
                                         k.filter = 200,
                                         k.score = 30,
                                         max.features = 200,
                                         nn.method = "rann",
                                         eps = 0,
                                         verbose = TRUE)

# Integrate dataset
seurat.combined <- IntegrateData(anchorset = immune.anchors,
                                 new.assay.name = "integrated",
                                 normalization.method = "LogNormalize",
                                 dims = 1:30,
                                 k.weight = 100,
                                 sd.weight = 1,
                                 verbose = TRUE)


# Basic overview of data
seurat.combined # 11,827 cells and 18,295 genes 

US.seurat.filt # 5,785 cells
Stim.seurat.filt # 6,042 cells


# Save files 
saveRDS(US.seurat.filt, file = "Exported_RDS_files/US_seurat_filt.rds")
saveRDS(Stim.seurat.filt, file = "Exported_RDS_files/Stim_seurat_filt.rds")

# Remove unnecessary data
rm(US.seurat.filt)
rm(Stim.seurat.filt)


# Format metadata in integrated seurat object
seurat.combined@meta.data$condition <- factor(seurat.combined@meta.data$condition, levels = c("US", "Stim"))


# Remove unneeded data
rm(immune.anchors, seurat.list)

```

## Clustering and dim reduction {.tabset}

### PCA and cluster identificaton

```{r Cluster_data}

DefaultAssay(seurat.combined) <- "integrated"

# Scale data
seurat.combined <- ScaleData(seurat.combined, 
                             verbose = TRUE)

# Run PCA
seurat.combined <- RunPCA(seurat.combined, 
                          npcs = 30, 
                          verbose = TRUE)

# Find Neighbors
seurat.combined <- FindNeighbors(seurat.combined, 
                                 reduction = "pca", 
                                 k.param = 20,
                                 dims = 1:20)

# Find clusters
seurat.combined <- FindClusters(seurat.combined, 
                                random.seed = 42,
                                resolution = 0.4) # 0.4 is cluster resolution decided upon


```

### Run UMAP

```{r UMAP}

# Create output directory
if(!dir.exists("output/figures/UMAP_no_clusts_removed")){
  dir.create("output/figures/UMAP_no_clusts_removed", 
             recursive = T)
}


# Run UMAP
seurat.combined <- RunUMAP(object = seurat.combined,
                           reduction = "pca",
                           dims = 1:20,
                           umap.method = "uwot",
                           n.neighbors = 30, # 5 to 50
                           min.dist = 0.3, # Sensible values are in the range 0.001 to 0.5
                           seed.use = 42)


# Plot UMAP projection
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + ggtitle("Integrated (n.neigh = 30 & min.dist = 0.3)") + NoLegend()

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_clusts_clust.pdf")
dev.off()



# UMAP projection grouped by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         cols = Condition.cols,
         group.by = "condition") + ggtitle("UMAP vis by Condition") 

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_condition.pdf")
dev.off()



p1 <- DimPlot(seurat.combined, 
              reduction = "umap", 
              cols = Condition.cols,
              group.by = "condition")

p2 <- DimPlot(seurat.combined, 
              reduction = "umap", 
              label = TRUE)

p1|p2

dev.copy(pdf, "output/figures/UMAP_no_clusts_removed/UMAP_clusters_conditions_sidebyside.pdf")
dev.off()


```

## Remove uninformative clusters {.tabset}

### Visualise and justify removing clusters

```{r Justify_clusts_to_remove}

# Based on resolution of 0.4 for cluster identification 
# Cluster #15 and 13 are to be removed 
# 15 = Myeloid population 
# 13 = ?? 


# Create output directory
if(!dir.exists("output/figures/Cluster_removal_validation")){
  dir.create("output/figures/Cluster_removal_validation", 
             recursive = T)
}


# Show overall number and frequency of clusters

x <- table(seurat.combined@meta.data$seurat_clusters)
y <- prop.table(table(seurat.combined@meta.data$seurat_clusters))*100

barplot(x, 
        main = "# of cells per cluster", 
        xlab = "Cluster #", 
        ylab = "# of cells",
        cex.names = 0.8, 
        ylim = c(0, 2000))

dev.copy(pdf, "output/figures/Cluster_removal_validation/Number_cells_per_cluster.pdf")
dev.off()

barplot(y,
        main = "% of cells per cluster",
        xlab = "Cluster #",
        ylab = "% of cells",
        cex.names = 0.8, 
        ylim = c(0, 20))

dev.copy(pdf, "output/figures/Cluster_removal_validation/Percent_cells_per_cluster.pdf")
dev.off()


##########################################################################################
# Get differentially expressed genes for clusters to be removed and show heatmaps
##########################################################################################

# Set assay to RNA
DefaultAssay(seurat.combined) <- "RNA"

################
# Positive only
################

# Find markers for clust 13
Clust.13.Markers <- FindMarkers(seurat.combined,
                                assay = "RNA",
                                ident.1 = "13",
                                only.pos = TRUE,
                                min.diff.pct = 0.1,
                                return.thresh = 0.05)


# Find markers for clust 15
Clust.15.Markers <- FindMarkers(seurat.combined,
                                assay = "RNA",
                                ident.1 = "15",
                                only.pos = TRUE,
                                min.diff.pct = 0.1,
                                return.thresh = 0.05)

###################
# Heatmap vis
###################

# Downsample for heatmap vis
#seurat.combined.small <- subset(seurat.combined, downsample = 300)

# Heatmap of Clust 13 markers
sig.genes <- Clust.13.Markers[Clust.13.Markers$p_val_adj < 0.1, ]



# Heatmap of Clust 15 markers
sig.genes <- Clust.15.Markers[Clust.15.Markers$p_val_adj < 0.1, ]



# Plot DEGs as heatmap for vis justification for removal


```

### Use Clustifyr to call cluster identities

**Note: What is up with the mouse.ref here?**

```{r Clustifyr_cell_ID}

# Create output directories
if(!dir.exists("output/figures/Cell_type_annotation/Clustifyr")){
  dir.create("output/figures/Cell_type_annotation/Clustifyr", 
             recursive = T)
}


mouse.ref <- cbmc_ref
rownames(mouse.ref) <- str_to_title(rownames(mouse.ref))


res <- clustify(input = seurat.combined,
                cluster_col = "seurat_clusters",
                ref_mat = cbmc_ref,
                seurat_out = FALSE,
                query_genes = seurat.combined@assays$integrated@var.features)


res2 <- cor_to_call(cor_mat = res,                  # matrix correlation coefficients
                    cluster_col = "seurat_clusters") # name of column in meta.data containing cell clusters



print(plot_cor_heatmap(cor_mat = res))
dev.copy(pdf, "output/figures/Cell_type_annotation/Clustifyr/Heatmap_cluster_annotations.pdf")
dev.off()

# Remove unneeded data
rm(mouse.ref, res, res2)
```

### Use various SingleR databases to call cluster identities

```{r SingleR_cell_clasification}

# Create output directory
if(!dir.exists("output/figures/Cell_type_annotation/SingleR")){
  dir.create("output/figures/Cell_type_annotation/SingleR", 
             recursive = T)
}

################################################################
# Use a couple databased to get broad overview of clusters 
################################################################

##################################
# Use HumanPrimaryCellAtlasData
##################################
# Info: Human, Microarray, 713 samples, 37 main labels, 157 fine lables, Non-specific focus

HumanPrimaryCellAtlasData.data <- celldex::HumanPrimaryCellAtlasData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = HumanPrimaryCellAtlasData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = HumanPrimaryCellAtlasData.data$label.fine)

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_HumanPrimaryCellAtlasData_db.pdf")
dev.off()

##########################
# Use BlueprintEncodeData
##########################
# Info: Human, RNAseq, 259 samples, 24 main labels, 43 fine lables, Non-specific focus

BlueprintEncodeData.data <- celldex::BlueprintEncodeData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = BlueprintEncodeData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = BlueprintEncodeData.data$label.fine)

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_BlueprintEncodeData_db.pdf")
dev.off()

##########################################
# Use NovershternHematopoieticData
##########################################
# Info: Human, Microarray, 211 samples, 17 main labels, 38 fine lables, Hematopoietic & Immune focus

NovershternHematopoieticData.data <- celldex::NovershternHematopoieticData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = NovershternHematopoieticData.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = NovershternHematopoieticData.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_NovershternHematopoietic_db.pdf")
dev.off()

#####################
# Use ImmGenData
#####################
# Info: Mouse, Microarray, 830 samples, 20 main labels, 253 fine lables, Hematopoietic & Immune focus

ImmGen.data <- celldex::ImmGenData()

# Convert GeneID to match human
ImmGen.data.counts <- ImmGen.data@assays@data$logcounts
rownames(ImmGen.data.counts) <- toupper(rownames(ImmGen.data.counts))


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = ImmGen.data.counts, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = ImmGen.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_ImmGen_db.pdf")
dev.off()




################################################################
# Most useful database is probably the MonacoImmuneData
################################################################

#########################
# Use MonacoImmuneData
#########################
# Info: Human, RNAseq, 114 samples, 11 main labels, 29 fine lables, Immune cell focus
Immune.data <- celldex::MonacoImmuneData()


# First calcualte cell ID using all available labels
SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = Immune.data, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = Immune.data$label.fine)


# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_all_labels_Monaco_db.pdf")
dev.off()


# Restrict labels to biologicaly relevant 
Immune.data.counts <- Immune.data@assays@data$logcounts

pattern <- c("CD8", "MAIT", "gd", "Intermediate")

labels.keep <- grepl(paste0(pattern, collapse = "|"), Immune.data$label.fine)

Immune.data.counts <- Immune.data.counts[,labels.keep]

SingleR.pred <- SingleR(test = seurat.combined@assays$integrated@data, 
                        ref = Immune.data.counts, 
                        method = "cluster",
                        clusters = seurat.combined@meta.data$seurat_clusters,
                        labels = Immune.data$label.fine[labels.keep])

# Plot 
plotScoreHeatmap(SingleR.pred, 
                 show_colnames = TRUE)

dev.copy(pdf, "output/figures/Cell_type_annotation/SingleR/Heatmap_cluster_annotations_limited_labels_Monaco_db.pdf")
dev.off()

# Remove unneeded datasets
rm(HumanPrimaryCellAtlasData.data,
   BlueprintEncodeData.data,
   NovershternHematopoieticData.data,
   ImmGen.data, ImmGen.data.counts,
   Immune.data, Immune.data.counts,
   SingleR.pred)

```

### Myeloid and Mitochondrial populations

```{r Remove_clusters}

# Remove cluster 13 and 15
seurat.combined <- subset(seurat.combined, idents = c(0:12, 14))

# Check clusters are removed
levels(seurat.combined@meta.data$seurat_clusters)

# Save old cluster IDs
seurat.combined@meta.data$seurat_clusters_old <- seurat.combined@meta.data$seurat_clusters


```

## Recalculate UMAP and Visualise {.tabset}

### Recalculate UMAP

```{r Recalculate_UMAP}

###########################
# Recalculate UMAP
###########################

DefaultAssay(seurat.combined) <- "integrated"

# Scale data
seurat.combined <- ScaleData(seurat.combined, 
                             verbose = TRUE)

# Run PCA
seurat.combined <- RunPCA(seurat.combined, 
                          npcs = 30, 
                          verbose = TRUE)

# Find Neighbors
seurat.combined <- FindNeighbors(seurat.combined, 
                                 reduction = "pca", 
                                 k.param = 20,
                                 dims = 1:20)

# Find clusters
seurat.combined <- FindClusters(seurat.combined, 
                                random.seed = 42,
                                resolution = 0.4)


# Run UMAP
seurat.combined <- RunUMAP(object = seurat.combined,
                           reduction = "pca",
                           dims = 1:20,
                           umap.method = "uwot",
                           n.neighbors = 30, # 5 to 50
                           min.dist = 0.3, # Sensible values are in the range 0.001 to 0.5
                           seed.use = 42)

```

### Vis new UMAP

```{r Visualise_new_UMAP_projection}

# Create output directory
if(!dir.exists("output/figures/UMAP")){
  dir.create("output/figures/UMAP", 
             recursive = T)
}


Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters_new

# Plot UMAP projection
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + 
  ggtitle("UMAP new projection and clust IDs")

dev.copy(pdf, "output/figures/UMAP/UMAP_new_clust_IDs_numbered.pdf")
dev.off()

# Plot UMAP projection with old clust IDs
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters_old

UMAPPlot(object = seurat.combined,
         label = TRUE, 
         label.size = 6) + 
  ggtitle("UMAP new projection - original clust IDs")

dev.copy(pdf, "output/figures/UMAP/UMAP_original_clust_IDs_numbered.pdf")
dev.off()

```

### Rename clusters

```{r rename_clusters}

# Name clusters

# Save cluster IDs - new ids = those after removal of clusters
seurat.combined@meta.data$seurat_clusters_new <- seurat.combined@meta.data$seurat_clusters

# Set Idents to cluster IDs following cluster removal 
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters


# Rename classes.
seurat.combined <- RenameIdents(object = seurat.combined,
                                `0` = "Cytotoxic",
                                `1` = "Naive_like_3",
                                `2` = "Exhausted_1", 
                                `3` = "Type_I_IFN",
                                `4` = "Naive_like_1_CM", # Central memory?
                                `5` = "Naive_like_2_SC", # Stem-cell-like
                                `6` = "Stimulated_1", # Derived from cytotoxic ?
                                `7` = "Stimulated_exhausted",
                                `8` = "gd_T_non_g9d2", 
                                `9` = "Exhausted_2",
                                `10` = "MAIT", 
                                `11` = "TRM", 
                                `12` = "gd_T_g9d2", 
                                `13` = "Proliferative")


# Relevel idents variable to group clusters into order of future modules 

# Module: Naive / Stem-like 
# Naïve_like_1_CM
# Naïve_like_2_SC
# Naïve_like_3

# Module: Activated
# Cytotoxic
# Type_I_IFN
# Stimulated_1

# Module: Exhaustion
# Stimulated_exhausted
# Exhausted_1, 
# Exhausted_2
# TRM

# Module: Innate
# gd_T_g9d2
# gd_T_non_g9d2 
# MAIT 

# Module: Cycling
# Proliferative


# reset levels of factor variable 
seurat.combined@active.ident <- factor(seurat.combined@active.ident, 
                                       levels = c("Naive_like_1_CM",
                                                  "Naive_like_2_SC", 
                                                  "Naive_like_3", 
                                                  "Cytotoxic",
                                                  "Type_I_IFN",
                                                  "Stimulated_1",
                                                  "Stimulated_exhausted",
                                                  "Exhausted_1",
                                                  "Exhausted_2", 
                                                  "TRM", 
                                                  "gd_T_g9d2", 
                                                  "gd_T_non_g9d2", 
                                                  "MAIT",
                                                  "Proliferative"))



# Change "seurat_clusters" metadata label to new ident names as this slot is used in downstream plotting
seurat.combined@meta.data$seurat_clusters <- Idents(seurat.combined)

```

### UMAP with Named clusters

```{r Vis_Named_Clusters_UMAP}

# Create output directory
if(!dir.exists("output/figures/UMAP")){
  dir.create("output/figures/UMAP", 
             recursive = T)
}


##########################################
# Plot UMAPs with cluster names
##########################################


Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

# UMAP named clusters
UMAPPlot(object = seurat.combined,
         pt.size = 1,
         label = FALSE, 
         cols = clust.cols) + 
  ggtitle("UMAP named clusters")

dev.copy(pdf, "output/figures/UMAP/UMAP_clusters.pdf")
dev.off()

# UMAP named clusters - labeled 
UMAPPlot(object = seurat.combined,
         label = TRUE, 
         pt.size = 1,
         label.size = 6,
         cols = clust.cols) + 
  NoLegend() +
  ggtitle("UMAP named clusters")

dev.copy(pdf, "output/figures/UMAP/UMAP_clusters_labeled.pdf")
dev.off()


#############
# Condition
#############

# Split by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "condition",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by condition")

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_conditions.pdf")
dev.off()

# Split by condition // No legend
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "condition",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by condition") + 
  NoLegend()

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_conditions_Nolegend.pdf")
dev.off()

# Group by condition
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         group.by = "condition",
         cols = Condition.cols,
         label.size = 6) + 
  ggtitle("UMAP group by condition")

dev.copy(pdf, "output/figures/UMAP/UMAP_groupby_conditions.pdf")
dev.off()


#############
# Sample
#############

# Split by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         pt.size = 1,
         split.by = "group",
         label.size = 6,
         cols = clust.cols) + 
  ggtitle("UMAP split by Sample")

dev.copy(pdf, "output/figures/UMAP/UMAP_splitby_sample.pdf")
dev.off()


# Group by Sample
UMAPPlot(object = seurat.combined,
         label = FALSE, 
         group.by = "group",
         pt.size = 1,
         label.size = 6) + 
  ggtitle("UMAP group by Sample")

dev.copy(pdf, "output/figures/UMAP/UMAP_groupby_sample.pdf")
dev.off()







```

### Saving dim reduction Embeddings to metadata

```{r Save_dimreduction_embeddings}

# UMAP embeddings
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$umap@cell.embeddings[,1], "UMAP_1")
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$umap@cell.embeddings[,2], "UMAP_2")

# Save PCA (Dim 1 and 2) embeddings
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$pca@cell.embeddings[,1], "PCA_1")
seurat.combined <- AddMetaData(seurat.combined, seurat.combined@reductions$pca@cell.embeddings[,2], "PCA_2")

head(seurat.combined@meta.data)

```

### Create Cluster by condition metadata

```{r Generate_metadata_for_Cluster_by_Condition}

######################################################
# Create additional Metadata for downstream analysis
######################################################
# Now that clusters are cleaned and renamed 
# Generate a joint cluster & condition_ID variable

# Using named clusters
seurat.combined@meta.data$condition_clust <- paste(seurat.combined@meta.data$condition, 
                                                   seurat.combined@meta.data$seurat_clusters, sep = "_")

```

## Export large data {.tabset}

### Export seurat object

```{r export_RDS_non_imputed}
if(!quick.load){
  saveRDS(seurat.combined, file = "Exported_RDS_files/seurat_combined_no_imputation.rds")
}

```

### Save large data tables

```{r write_data, eval = FALSE}

if(long.compute){
  
  
  # Create output directory
  if(!dir.exists("output/tables/Large_dataframes")){
    dir.create("output/tables/Large_dataframes", 
               recursive = T)
  }
  
  
  # Raw data
  save.data.frame.function(seurat.combined@assays$RNA@counts,
                           path = "output/tables/Large_dataframes/", 
                           title = "Raw_dataframe")
  
  # Normed data
  save.data.frame.function(seurat.combined@assays$RNA@data,
                           path = "output/tables/Large_dataframes/",
                           title = "filtered_dataframe")
  
  # Scaled data
  save.data.frame.function(seurat.combined@assays$RNA@scale.data,
                           path = "output/tables/Large_dataframes/", 
                           title = "scaled_dataframe")
  
  # PCA embeddings
  save.data.frame.function(seurat.combined@reductions$pca@cell.embeddings,
                           path = "output/tables/Large_dataframes/", 
                           title = "RNA_PCA")
  
  # UMAP embeddings
  save.data.frame.function(seurat.combined@reductions$umap@cell.embeddings, 
                           path = "output/tables/Large_dataframes/", 
                           title = "RNA_UMAP")
  
  # Metadata
  save.data.frame.function(seurat.combined@meta.data,
                           path = "output/tables/Large_dataframes/", 
                           title = "Meta_data_dataframe")
  
  # Integrated normed values
  save.data.frame.function(seurat.combined@assays$integrated@data, 
                           path = "output/tables/Large_dataframes/", 
                           title = "filtered_integrated_dataframe")
  
  # Integrated scaled data
  save.data.frame.function(seurat.combined@assays$integrated@scale.data,
                           path = "output/tables/Large_dataframes/", 
                           title = "scaled_integrated_dataframe")
  
}

```

## Imputation {.tabset}

### Imputation calculation

```{r seurat_imputation}


######################
# Impute values 
######################
if(long.compute){
  seurat.combined <- RunALRA(seurat.combined, 
                             genes.use = rownames(seurat.combined))
}

# 8.37% of the values became negative in the scaling process and were set to zero
# The matrix went from 29.63% nonzero to 38.95% nonzero


####################
# Calculate k value
####################
if(long.compute){
  
  Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
  seurat.combined.small <- subset(seurat.combined, downsample = 100)
  
  ALRA.out <- RunALRA(seurat.combined.small,
                      k.only = TRUE)
  
  ggouts <- ALRAChooseKPlot(ALRA.out)
  
  ggouts
  dev.copy(pdf, "output/QC/Imputation_K_plot.pdf")
  dev.off()
}


# set default assay back to RNA
DefaultAssay(seurat.combined) <- "RNA"
Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters

```

## Export large data after imputation {.tabset}

### Export seurat object with imputation

```{r export_RDS}
if(!quick.load){
  saveRDS(seurat.combined, file = "Exported_RDS_files/seurat_combined.rds")
}

if(long.compute){
  
  
  # Create output directory
  if(!dir.exists("output/tables/Large_dataframes")){
    dir.create("output/tables/Large_dataframes", 
               recursive = T)
  }
  
  
  # Imputed values
  save.data.frame.function(seurat.combined@assays$alra@counts,
                           path = "output/tables/Large_dataframes/", 
                           title = "Imputed_counts_dataframe")
  
}


```



## Visualise distribution of cells across clusters/condition/modules {.tabset}

### Plot distribution of cells per each cluster

```{r Distribution_cells_per_cluster}

# Create output directory
if(!dir.exists("output/figures/Clust_and_Module_distribution")){
  dir.create("output/figures/Clust_and_Module_distribution", 
             recursive = T)
}

################################
# Plot cluster wise distribution
################################
default.mar <- par()$mar

par(mar = c(10.1, 5.1, 4.1, 2.1))


# Number of cells 
x <- table(seurat.combined@meta.data$seurat_clusters)

barplot(t(x), 
        main = "Number of cells per clust",
        ylab = "Number of cells",
        cex.names = 1,
        las = 2,
        ylim = c(0, 2500),
        legend = TRUE, 
        beside = TRUE)


dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Number_cells_per_clust.pdf")
dev.off()

# Frequency 
x <- prop.table(table(seurat.combined@meta.data$seurat_clusters)) * 100

barplot(t(x), 
        main = "Freq of cells per clust",
        ylab = "% of total",
        cex.names = 1, 
        las = 2,
        ylim = c(0, 20),
        legend = TRUE, 
        beside = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Freq_cells_per_clust.pdf")
dev.off()



###################################################
# Plot Freq per cluster per condition 
###################################################

# Be aware, US and Stim have diff total number of cells and therefore should be represented as a % normalised to total condition cell #

condition.cell.n <- table(seurat.combined@meta.data$condition)
US.cell.n <- condition.cell.n[1]
Stim.cell.n <- condition.cell.n[2]

Idents(seurat.combined) <- seurat.combined@meta.data$seurat_clusters
Cluster.cell.n <- table(Idents(seurat.combined), seurat.combined@meta.data$condition)

Cluster.cell.n[,1] <- Cluster.cell.n[,1]/US.cell.n*100
Cluster.cell.n[,2] <- Cluster.cell.n[,2]/Stim.cell.n*100

colSums(Cluster.cell.n) # sanity check, both should = 100%

barplot(t(Cluster.cell.n),
        main = "% of cells per cluster per condition",
        ylab = "% of cells",
        col = Condition.cols,
        cex.names = 1, 
        las = 2,
        ylim = c(0, 30), 
        beside = TRUE, 
        legend = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_cluster_per_condition.pdf")
dev.off()


# reset margin to default 
par(mar = c(default.mar))


#########################################
# Plot Module wise distribution
#########################################

# Plot total cell # per module 

Module.cell.n <- table(seurat.combined@meta.data$Module)

barplot(Module.cell.n, 
        main = "# of cells per Module", 
        xlab = "Module", 
        ylab = "# of cells",
        cex.names = 0.8, 
        ylim = c(0, 5000))

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Number_cells_per_Module.pdf")
dev.off()


# Plot freq of total per module
Module.freq <- prop.table(table(seurat.combined@meta.data$Module))*100

barplot(Module.freq,
        main = "% of cells per Module",
        xlab = "Module",
        ylab = "% of cells",
        cex.names = 0.8, 
        ylim = c(0, 40))

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_Module.pdf")
dev.off()


###################################################
# Plot Freq per module per condition 
###################################################

# Be aware, US and Stim have diff total number of cells and therefore should be represented as a % normalised to total condition cell #

condition.cell.n <- table(seurat.combined@meta.data$condition)
US.cell.n <- condition.cell.n[1]
Stim.cell.n <- condition.cell.n[2]

Idents(seurat.combined) <- seurat.combined@meta.data$Module
Module.cell.n <- table(Idents(seurat.combined), seurat.combined@meta.data$condition)

Module.cell.n[,1] <- Module.cell.n[,1]/US.cell.n*100
Module.cell.n[,2] <- Module.cell.n[,2]/Stim.cell.n*100

colSums(Module.cell.n) # sanity check, both should = 100%


barplot(t(Module.cell.n),
        main = "% of cells per Module per condition",
        xlab = "Module",
        ylab = "% of cells",
        col = Condition.cols,
        cex.names = 0.8, 
        ylim = c(0, 50), 
        beside = TRUE, 
        legend = TRUE)

dev.copy(pdf, "output/figures/Clust_and_Module_distribution/Percent_cells_per_Module_per_condition.pdf")
dev.off()



```


## Analysis optimisation code {.tabset}

### Optimise UMAP

```{r Optimise_UMAP_vis, eval = FALSE}


if(long.compute){
  
  # determine best min distance & neighbour val for UMAP
  
  # Set assay 
  DefaultAssay(seurat.combined) <- "integrated"
  
  # Set Idents
  Idents(seurat.combined) <- seurat.combined@meta.data$Module
  
  UMAP.optimise(seurat.combined)
}

# Default of n.neighbor = 30 and min.dist = 0.3 work well

```

### Altering the cluster calling resolution

```{r Differing_clust_resolution, eval = FALSE, echo = FALSE}

if(long.compute){
  
  # Set assay 
  DefaultAssay(seurat.combined) <- "RNA"
  
  clust.res.optimise(seurat.combined)
  
}

```


