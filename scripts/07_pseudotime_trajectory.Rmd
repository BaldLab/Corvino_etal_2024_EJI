---
title: "HNSCC_Trajectory_analysis"
author: "Dillon Corvino"
date: "03/02/2020"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: united
    highlight: tango
    df_print: paged
    code_folding: hide
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

Built with R version `{r} getRversion()`

## Setup {.tabset}

### Environment

```{r setup, message = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,  
  eval = TRUE, 
  tidy = TRUE
)

knitr::opts_knit$set(
  root.dir = "../"
)

# Environment Set up
rm(list = ls()) #Clean workspace
cat("\014")     #Clean Console
gc() # Free memory


# Establish working directory
library("rstudioapi")

# Set working directory to source file location
setwd(dirname(getActiveDocumentContext()$path))
setwd("..")

# Create output directories & load custom functions & colour scheme
source("scripts/Setup.R", local = knitr::knit_global())


library(Seurat)


# pipeline variables
quick.load <- TRUE
long.compute <- FALSE

# load saved seurat object with cluster annotations and imputation performed
if(quick.load){
  # Read in CD8 only dataset
  CD8.seurat <- LoadH5Seurat("saves/CD8_seurat.h5Seurat")
  Idents(CD8.seurat) <- CD8.seurat@meta.data$Clusters_l1
  DefaultAssay(CD8.seurat) <- "RNA"
}

```

## Trajectory analysis {.tabset}

## Need to amend root node settings etc

### Preparing data for trajectory analysis

```{r Trajectory_data_prep, eval = TRUE}

#devtools::install_github("dynverse/dyno")

library(dyno)
library(dynplot)
library(dynmethods)
library(dynutils)
library(dynwrap)
library(tidyverse)
dynwrap::test_docker_installation(detailed = TRUE)

############################
# Read in and prepare data
############################

# perform pseudotime on just naive,isg, effector axis of dataset 

Idents(CD8.seurat) <- CD8.seurat@meta.data$Clusters_l1
input.seurat <- subset(CD8.seurat, idents = c("GZMK", "ISG", "Stimulated_1"))

input.seurat <- Seurat::FindVariableFeatures(input.seurat)
input.seurat <- Seurat::ScaleData(input.seurat)
input.seurat <- Seurat::RunPCA(input.seurat)
input.seurat <- Seurat::RunUMAP(object = input.seurat,
                           reduction = "pca",
                           dims = 1:20,
                           umap.method = "uwot",
                           n.neighbors = 30, # 5 to 50
                           min.dist = 0.3, # Sensible values are in the range 0.001 to 0.5
                           seed.use = 42)

UMAPPlot(input.seurat,
         group.by = "Clusters_l1", 
         label = TRUE, 
         pt.size = 1) + NoLegend()




# Read in dataframes
raw.data <- as.data.frame(input.seurat@assays$RNA@counts)
normed.data <- as.data.frame(input.seurat@assays$RNA@data)


# data is organized cols = cells and rows = genes
head(raw.data[1:10, 1:10])
head(normed.data[1:10, 1:10])

# Need to inverse data for input into dyno package
raw.data <- t(raw.data)
head(raw.data[1:10, 1:10])

normed.data <- t(normed.data)
head(normed.data[1:10, 1:10])

# Check data structure
dim(raw.data) # 4,102 cells and 16,295 genes
dim(normed.data) # 4,102 cells and 16,295 genes


if(long.compute){  
  ##########################################
  # Creating Dyno formatted data structure
  ##########################################
  
  Dyno.data <- wrap_expression(counts = raw.data,
                               expression = normed.data)
  
  # Add grouping info
  group.vect <- input.seurat@meta.data$Clusters_l1
  names(group.vect) <- colnames(input.seurat)
  
  Dyno.data <- add_grouping(Dyno.data,
                            grouping = group.vect)
  
  
  # Add dim reduction
    UMAP.dims <- input.seurat@reductions$umap@cell.embeddings

  
  Dyno.data <- add_dimred(Dyno.data,
                          dimred = UMAP.dims)
  
  
  
}




```

### Running trajectory analysis

```{r trajectory_analysis, eval = FALSE}


save.dir <- "saves/Trajectory/"
  
  if(!dir.exists(paste0(save.dir))){
    dir.create(paste0(save.dir), 
               recursive = T)
  }
  

if(long.compute){
  
  
  ################################################
  # selecting best trajectory method for dataset
  ################################################
  # Using shiny app to get guidelines
  # guidelines <- guidelines_shiny(Dyno.total.data)
  
  
  answers <- dynguidelines::answer_questions(multiple_disconnected = NULL, 
                                             expect_topology = NULL, 
                                             expected_topology = NULL, 
                                             n_cells = 4102, 
                                             n_features = 20295, 
                                             memory = "200GB", 
                                             prior_information = NULL, 
                                             docker = TRUE)
  
  guidelines.vals <- dynguidelines::guidelines(answers = answers) 
  
  methods.selected <- guidelines.vals$methods_selected
  
  print(methods.selected)
  
  
  #####################
  # Infer Trajectory
  #####################
  
  ##############
  # Slingshot
  ##############
  
  slingshot <- infer_trajectory(Dyno.data, 
                                method = "dynverse/ti_slingshot:v0.9.9.01", 
                                parameters = NULL, 
                                give_priors = NULL, 
                                seed = set.seed(42),
                                verbose = TRUE)
  
  
  
  saveRDS(slingshot, file = paste0(save.dir, "slingshot.rds"))
  rm(slingshot)
  
}


```

### Visualisation trajectory analysis

```{r Visualisation_trajectory, eval = TRUE}

####################################
# Visualise exported trajectories 
####################################
 

output.dir <- "results/Pseudotime/"
  
  if(!dir.exists(paste0(output.dir))){
    dir.create(paste0(output.dir), 
               recursive = T)
  }
  



###############
# Slingshot
###############



# Create output directory
if(!dir.exists("output/figures/Trajectories/Slingshot")){
  dir.create("output/figures/Trajectories/Slingshot",
             recursive = T)}


# Read data
slingshot <- readRDS(paste0(save.dir, "slingshot.rds"))

# Modify variables

# Set root milestone
slingshot <- add_root(trajectory = slingshot, 
                        root_milestone_id = "1")

dynplot::plot_dimred(slingshot, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     label_milestones = T,
                     color_cells = "pseudotime")

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_plot_pseudotime.pdf")
dev.off()


dynplot::plot_dimred(angle, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     grouping = group.vect,
                     label_milestones = TRUE,
                     color_cells = "grouping")

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_plot_clusters.pdf")
dev.off()


# Rename milestone labels
milestone.labels <- c("Naive_memory", "Cytotoxic", "Stem-like", "Exhausted")
names(milestone.labels) <- c(1, 2, 3, 4)

slingshot <- label_milestones(slingshot, 
                                 labelling = milestone.labels)

dynplot::plot_dimred(slingshot, 
                     dimred = UMAP.dims,
                     hex_cells = TRUE, 
                     grouping = group.vect,
                     label_milestones = TRUE,
                     color_cells = "grouping")

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Slingshot_named_milestones.pdf")
dev.off()


# Cacluate trajectory feature importance

overall_feature_importances <- dynfeature::calculate_overall_feature_importance(slingshot, 
                                                                                expression_source = normed.data)

top.features <- overall_feature_importances %>% 
  top_n(50, importance) %>% 
  pull(feature_id)


plot_heatmap(slingshot, 
             expression_source = normed.data, 
             features_oi = top.features)

dev.copy(pdf, "output/figures/Trajectories/Slingshot/Combined_heatmap_top50_important_features.pdf")
dev.off()


# Calculate milestone importance
for(i in 1:length(slingshot$milestone_ids)){
  
  # Because milestone ids are not in order get the corresponding ID name for each milestone #
  logic.var <- names(slingshot$milestone_labelling) == i
  milestone.name <- paste0(slingshot$milestone_labelling[logic.var])
  
  
  milestone.feature.importance <- calculate_milestone_feature_importance(slingshot,
                                                                         expression_source = normed.data, 
                                                                         milestones_oi = i, 
                                                                         verbose = TRUE)
  
  
  top.features <- milestone.feature.importance %>% 
    top_n(25, importance) %>% 
    pull(feature_id)
  
  print(plot_heatmap(slingshot, 
                     expression_source = normed.data, 
                     features_oi = top.features))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Slingshot/Combined_heatmap_top25_milestone_", milestone.name, "_important_features.pdf"))
  dev.off()
  
  
}



################################################
# Base plots of other trajectories calculated
################################################


# Generate list of exported trajectories 
trajectories_master <- list.files("Exported_RDS_files/", ".rds")

print(trajectories_master)

for(i in 1:length(trajectories_master)){
  
  print(paste0("Plotting ", trajectories_master[i]))
  
  trajectory.val <- readRDS(paste0("Exported_RDS_files/", trajectories_master[i]))
  trajectory.name <- gsub(".rds", "", trajectories_master[i])
  
  
  #####################
  # Plot trajectory
  #####################
  
  # Vis pseudotime
  print(dynplot::plot_dimred(trajectory.val, 
                             dimred = UMAP.dims,
                             hex_cells = TRUE, 
                             label_milestones = TRUE,
                             color_cells = "pseudotime"))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Pseudotime_", trajectory.name, ".pdf"))
  dev.off()
  
  # Overlay clusters
  print(dynplot::plot_dimred(trajectory.val, 
                             dimred = UMAP.dims,
                             hex_cells = TRUE, 
                             grouping = group.vect,
                             label_milestones = TRUE,
                             color_cells = "grouping"))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Clusters_", trajectory.name, ".pdf"))
  dev.off()
  
  # Group clusters
  print(dynplot::plot_dimred(trajectory.val, 
                             color_cells = "grouping",
                             color_density = "grouping",
                             dimred = UMAP.dims,
                             hex_cells = TRUE,
                             grouping = group.vect))
  
  dev.copy(pdf, paste0("output/figures/Trajectories/Clusters_grouped_", trajectory.name, ".pdf"))
  dev.off()
  
}


rm(trajectory.val)




```

### Monocle trajectory

```{r Monocle_analysis}

# Create output directory
if(!dir.exists("results/figures/Trajectories/monocle")){
  dir.create("results/figures/Trajectories/monocle",
             recursive = T)}

# Load library
#BiocManager::install("monocle")
library("monocle")
#remotes::install_github('satijalab/seurat-wrappers', force = T)
#devtools::install_github("cole-trapnell-lab/monocle3") #needs to be installed

library(monocle3)

# Set assay and idents
DefaultAssay(CD8.seurat) <- "integrated"
Idents(CD8.seurat) <- CD8.seurat@meta.data$Clusters_l1
unique(Idents(CD8.seurat))

input.seurat <- subset(CD8.seurat, idents = c("ISG", "GZMK", "Stimulated_1"))
input.seurat <- Seurat::FindVariableFeatures(input.seurat, assay = "integrated")
input.seurat <- Seurat::ScaleData(input.seurat)
input.seurat <- Seurat::RunPCA(input.seurat, assay = "integrated")
input.seurat <- Seurat::RunUMAP(object = input.seurat,
                           reduction = "pca",
                           dims = 1:20,
                           umap.method = "uwot",
                           n.neighbors = 30, # 5 to 50
                           min.dist = 0.5, # Sensible values are in the range 0.001 to 0.5
                           seed.use = 42)

UMAPPlot(input.seurat,
         group.by = "Clusters_l1", 
         label = TRUE, 
         pt.size = 1) + NoLegend()



# convert seurat object to a cell data set
cds <- SeuratWrappers::as.cell_data_set(input.seurat, 
                                        group.by = "Clusters_l1")

# Cluster cells
cds <- monocle3::cluster_cells(cds, 
                               reduction_method = "UMAP")

monocle3::plot_cells(cds, 
                     color_cells_by = "partition", 
                     show_trajectory_graph = FALSE)



# Plot cell partition
p1 <- monocle3::plot_cells(cds, show_trajectory_graph = FALSE)
p2 <- monocle3::plot_cells(cds, color_cells_by = "partition", show_trajectory_graph = FALSE)

p1|p2

# Learn graph
cds <- monocle3::learn_graph(cds, 
                             use_partition = TRUE,
                             close_loop = TRUE,
                             
                             verbose = TRUE)

learn_graph_control = list(nn.k = NULL, 
                                                        prune_graph = TRUE, 
                                                        orthogonal_proj_tip = FALSE, 
                                                        minimal_branch_len = 20, 
                                                        nn.cores = 10,
                                                        euclidean_distance_ratio = 0.4)



# Plot monocle trajectory
monocle3::plot_cells(cds,
                     label_groups_by_cluster = FALSE, 
                     label_leaves = FALSE, 
                     label_branch_points = FALSE)




dev.copy(pdf, "output/figures/Trajectories/monocle/Monocle_trajectory.pdf")
dev.off()



# Plot monocle trajectory with leaves and branch points labelled
monocle3::plot_cells(cds, 
                     label_groups_by_cluster = FALSE,
                     label_leaves = TRUE, 
                     label_branch_points = TRUE)

dev.copy(pdf, "output/figures/Trajectories/monocle/Monocle_trajectory_branchpoints_labelled.pdf")
dev.off()



ciliated_cds_pr_test_res <- monocle3::graph_test(cds, neighbor_graph="principal_graph", cores=8)
pr_deg_ids <- row.names(subset(ciliated_cds_pr_test_res, q_value < 0.05))


pr_graph_test_res <- monocle3::graph_test(cds_subset, neighbor_graph="principal_graph", cores=8)
pr_deg_ids <- row.names(subset(pr_graph_test_res, morans_I > 0.01 & q_value < 0.05))



AFD_genes <- pr_deg_ids[1:5]
AFD_genes <- c("EOMES", "PRF1")
AFD_lineage_cds <- cds[rownames(cds) %in% AFD_genes,]


monocle3::plot_genes_in_pseudotime(AFD_lineage_cds,
                                   label_by_short_name = F,
                                   color_cells_by="Clusters_l1",
                                   min_expr=0.5)


gene_module_df <- monocle3::find_gene_modules(cds[pr_deg_ids,], resolution=1e-3)


  
cds_subset <- monocle3::choose_cells(cds)
cds <- monocle3::order_cells(cds)

monocle3::plot_cells(cds,
                     genes=c("ISG15"), 
                     show_trajectory_graph=FALSE, 
                     label_cell_groups=FALSE)



?plot_genes_in_pseudotime

####### WORK in progress ################



monocle3::plot_cells(cds, 
                     color_cells_by = "pseudotime", 
                     label_cell_groups = FALSE,
                     label_leaves = FALSE, 
                     label_branch_points = FALSE)


gene_module_df <- monocle3::find_gene_modules(cds, resolution = 1e-2)

unique(gene_module_df$module)

goi <- gene_module_df %>% 
  filter(module %in% c(7)) %>%
  dplyr::select(id)




monocle3::plot_cells(cds, 
           genes= goi$id,
           group_cells_by="partition",
           color_cells_by="partition",
           show_trajectory_graph=FALSE)

monocle3::plot_cells(cds,
           color_cells_by = "cluster",
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE)



AFD_genes <- c("ICOS", "PDCD1", "IFNG")
AFD_lineage_cds <- cds[rowData(cds) %in% AFD_genes, ]

my_genes <- row.names(subset(fData(cds), gene_short_name %in% goi$id)) 
cds_subset <- HSMM[my_genes,]

monocle3::plot_genes_in_pseudotime(cds,
                         color_cells_by="cluster",
                         label_by_short_name = F,
                         min_expr=0.5)

?plot_genes_in_pseudotime

ciliated_cds_pr_test_res <- monocle3::graph_test(cds, neighbor_graph="principal_graph", cores=4)
pr_deg_ids <- row.names(subset(ciliated_cds_pr_test_res, q_value < 0.05))


```

### Exporting metadata for velocity analysis

```{r exporting_metadata}
# export metadata for velocity analysis 
meta.data <- seurat.combined@meta.data

colnames(meta.data)
head(meta.data)

# Remove non-necessary columns 
meta.data <- meta.data %>%
  dplyr::select(group, condition, seurat_clusters, UMAP_1, UMAP_2, PCA_1, PCA_2, Module, condition_clust, condition_module)

# Create new barcode columns 
meta.data$uniq_barcode <- rownames(meta.data)

meta.data$barcode <- gsub(".*_", "", rownames(meta.data))

write.table(meta.data, "output/tables/Meta_data.txt", sep = "\t", row.names = F, quote = F)



```


