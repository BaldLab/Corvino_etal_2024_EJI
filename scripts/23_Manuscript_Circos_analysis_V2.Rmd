---
title: "HNSCC_scTCRseq_Circos_analysis"
author: "Dillon Corvino"
date: "03/02/2020"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: united
    highlight: tango
    df_print: paged
    code_folding: hide
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---


Built with R version `r getRversion()`

## Setup {.tabset}

### Environment
```{r setup, message = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,  
  eval = TRUE, 
  tidy = TRUE
)

knitr::opts_knit$set(
  root.dir = "../"
)

# Environment Set up
rm(list = ls()) #Clean workspace
cat("\014")     #Clean Console
gc() # Free memory


# Establish working directory
library("rstudioapi")

# Set working directory to source file location
setwd(dirname(getActiveDocumentContext()$path))
setwd("..")

# Load packages
#source("R/Load_packages.R", local = knitr::knit_global())

# Create output directories & load custom functions & colour scheme
source("R/Setup.R", local = knitr::knit_global())

# pipeline variables
quick.load <- TRUE
long.compute <- FALSE
do.plot <- FALSE


# load saved seurat object with cluster annotations and imputation performed
if(quick.load){
  
# Read in CD8 only dataset
CD8.seurat <- readRDS("Exported_RDS_files/CD8_seurat.rds")
Idents(CD8.seurat) <- CD8.seurat@meta.data$Clusters_l1
DefaultAssay(CD8.seurat) <- "RNA"

# CD8 TCR data
CD8.seurat.tcr <- readRDS("Exported_RDS_files/CD8_seurat_tcr.rds")
CD8.seurat.tcr.filt <- readRDS("Exported_RDS_files/CD8_seurat_tcr_filt.rds")
  
}

```


## Circos AKA Chord Diagrams {.tabset}

### Set up data for chord diagrams 
```{r setup_chord}

#Here is a little more inuitive for me, seperate the Stim and US cells, create a matrix that counts the shared clonotype by clusters, correct for overcounting and visuaize both conditions using Chord Diagrams. 

#For the most part the function `getCircles()` does all the processing. 


### Proportion parameter to get getGircles(), will divide by total size of none-NA clonotypes
###clonotypesOnly can be used to just count the clonotypes shared between cluster (removes cell numbers from the equation)




source("R/Functions/getCircles_functionV2.R", local = knitr::knit_global())


# Set up variables 
remove.self.ribbons <- TRUE


# Subset dataset by condition
meta.tcr <- CD8.seurat.tcr.filt@meta.data

US <- subset(meta.tcr, condition == "US")

Stim <- subset(meta.tcr, condition == "Stim")


# Collect clonotype overlaps and format data for Circos plots
US <- getCircles(US, 
                 proportion = TRUE, 
                 clonotypesOnly = TRUE)

Stim <- getCircles(Stim,
                   proportion = TRUE, 
                   clonotypesOnly = TRUE)

Chord.list <- list(US, Stim)

names(Chord.list) <- c("US", "Stim")


# Remove ribbons originating and ending in the same cluster
if(remove.self.ribbons){
  for(i in seq_along(names(Chord.list))){
    logic.vec <- Chord.list[[i]][ ,1] == Chord.list[[i]][ ,2]
    Chord.list[[i]] <- Chord.list[[i]][!logic.vec, ]
  }
}


# Defining grid colors
grid.cols <- CD8.cols


```

## Plotting Chord Diagrams
```{r chord_plots}

# Create output directory

fig.output <- "output/figures/Manuscript/Figure3/ChordVisualizations"


if(!dir.exists(paste0(fig.output))){
  dir.create(paste0(fig.output), 
             recursive = T)
}






library(circlize)


####################
# Plot US dataset
####################
circos.clear()


pdf(paste0(fig.output, "/Unstimulated_TCRcircos.pdf"), height=10, width=10)

chordDiagram(Chord.list[["US"]], 
             grid.col = grid.cols, 
             self.link = 1, 
             annotationTrack = "grid", 
             preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(Chord.list[["US"]]))))))


circos.track(track.index = 1, 
             panel.fun = function(x, y) {
               xlim = get.cell.meta.data("xlim")
               xplot = get.cell.meta.data("xplot")
               ylim = get.cell.meta.data("ylim")
               sector.name = get.cell.meta.data("sector.index")
               
               circos.text(mean(xlim), 
                           ylim[1], 
                           sector.name, 
                           facing = "clockwise",
                           niceFacing = TRUE, 
                           adj = c(0, 0.5)) 
             }, 
             bg.border = NA)

dev.off()

circos.clear()

####################
# Plot Stim dataset
####################

pdf(paste0(fig.output, "/Stimulated_TCRcircos.pdf"), height=10, width=10)

chordDiagram(Chord.list[["Stim"]], 
             grid.col = grid.cols, 
             self.link = 1, 
             annotationTrack = "grid", 
             preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(Chord.list[["Stim"]]))))))

circos.track(track.index = 1, 
             panel.fun = function(x, y) {
               xlim = get.cell.meta.data("xlim")
               xplot = get.cell.meta.data("xplot")
               ylim = get.cell.meta.data("ylim")
               sector.name = get.cell.meta.data("sector.index")
               
               circos.text(mean(xlim), 
                           ylim[1], 
                           sector.name, 
                           facing = "clockwise",
                           niceFacing = TRUE, 
                           adj = c(0, 0.5)) 
             }, 
             bg.border = NA)

dev.off()

circos.clear()

```

## Plotting Integrated Chord Diagram
```{r integrated_chord}

#2020/09/01 Still needs adjustment for very small groups to get secondary track - as of now, the code will segregate the clusters between #conditions, but errors at the **for(species in unique(combined$from))** loop


# Set colour scheme 
color_species  <- CD8.cols

color_regions  <- condition.cols

# Calculate overlap
output <- getIntegratedCircle(meta.tcr, 
                              proportion = F, 
                              clonotypesOnly = TRUE) # clonotypesOnly will ignore cell # and just count the # of clonotypes that overlap

dim(output) # 253

######################################
# Remove intra-condition links 
######################################

# preserve self links (note: there are only 6 clones unique to condition/cluster)
output[output$from == output$to & output$from_group == output$to_group, ]

# Self-links
self.links <- output$from == output$to & output$from_group == output$to_group

# Inter-condition links only
inter.condition <- output$from_group != output$to_group

# Keep all inter.condition links or self-links
output <- output[self.links | inter.condition, ]
dim(output) # 143



# note there is no directionality in the dataset - simply overlap between clusters in conditions 
df2 <- data.frame(clust_1 = paste(output[[5]], output[[2]], sep = "|"),
                  clust_2 = paste(output[[4]], output[[1]], sep = "|"),
                  value = output[[3]], 
                  stringsAsFactors = FALSE)

##############################
# Set plotting params
##############################

# Ensure plotting params are all cleared
circos.clear()

# Plotting order
df2 <- df2 %>%
  dplyr::arrange(clust_1, clust_2)

order.val <- c(df2$clust_2, df2$clust_1)

# Track colour
grid.col.1 <- color_species
names(grid.col.1) <- paste0("US|", names(grid.col.1))

grid.col.2 <- color_species
names(grid.col.2) <- paste0("Stim|", names(grid.col.2))

grid.col <- c(grid.col.1, grid.col.2)

# Set gap variable
gap.var <- rep(1, length(unique(names(grid.col))))
names(gap.var) <- unique(names(grid.col))

logic.vec <- grepl("US\\|Type_I_IFN", names(gap.var))
gap.var[logic.vec] <- 10

logic.vec <- grepl("Stim\\|Type_I_IFN", names(gap.var))
gap.var[logic.vec] <- 10

circos.par(gap.after = gap.var)


# Colour ribbons by originating node (i.e US node)
for(i in seq_along(color_species)){
  
  
  link.col <- rep(transparent.col("Gray", percent = 80), length(df2$clust_1))
  
  link.col[df2$clust_1 == paste0("US|", names(color_species)[i])] <- color_species[i]
  
  # Set gap
  circos.par(gap.after = gap.var)
  
  
  ####Ploting
  pdf(paste0(fig.output, "/Circos_inter_condition_US_", names(color_species)[i], ".pdf"), height=10, width=10)
  
  
  chordDiagram(df2, 
               self.link = 1, 
               annotationTrack = c("grid"),
               grid.col = grid.col,
               col = link.col,
               order = order.val,
               directional = 0,
               link.overlap = FALSE,
               preAllocateTracks = list(
                 track.height = 0.3,
                 track.margin = c(0.05, 0)
               )
  )
  
  
  circos.track(track.index = 1, 
               panel.fun = function(x, y) {
                 xlim = get.cell.meta.data("xlim")
                 xplot = get.cell.meta.data("xplot")
                 ylim = get.cell.meta.data("ylim")
                 sector.name = get.cell.meta.data("sector.index")
                 
                 circos.text(mean(xlim), 
                             ylim[1], 
                             sector.name, 
                             facing = "clockwise",
                             niceFacing = TRUE, 
                             adj = c(0, 0.5)) 
               }, 
               bg.border = NA)
  
  
  dev.off()
  
  circos.clear()
  
}



# Colour ribbons by target node (i.e Stim node)
for(i in seq_along(color_species)){
  
temp.df <- df2
  
temp.df$clust_1 <- gsub(".*\\|", "", df2$clust_1)
temp.df$clust_2 <- gsub(".*\\|", "", df2$clust_2)

temp.df$node_col <- NA

for(j in seq_along(names(color_species))){
index.var <- which(temp.df$clust_1 == names(color_species)[j])

temp.df$node_col[index.var] <- color_species[j]


}


  # Initialise colour vector
  link.col <- rep(transparent.col("Gray", percent = 80), length(df2$clust_2))
  
  # Find ribbons for ending at target node
  logic.vec <- df2$clust_2 == paste0("Stim|", names(color_species)[i])
  
  # Identify source node colours to use for ribbons
  link.col[logic.vec] <- temp.df$node_col[logic.vec]


  # Set gap
  circos.par(gap.after = gap.var)
  
  
  ####Ploting
  pdf(paste0(fig.output, "/Circos_inter_condition_Stim_", names(color_species)[i], ".pdf"), height=10, width=10)
  
  
  chordDiagram(df2, 
               self.link = 1, 
               annotationTrack = c("grid"),
               grid.col = grid.col,
               col = link.col,
               order = order.val,
               directional = 0,
               link.overlap = FALSE,
               preAllocateTracks = list(
                 track.height = 0.3,
                 track.margin = c(0.05, 0)
               )
  )
  
  
  circos.track(track.index = 1, 
               panel.fun = function(x, y) {
                 xlim = get.cell.meta.data("xlim")
                 xplot = get.cell.meta.data("xplot")
                 ylim = get.cell.meta.data("ylim")
                 sector.name = get.cell.meta.data("sector.index")
                 
                 circos.text(mean(xlim), 
                             ylim[1], 
                             sector.name, 
                             facing = "clockwise",
                             niceFacing = TRUE, 
                             adj = c(0, 0.5)) 
               }, 
               bg.border = NA)
  
  
  dev.off()
  
  circos.clear()
  
}





# Plot all data with no particular ribbon highlighted

# Set gap
circos.par(gap.after = gap.var)


####Ploting
pdf(paste0(fig.output, "/Circos_inter_condition_all_ribbons.pdf"), height=10, width=10)


chordDiagram(df2, 
             self.link = 1, 
             annotationTrack = c("grid"),
             grid.col = grid.col,
             order = order.val,
             directional = 0,
             link.overlap = FALSE,
             preAllocateTracks = list(
               track.height = 0.3,
               track.margin = c(0.05, 0)
             )
)


circos.track(track.index = 1, 
             panel.fun = function(x, y) {
               xlim = get.cell.meta.data("xlim")
               xplot = get.cell.meta.data("xplot")
               ylim = get.cell.meta.data("ylim")
               sector.name = get.cell.meta.data("sector.index")
               
               circos.text(mean(xlim), 
                           ylim[1], 
                           sector.name, 
                           facing = "clockwise",
                           niceFacing = TRUE, 
                           adj = c(0, 0.5)) 
             }, 
             bg.border = NA)


dev.off()

circos.clear()


```

